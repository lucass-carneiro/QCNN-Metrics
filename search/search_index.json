{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"QCNN Toolkit This is a python package for training quantum convolutional neural networks. It uses Pennylane for building quantum circuits and can be trained with Numpy or Torch backends on CPUs or GPUs. The code also supports checkpoints, recovery and streaming IO via the ADIOS2 library. This program trains quantum circuits to solve the following problems: 1D Function fitting ODE solving","title":"Home"},{"location":"apptainer/","text":"Containers When running in an HPC cluster, users often don't have access to administrative rights. This can cause issues if the system-wide version of python is too old or if the cluster does not have pip enabled. To avoid such problems, QCNN-Metrics provides a recipe for building an Apptainer (formerly Singularity) image in the sing folder, together with a Slurm script and a bash script that takes care of job submission and virtual environment activation on a cluster. Note that the cluster must have Apptainer installed for this to work. Building the image In a machine where you have root access (this is mandatory), from inside the QCNN-Metrics folder issue sudo apptainer build qcnn.simg singularity/qcnn.recipe After the image is built, copy it over to the cluster where you will be running the code. Submitting the job TODO: This section needs more detail sbatch --job-name=fit_0 job.slurm /home/lucas.t/qcnn.simg /home/lucas.t/fit.toml /home/lucas.t/QCNN-Metrics","title":"Apptainer images"},{"location":"apptainer/#containers","text":"When running in an HPC cluster, users often don't have access to administrative rights. This can cause issues if the system-wide version of python is too old or if the cluster does not have pip enabled. To avoid such problems, QCNN-Metrics provides a recipe for building an Apptainer (formerly Singularity) image in the sing folder, together with a Slurm script and a bash script that takes care of job submission and virtual environment activation on a cluster. Note that the cluster must have Apptainer installed for this to work.","title":"Containers"},{"location":"apptainer/#building-the-image","text":"In a machine where you have root access (this is mandatory), from inside the QCNN-Metrics folder issue sudo apptainer build qcnn.simg singularity/qcnn.recipe After the image is built, copy it over to the cluster where you will be running the code.","title":"Building the image"},{"location":"apptainer/#submitting-the-job","text":"TODO: This section needs more detail sbatch --job-name=fit_0 job.slurm /home/lucas.t/qcnn.simg /home/lucas.t/fit.toml /home/lucas.t/QCNN-Metrics","title":"Submitting the job"},{"location":"getting_started/","text":"Getting started with QCNN-Metrics The main interaction point of this package is the qcnn.py script, provided in the src folder of this repository. This script takes a single argument, a configuration file, that completely drives the behavior of the program. The next few sections will teach you to use its usage. Installing dependencies In order to use the qcnn.py script, dependencies need to be installed. The recommended way to install the required dependencies is by creating a virtual environment and using pip to install dependencies to that virtual environment. All the package's dependencies are specified in the requirements.txt file within the repository. To create a suitable virtual environment, issue the following commands from within the QCNN-Metrics repository folder: python -m venv venv source venv/bin/activate pip install --upgrade pip pip install --upgrade -r requirements.txt # Issue python commands using the libraries installed in the virtual environment deactivate # When done with using the environment Note that the virtual environment does not necessarily need to be named venv or located inside the QCNN-Metrics folder. Just be sure to point to the correct location of the requirements.txt file when creating the environment and to activate the correct environment prior to interacting with the code. Usage Activate the virtual environment with the dependencies installed and call the qcnn.py script. Issue the deactivate command when done. To activate the environment, issue source venv/bin/activate Where venv is the virtual environment folder where dependencies where installed. Next, to see the available options issue pyhton src/qcnn.py --help When all operations are done exit out of the virtual environment with deactivate","title":"Getting started"},{"location":"getting_started/#getting-started-with-qcnn-metrics","text":"The main interaction point of this package is the qcnn.py script, provided in the src folder of this repository. This script takes a single argument, a configuration file, that completely drives the behavior of the program. The next few sections will teach you to use its usage.","title":"Getting started with QCNN-Metrics"},{"location":"getting_started/#installing-dependencies","text":"In order to use the qcnn.py script, dependencies need to be installed. The recommended way to install the required dependencies is by creating a virtual environment and using pip to install dependencies to that virtual environment. All the package's dependencies are specified in the requirements.txt file within the repository. To create a suitable virtual environment, issue the following commands from within the QCNN-Metrics repository folder: python -m venv venv source venv/bin/activate pip install --upgrade pip pip install --upgrade -r requirements.txt # Issue python commands using the libraries installed in the virtual environment deactivate # When done with using the environment Note that the virtual environment does not necessarily need to be named venv or located inside the QCNN-Metrics folder. Just be sure to point to the correct location of the requirements.txt file when creating the environment and to activate the correct environment prior to interacting with the code.","title":"Installing dependencies"},{"location":"getting_started/#usage","text":"Activate the virtual environment with the dependencies installed and call the qcnn.py script. Issue the deactivate command when done. To activate the environment, issue source venv/bin/activate Where venv is the virtual environment folder where dependencies where installed. Next, to see the available options issue pyhton src/qcnn.py --help When all operations are done exit out of the virtual environment with deactivate","title":"Usage"},{"location":"module_ansatz/","text":"Module ansatz This module defines an abstract anstz circuit. An ansatz circuit is the combination of training and encoding blocks as defined here Ansatz Abstract class defining an ansatz quantum circuit that combines encoding and training blocks. See here for details Source code in src/ansatz.py class Ansatz(metaclass=abc.ABCMeta): \"\"\" Abstract class defining an `ansatz` quantum circuit that combines encoding and training blocks. See [here](https://arxiv.org/abs/2008.08605) for details \"\"\" @abc.abstractmethod def S(self, x): \"\"\" The enconder block for the ansatz circuit. Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" pass @abc.abstractmethod def W(self, theta): \"\"\" The trainable block for the ansatz circuit. Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" pass @abc.abstractmethod def ansatz(self, w, x): \"\"\" The ansatz circuit containing enconding and trainable blocks. Parameters: w (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" pass S(x) abstractmethod The enconder block for the ansatz circuit. Parameters: Name Type Description Default x array An array-like object containing the datapoints to encode. required Source code in src/ansatz.py @abc.abstractmethod def S(self, x): \"\"\" The enconder block for the ansatz circuit. Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" pass W(theta) abstractmethod The trainable block for the ansatz circuit. Parameters: Name Type Description Default theta array An array-like object containing the list of trainable parameters. required Source code in src/ansatz.py @abc.abstractmethod def W(self, theta): \"\"\" The trainable block for the ansatz circuit. Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" pass ansatz(w, x) abstractmethod The ansatz circuit containing enconding and trainable blocks. Parameters: Name Type Description Default w array An object containing the list of trainable parameters. required x array An object containing the list of datapoints to encode. required Returns: Type Description ExpectationMP The expected value of the quantum circuit Source code in src/ansatz.py @abc.abstractmethod def ansatz(self, w, x): \"\"\" The ansatz circuit containing enconding and trainable blocks. Parameters: w (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" pass","title":"ansatz"},{"location":"module_ansatz/#module-ansatz","text":"This module defines an abstract anstz circuit. An ansatz circuit is the combination of training and encoding blocks as defined here","title":"Module ansatz"},{"location":"module_ansatz/#ansatz.Ansatz","text":"Abstract class defining an ansatz quantum circuit that combines encoding and training blocks. See here for details Source code in src/ansatz.py class Ansatz(metaclass=abc.ABCMeta): \"\"\" Abstract class defining an `ansatz` quantum circuit that combines encoding and training blocks. See [here](https://arxiv.org/abs/2008.08605) for details \"\"\" @abc.abstractmethod def S(self, x): \"\"\" The enconder block for the ansatz circuit. Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" pass @abc.abstractmethod def W(self, theta): \"\"\" The trainable block for the ansatz circuit. Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" pass @abc.abstractmethod def ansatz(self, w, x): \"\"\" The ansatz circuit containing enconding and trainable blocks. Parameters: w (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" pass","title":"Ansatz"},{"location":"module_ansatz/#ansatz.Ansatz.S","text":"The enconder block for the ansatz circuit. Parameters: Name Type Description Default x array An array-like object containing the datapoints to encode. required Source code in src/ansatz.py @abc.abstractmethod def S(self, x): \"\"\" The enconder block for the ansatz circuit. Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" pass","title":"S"},{"location":"module_ansatz/#ansatz.Ansatz.W","text":"The trainable block for the ansatz circuit. Parameters: Name Type Description Default theta array An array-like object containing the list of trainable parameters. required Source code in src/ansatz.py @abc.abstractmethod def W(self, theta): \"\"\" The trainable block for the ansatz circuit. Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" pass","title":"W"},{"location":"module_ansatz/#ansatz.Ansatz.ansatz","text":"The ansatz circuit containing enconding and trainable blocks. Parameters: Name Type Description Default w array An object containing the list of trainable parameters. required x array An object containing the list of datapoints to encode. required Returns: Type Description ExpectationMP The expected value of the quantum circuit Source code in src/ansatz.py @abc.abstractmethod def ansatz(self, w, x): \"\"\" The ansatz circuit containing enconding and trainable blocks. Parameters: w (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" pass","title":"ansatz"},{"location":"module_ansatzes/","text":"Module ansatzes This module defines the actual ansatzes supported in the code. All ansatzes are specializations of the ansatz.Ansatz abstract base class. AnsatzConv Bases: Ansatz This anstaz uses Pauli X rotations as encoding and convolutional layers from the conv_layer module as trainable blocks Source code in src/ansatzes.py class AnsatzConv(ansatz.Ansatz): \"\"\" This anstaz uses Pauli X rotations as encoding and convolutional layers from the `conv_layer` module as trainable blocks \"\"\" def __init__(self, num_qubits: int, conv_layer, random_generator): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. conv_layer (any): The convolutional layer to use in the circuit. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self.num_qubits = num_qubits self.conv_layer = conv_layer self.param_shape = (2, num_qubits, conv_layer.ppb) self.weights = 2 * np.pi * \\ random_generator.random(size=self.param_shape) def S(self, x): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x: An array-like object containing the datapoints to encode. \"\"\" for w in range(self.num_qubits): qml.RX(x, wires=w) def conv_block(self, p): \"\"\" Constructs the trainable part of the circuit. Each convolutional layer is applied to a pair of quibits. As a \"boundary condition\", the last quibit pairs with the first. \"\"\" qml.Barrier(wires=range(self.num_qubits)) for i in range(self.num_qubits): self.conv_layer.layer(p[i], [i, (i + 1) % self.num_qubits]) qml.Barrier(wires=range(self.num_qubits)) def W(self, theta): \"\"\" The trainable block for the ansatz circuit, using convolutional layers Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" self.conv_block(theta) def ansatz(self, weights, x=None): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self.W(weights[0]) self.S(x) self.W(weights[1]) return qml.expval(qml.PauliZ(wires=0)) S(x) The enconder block for the ansatz circuit, using Pauli X rotations x: An array-like object containing the datapoints to encode. Source code in src/ansatzes.py def S(self, x): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x: An array-like object containing the datapoints to encode. \"\"\" for w in range(self.num_qubits): qml.RX(x, wires=w) W(theta) The trainable block for the ansatz circuit, using convolutional layers Parameters: Name Type Description Default theta array An array-like object containing the list of trainable parameters. required Source code in src/ansatzes.py def W(self, theta): \"\"\" The trainable block for the ansatz circuit, using convolutional layers Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" self.conv_block(theta) __init__(num_qubits, conv_layer, random_generator) Initialize the object Parameters: Name Type Description Default num_qubits int The number of qubits to use in the quantum circuit. required conv_layer any The convolutional layer to use in the circuit. required random_generator Generator A random number generator to use for trainable parameter initialization. required Source code in src/ansatzes.py def __init__(self, num_qubits: int, conv_layer, random_generator): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. conv_layer (any): The convolutional layer to use in the circuit. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self.num_qubits = num_qubits self.conv_layer = conv_layer self.param_shape = (2, num_qubits, conv_layer.ppb) self.weights = 2 * np.pi * \\ random_generator.random(size=self.param_shape) ansatz(weights, x=None) The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: Name Type Description Default weights array An object containing the list of trainable parameters. required x array An object containing the list of datapoints to encode. None Returns: Type Description ExpectationMP The expected value of the quantum circuit Source code in src/ansatzes.py def ansatz(self, weights, x=None): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self.W(weights[0]) self.S(x) self.W(weights[1]) return qml.expval(qml.PauliZ(wires=0)) conv_block(p) Constructs the trainable part of the circuit. Each convolutional layer is applied to a pair of quibits. As a \"boundary condition\", the last quibit pairs with the first. Source code in src/ansatzes.py def conv_block(self, p): \"\"\" Constructs the trainable part of the circuit. Each convolutional layer is applied to a pair of quibits. As a \"boundary condition\", the last quibit pairs with the first. \"\"\" qml.Barrier(wires=range(self.num_qubits)) for i in range(self.num_qubits): self.conv_layer.layer(p[i], [i, (i + 1) % self.num_qubits]) qml.Barrier(wires=range(self.num_qubits)) AnsatzSEL Bases: Ansatz This anstaz uses Pauli X rotations as encoding and strongly entangling layers as trainable blocks Source code in src/ansatzes.py class AnsatzSEL(ansatz.Ansatz): \"\"\" This anstaz uses Pauli X rotations as encoding and [strongly entangling layers](https://docs.pennylane.ai/en/stable/code/api/pennylane.StronglyEntanglingLayers.html) as trainable blocks \"\"\" def __init__(self, num_qubits: int, num_layers: int, random_generator): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. num_layers (int): The number of layers to use. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self.num_qubits = num_qubits self.num_layers = num_layers self.param_shape = (2, num_layers, num_qubits, 3) self.weights = 2 * np.pi * \\ random_generator.random(size=self.param_shape) def S(self, x): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" for w in range(self.num_qubits): qml.RX(x, wires=w) def W(self, theta): \"\"\" The trainable block for the ansatz circuit, using `StronglyEntanglingLayers` Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" StronglyEntanglingLayers(theta, wires=range(self.num_qubits)) def ansatz(self, weights, x=None): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self.W(weights[0]) self.S(x) self.W(weights[1]) return qml.expval(qml.PauliZ(wires=0)) S(x) The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x (array): An array-like object containing the datapoints to encode. Source code in src/ansatzes.py def S(self, x): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" for w in range(self.num_qubits): qml.RX(x, wires=w) W(theta) The trainable block for the ansatz circuit, using StronglyEntanglingLayers Parameters: Name Type Description Default theta array An array-like object containing the list of trainable parameters. required Source code in src/ansatzes.py def W(self, theta): \"\"\" The trainable block for the ansatz circuit, using `StronglyEntanglingLayers` Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" StronglyEntanglingLayers(theta, wires=range(self.num_qubits)) __init__(num_qubits, num_layers, random_generator) Initialize the object Parameters: Name Type Description Default num_qubits int The number of qubits to use in the quantum circuit. required num_layers int The number of layers to use. required random_generator Generator A random number generator to use for trainable parameter initialization. required Source code in src/ansatzes.py def __init__(self, num_qubits: int, num_layers: int, random_generator): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. num_layers (int): The number of layers to use. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self.num_qubits = num_qubits self.num_layers = num_layers self.param_shape = (2, num_layers, num_qubits, 3) self.weights = 2 * np.pi * \\ random_generator.random(size=self.param_shape) ansatz(weights, x=None) The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: Name Type Description Default weights array An object containing the list of trainable parameters. required x array An object containing the list of datapoints to encode. None Returns: Type Description ExpectationMP The expected value of the quantum circuit Source code in src/ansatzes.py def ansatz(self, weights, x=None): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self.W(weights[0]) self.S(x) self.W(weights[1]) return qml.expval(qml.PauliZ(wires=0))","title":"ansatzes"},{"location":"module_ansatzes/#module-ansatzes","text":"This module defines the actual ansatzes supported in the code. All ansatzes are specializations of the ansatz.Ansatz abstract base class.","title":"Module ansatzes"},{"location":"module_ansatzes/#ansatzes.AnsatzConv","text":"Bases: Ansatz This anstaz uses Pauli X rotations as encoding and convolutional layers from the conv_layer module as trainable blocks Source code in src/ansatzes.py class AnsatzConv(ansatz.Ansatz): \"\"\" This anstaz uses Pauli X rotations as encoding and convolutional layers from the `conv_layer` module as trainable blocks \"\"\" def __init__(self, num_qubits: int, conv_layer, random_generator): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. conv_layer (any): The convolutional layer to use in the circuit. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self.num_qubits = num_qubits self.conv_layer = conv_layer self.param_shape = (2, num_qubits, conv_layer.ppb) self.weights = 2 * np.pi * \\ random_generator.random(size=self.param_shape) def S(self, x): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x: An array-like object containing the datapoints to encode. \"\"\" for w in range(self.num_qubits): qml.RX(x, wires=w) def conv_block(self, p): \"\"\" Constructs the trainable part of the circuit. Each convolutional layer is applied to a pair of quibits. As a \"boundary condition\", the last quibit pairs with the first. \"\"\" qml.Barrier(wires=range(self.num_qubits)) for i in range(self.num_qubits): self.conv_layer.layer(p[i], [i, (i + 1) % self.num_qubits]) qml.Barrier(wires=range(self.num_qubits)) def W(self, theta): \"\"\" The trainable block for the ansatz circuit, using convolutional layers Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" self.conv_block(theta) def ansatz(self, weights, x=None): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self.W(weights[0]) self.S(x) self.W(weights[1]) return qml.expval(qml.PauliZ(wires=0))","title":"AnsatzConv"},{"location":"module_ansatzes/#ansatzes.AnsatzConv.S","text":"The enconder block for the ansatz circuit, using Pauli X rotations x: An array-like object containing the datapoints to encode. Source code in src/ansatzes.py def S(self, x): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x: An array-like object containing the datapoints to encode. \"\"\" for w in range(self.num_qubits): qml.RX(x, wires=w)","title":"S"},{"location":"module_ansatzes/#ansatzes.AnsatzConv.W","text":"The trainable block for the ansatz circuit, using convolutional layers Parameters: Name Type Description Default theta array An array-like object containing the list of trainable parameters. required Source code in src/ansatzes.py def W(self, theta): \"\"\" The trainable block for the ansatz circuit, using convolutional layers Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" self.conv_block(theta)","title":"W"},{"location":"module_ansatzes/#ansatzes.AnsatzConv.__init__","text":"Initialize the object Parameters: Name Type Description Default num_qubits int The number of qubits to use in the quantum circuit. required conv_layer any The convolutional layer to use in the circuit. required random_generator Generator A random number generator to use for trainable parameter initialization. required Source code in src/ansatzes.py def __init__(self, num_qubits: int, conv_layer, random_generator): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. conv_layer (any): The convolutional layer to use in the circuit. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self.num_qubits = num_qubits self.conv_layer = conv_layer self.param_shape = (2, num_qubits, conv_layer.ppb) self.weights = 2 * np.pi * \\ random_generator.random(size=self.param_shape)","title":"__init__"},{"location":"module_ansatzes/#ansatzes.AnsatzConv.ansatz","text":"The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: Name Type Description Default weights array An object containing the list of trainable parameters. required x array An object containing the list of datapoints to encode. None Returns: Type Description ExpectationMP The expected value of the quantum circuit Source code in src/ansatzes.py def ansatz(self, weights, x=None): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self.W(weights[0]) self.S(x) self.W(weights[1]) return qml.expval(qml.PauliZ(wires=0))","title":"ansatz"},{"location":"module_ansatzes/#ansatzes.AnsatzConv.conv_block","text":"Constructs the trainable part of the circuit. Each convolutional layer is applied to a pair of quibits. As a \"boundary condition\", the last quibit pairs with the first. Source code in src/ansatzes.py def conv_block(self, p): \"\"\" Constructs the trainable part of the circuit. Each convolutional layer is applied to a pair of quibits. As a \"boundary condition\", the last quibit pairs with the first. \"\"\" qml.Barrier(wires=range(self.num_qubits)) for i in range(self.num_qubits): self.conv_layer.layer(p[i], [i, (i + 1) % self.num_qubits]) qml.Barrier(wires=range(self.num_qubits))","title":"conv_block"},{"location":"module_ansatzes/#ansatzes.AnsatzSEL","text":"Bases: Ansatz This anstaz uses Pauli X rotations as encoding and strongly entangling layers as trainable blocks Source code in src/ansatzes.py class AnsatzSEL(ansatz.Ansatz): \"\"\" This anstaz uses Pauli X rotations as encoding and [strongly entangling layers](https://docs.pennylane.ai/en/stable/code/api/pennylane.StronglyEntanglingLayers.html) as trainable blocks \"\"\" def __init__(self, num_qubits: int, num_layers: int, random_generator): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. num_layers (int): The number of layers to use. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self.num_qubits = num_qubits self.num_layers = num_layers self.param_shape = (2, num_layers, num_qubits, 3) self.weights = 2 * np.pi * \\ random_generator.random(size=self.param_shape) def S(self, x): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" for w in range(self.num_qubits): qml.RX(x, wires=w) def W(self, theta): \"\"\" The trainable block for the ansatz circuit, using `StronglyEntanglingLayers` Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" StronglyEntanglingLayers(theta, wires=range(self.num_qubits)) def ansatz(self, weights, x=None): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self.W(weights[0]) self.S(x) self.W(weights[1]) return qml.expval(qml.PauliZ(wires=0))","title":"AnsatzSEL"},{"location":"module_ansatzes/#ansatzes.AnsatzSEL.S","text":"The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x (array): An array-like object containing the datapoints to encode. Source code in src/ansatzes.py def S(self, x): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" for w in range(self.num_qubits): qml.RX(x, wires=w)","title":"S"},{"location":"module_ansatzes/#ansatzes.AnsatzSEL.W","text":"The trainable block for the ansatz circuit, using StronglyEntanglingLayers Parameters: Name Type Description Default theta array An array-like object containing the list of trainable parameters. required Source code in src/ansatzes.py def W(self, theta): \"\"\" The trainable block for the ansatz circuit, using `StronglyEntanglingLayers` Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" StronglyEntanglingLayers(theta, wires=range(self.num_qubits))","title":"W"},{"location":"module_ansatzes/#ansatzes.AnsatzSEL.__init__","text":"Initialize the object Parameters: Name Type Description Default num_qubits int The number of qubits to use in the quantum circuit. required num_layers int The number of layers to use. required random_generator Generator A random number generator to use for trainable parameter initialization. required Source code in src/ansatzes.py def __init__(self, num_qubits: int, num_layers: int, random_generator): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. num_layers (int): The number of layers to use. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self.num_qubits = num_qubits self.num_layers = num_layers self.param_shape = (2, num_layers, num_qubits, 3) self.weights = 2 * np.pi * \\ random_generator.random(size=self.param_shape)","title":"__init__"},{"location":"module_ansatzes/#ansatzes.AnsatzSEL.ansatz","text":"The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: Name Type Description Default weights array An object containing the list of trainable parameters. required x array An object containing the list of datapoints to encode. None Returns: Type Description ExpectationMP The expected value of the quantum circuit Source code in src/ansatzes.py def ansatz(self, weights, x=None): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self.W(weights[0]) self.S(x) self.W(weights[1]) return qml.expval(qml.PauliZ(wires=0))","title":"ansatz"},{"location":"module_config/","text":"Module config Contains definitions relating to the configuration of how and what types of training will be performed ConfigData Read and process configurations from a .yaml file. These files are used to drive the training, selecting which type of training to do and how to do it. Source code in src/config.py class ConfigData: \"\"\" Read and process configurations from a `.yaml` file. These files are used to drive the training, selecting which type of training to do and how to do it. \"\"\" def __init__(self, config_file_path: str): \"\"\" Initialize the object. Parameters: config_file_path (str): String with the path to a YAML configuration file. Attributes: config_file (dict[str, Any]): The loaded YAML configuration file as a dictionary of options. num_qubits (int): The total number of qubits to use for training. ansatz (str): The type of ansatz to use. conv_layer (str): The name of the convolutional layer to use. Ignored if `ansatz != \"conv\"`. num_layers (int): The number of entangling layers to use. Ignored if `ansatz != \"sel\"`. dataset_size (int): The number of datapoints to use during training. batch_size (int): The number of subsamples to use during batching. If set to `0`, no batching is used. optimizer (str): The training library to use for optimization. use_cuda (bool): Use CUDA for training, if available. max_iters (int): The maximum number of steps the optimizer is allowed to take. abstol (float): The error function value bellow which training stops. setp_size (float): Initial step size for the optimizing algorithm. x0 (float): Left domain boundary. xf (float): Right domain boundary. problem_type (str): The type of problem to solve. output_folder_name (str): The folder where training output will be generated. hp_params: (HagenPoiseuilleParams): The parameters for the Hagen-Poiseuille problem to be solved. Only used if `problem_type = \"plane-hagen-poiseuille\" or \"plane-hagen-poiseuille\"` \"\"\" with open(config_file_path, \"rb\") as f: self.config_file = yaml.safe_load(f) self.num_qubits = self.config_file[\"computer\"][\"num_qubits\"] self.ansatz = self.config_file[\"circuit\"][\"ansatz\"] if self.ansatz == \"conv\": self.conv_layer = self.config_file[\"circuit\"][\"conv_layer\"] else: self.conv_layer = None if self.ansatz == \"sel\": self.num_layers = self.config_file[\"circuit\"][\"num_layers\"] else: self.num_layers = None self.dataset_size = self.config_file[\"dataset\"][\"dataset_size\"] self.batch_size = self.config_file[\"dataset\"][\"batch_size\"] self.optimizer = self.config_file[\"training\"][\"optimizer\"] self.use_cuda = self.config_file[\"training\"][\"use_cuda\"] self.max_iters = self.config_file[\"training\"][\"max_iters\"] self.abstol = self.config_file[\"training\"][\"abstol\"] self.step_size = self.config_file[\"training\"][\"step_size\"] self.x0 = self.config_file[\"domain\"][\"x0\"] self.xf = self.config_file[\"domain\"][\"xf\"] self.problem_type = self.config_file[\"problem\"][\"type\"] self.output_folder_name = self.config_file[\"output\"][\"folder_name\"] if self.problem_type == \"hagen-poiseuille\" or self.problem_type == \"plane-hagen-poiseuille\": self.hp_params = hp_params.HagenPoiseuilleParams( self.config_file[\"problem\"][\"params\"][\"G\"], self.config_file[\"problem\"][\"params\"][\"R\"], self.config_file[\"problem\"][\"params\"][\"mu\"] ) __init__(config_file_path) Initialize the object. Parameters: Name Type Description Default config_file_path str String with the path to a YAML configuration file. required Attributes: Name Type Description config_file dict [ str , Any ] The loaded YAML configuration file as a dictionary of options. num_qubits int The total number of qubits to use for training. ansatz str The type of ansatz to use. conv_layer str The name of the convolutional layer to use. Ignored if ansatz != \"conv\" . num_layers int The number of entangling layers to use. Ignored if ansatz != \"sel\" . dataset_size int The number of datapoints to use during training. batch_size int The number of subsamples to use during batching. If set to 0 , no batching is used. optimizer str The training library to use for optimization. use_cuda bool Use CUDA for training, if available. max_iters int The maximum number of steps the optimizer is allowed to take. abstol float The error function value bellow which training stops. setp_size float Initial step size for the optimizing algorithm. x0 float Left domain boundary. xf float Right domain boundary. problem_type str The type of problem to solve. output_folder_name str The folder where training output will be generated. hp_params str (HagenPoiseuilleParams): The parameters for the Hagen-Poiseuille problem to be solved. Only used if problem_type = \"plane-hagen-poiseuille\" or \"plane-hagen-poiseuille\" Source code in src/config.py def __init__(self, config_file_path: str): \"\"\" Initialize the object. Parameters: config_file_path (str): String with the path to a YAML configuration file. Attributes: config_file (dict[str, Any]): The loaded YAML configuration file as a dictionary of options. num_qubits (int): The total number of qubits to use for training. ansatz (str): The type of ansatz to use. conv_layer (str): The name of the convolutional layer to use. Ignored if `ansatz != \"conv\"`. num_layers (int): The number of entangling layers to use. Ignored if `ansatz != \"sel\"`. dataset_size (int): The number of datapoints to use during training. batch_size (int): The number of subsamples to use during batching. If set to `0`, no batching is used. optimizer (str): The training library to use for optimization. use_cuda (bool): Use CUDA for training, if available. max_iters (int): The maximum number of steps the optimizer is allowed to take. abstol (float): The error function value bellow which training stops. setp_size (float): Initial step size for the optimizing algorithm. x0 (float): Left domain boundary. xf (float): Right domain boundary. problem_type (str): The type of problem to solve. output_folder_name (str): The folder where training output will be generated. hp_params: (HagenPoiseuilleParams): The parameters for the Hagen-Poiseuille problem to be solved. Only used if `problem_type = \"plane-hagen-poiseuille\" or \"plane-hagen-poiseuille\"` \"\"\" with open(config_file_path, \"rb\") as f: self.config_file = yaml.safe_load(f) self.num_qubits = self.config_file[\"computer\"][\"num_qubits\"] self.ansatz = self.config_file[\"circuit\"][\"ansatz\"] if self.ansatz == \"conv\": self.conv_layer = self.config_file[\"circuit\"][\"conv_layer\"] else: self.conv_layer = None if self.ansatz == \"sel\": self.num_layers = self.config_file[\"circuit\"][\"num_layers\"] else: self.num_layers = None self.dataset_size = self.config_file[\"dataset\"][\"dataset_size\"] self.batch_size = self.config_file[\"dataset\"][\"batch_size\"] self.optimizer = self.config_file[\"training\"][\"optimizer\"] self.use_cuda = self.config_file[\"training\"][\"use_cuda\"] self.max_iters = self.config_file[\"training\"][\"max_iters\"] self.abstol = self.config_file[\"training\"][\"abstol\"] self.step_size = self.config_file[\"training\"][\"step_size\"] self.x0 = self.config_file[\"domain\"][\"x0\"] self.xf = self.config_file[\"domain\"][\"xf\"] self.problem_type = self.config_file[\"problem\"][\"type\"] self.output_folder_name = self.config_file[\"output\"][\"folder_name\"] if self.problem_type == \"hagen-poiseuille\" or self.problem_type == \"plane-hagen-poiseuille\": self.hp_params = hp_params.HagenPoiseuilleParams( self.config_file[\"problem\"][\"params\"][\"G\"], self.config_file[\"problem\"][\"params\"][\"R\"], self.config_file[\"problem\"][\"params\"][\"mu\"] )","title":"config"},{"location":"module_config/#module-config","text":"Contains definitions relating to the configuration of how and what types of training will be performed","title":"Module config"},{"location":"module_config/#config.ConfigData","text":"Read and process configurations from a .yaml file. These files are used to drive the training, selecting which type of training to do and how to do it. Source code in src/config.py class ConfigData: \"\"\" Read and process configurations from a `.yaml` file. These files are used to drive the training, selecting which type of training to do and how to do it. \"\"\" def __init__(self, config_file_path: str): \"\"\" Initialize the object. Parameters: config_file_path (str): String with the path to a YAML configuration file. Attributes: config_file (dict[str, Any]): The loaded YAML configuration file as a dictionary of options. num_qubits (int): The total number of qubits to use for training. ansatz (str): The type of ansatz to use. conv_layer (str): The name of the convolutional layer to use. Ignored if `ansatz != \"conv\"`. num_layers (int): The number of entangling layers to use. Ignored if `ansatz != \"sel\"`. dataset_size (int): The number of datapoints to use during training. batch_size (int): The number of subsamples to use during batching. If set to `0`, no batching is used. optimizer (str): The training library to use for optimization. use_cuda (bool): Use CUDA for training, if available. max_iters (int): The maximum number of steps the optimizer is allowed to take. abstol (float): The error function value bellow which training stops. setp_size (float): Initial step size for the optimizing algorithm. x0 (float): Left domain boundary. xf (float): Right domain boundary. problem_type (str): The type of problem to solve. output_folder_name (str): The folder where training output will be generated. hp_params: (HagenPoiseuilleParams): The parameters for the Hagen-Poiseuille problem to be solved. Only used if `problem_type = \"plane-hagen-poiseuille\" or \"plane-hagen-poiseuille\"` \"\"\" with open(config_file_path, \"rb\") as f: self.config_file = yaml.safe_load(f) self.num_qubits = self.config_file[\"computer\"][\"num_qubits\"] self.ansatz = self.config_file[\"circuit\"][\"ansatz\"] if self.ansatz == \"conv\": self.conv_layer = self.config_file[\"circuit\"][\"conv_layer\"] else: self.conv_layer = None if self.ansatz == \"sel\": self.num_layers = self.config_file[\"circuit\"][\"num_layers\"] else: self.num_layers = None self.dataset_size = self.config_file[\"dataset\"][\"dataset_size\"] self.batch_size = self.config_file[\"dataset\"][\"batch_size\"] self.optimizer = self.config_file[\"training\"][\"optimizer\"] self.use_cuda = self.config_file[\"training\"][\"use_cuda\"] self.max_iters = self.config_file[\"training\"][\"max_iters\"] self.abstol = self.config_file[\"training\"][\"abstol\"] self.step_size = self.config_file[\"training\"][\"step_size\"] self.x0 = self.config_file[\"domain\"][\"x0\"] self.xf = self.config_file[\"domain\"][\"xf\"] self.problem_type = self.config_file[\"problem\"][\"type\"] self.output_folder_name = self.config_file[\"output\"][\"folder_name\"] if self.problem_type == \"hagen-poiseuille\" or self.problem_type == \"plane-hagen-poiseuille\": self.hp_params = hp_params.HagenPoiseuilleParams( self.config_file[\"problem\"][\"params\"][\"G\"], self.config_file[\"problem\"][\"params\"][\"R\"], self.config_file[\"problem\"][\"params\"][\"mu\"] )","title":"ConfigData"},{"location":"module_config/#config.ConfigData.__init__","text":"Initialize the object. Parameters: Name Type Description Default config_file_path str String with the path to a YAML configuration file. required Attributes: Name Type Description config_file dict [ str , Any ] The loaded YAML configuration file as a dictionary of options. num_qubits int The total number of qubits to use for training. ansatz str The type of ansatz to use. conv_layer str The name of the convolutional layer to use. Ignored if ansatz != \"conv\" . num_layers int The number of entangling layers to use. Ignored if ansatz != \"sel\" . dataset_size int The number of datapoints to use during training. batch_size int The number of subsamples to use during batching. If set to 0 , no batching is used. optimizer str The training library to use for optimization. use_cuda bool Use CUDA for training, if available. max_iters int The maximum number of steps the optimizer is allowed to take. abstol float The error function value bellow which training stops. setp_size float Initial step size for the optimizing algorithm. x0 float Left domain boundary. xf float Right domain boundary. problem_type str The type of problem to solve. output_folder_name str The folder where training output will be generated. hp_params str (HagenPoiseuilleParams): The parameters for the Hagen-Poiseuille problem to be solved. Only used if problem_type = \"plane-hagen-poiseuille\" or \"plane-hagen-poiseuille\" Source code in src/config.py def __init__(self, config_file_path: str): \"\"\" Initialize the object. Parameters: config_file_path (str): String with the path to a YAML configuration file. Attributes: config_file (dict[str, Any]): The loaded YAML configuration file as a dictionary of options. num_qubits (int): The total number of qubits to use for training. ansatz (str): The type of ansatz to use. conv_layer (str): The name of the convolutional layer to use. Ignored if `ansatz != \"conv\"`. num_layers (int): The number of entangling layers to use. Ignored if `ansatz != \"sel\"`. dataset_size (int): The number of datapoints to use during training. batch_size (int): The number of subsamples to use during batching. If set to `0`, no batching is used. optimizer (str): The training library to use for optimization. use_cuda (bool): Use CUDA for training, if available. max_iters (int): The maximum number of steps the optimizer is allowed to take. abstol (float): The error function value bellow which training stops. setp_size (float): Initial step size for the optimizing algorithm. x0 (float): Left domain boundary. xf (float): Right domain boundary. problem_type (str): The type of problem to solve. output_folder_name (str): The folder where training output will be generated. hp_params: (HagenPoiseuilleParams): The parameters for the Hagen-Poiseuille problem to be solved. Only used if `problem_type = \"plane-hagen-poiseuille\" or \"plane-hagen-poiseuille\"` \"\"\" with open(config_file_path, \"rb\") as f: self.config_file = yaml.safe_load(f) self.num_qubits = self.config_file[\"computer\"][\"num_qubits\"] self.ansatz = self.config_file[\"circuit\"][\"ansatz\"] if self.ansatz == \"conv\": self.conv_layer = self.config_file[\"circuit\"][\"conv_layer\"] else: self.conv_layer = None if self.ansatz == \"sel\": self.num_layers = self.config_file[\"circuit\"][\"num_layers\"] else: self.num_layers = None self.dataset_size = self.config_file[\"dataset\"][\"dataset_size\"] self.batch_size = self.config_file[\"dataset\"][\"batch_size\"] self.optimizer = self.config_file[\"training\"][\"optimizer\"] self.use_cuda = self.config_file[\"training\"][\"use_cuda\"] self.max_iters = self.config_file[\"training\"][\"max_iters\"] self.abstol = self.config_file[\"training\"][\"abstol\"] self.step_size = self.config_file[\"training\"][\"step_size\"] self.x0 = self.config_file[\"domain\"][\"x0\"] self.xf = self.config_file[\"domain\"][\"xf\"] self.problem_type = self.config_file[\"problem\"][\"type\"] self.output_folder_name = self.config_file[\"output\"][\"folder_name\"] if self.problem_type == \"hagen-poiseuille\" or self.problem_type == \"plane-hagen-poiseuille\": self.hp_params = hp_params.HagenPoiseuilleParams( self.config_file[\"problem\"][\"params\"][\"G\"], self.config_file[\"problem\"][\"params\"][\"R\"], self.config_file[\"problem\"][\"params\"][\"mu\"] )","title":"__init__"},{"location":"module_conv_layer/","text":"Module conv_layer Contains all convolutional layer circuits that can be used for training. FreeVatanWilliams dataclass Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf. Modified so taht all roations are free trainable parameters. Attributes: Name Type Description name str The name of the convolutional layer (\"Free Vatan - Williams\"). ppb int The number of trainable parameters per convolutional block (5). Source code in src/conv_layers.py @dataclass class FreeVatanWilliams: \"\"\" Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf. Modified so taht all roations are free trainable parameters. Attributes: name (str): The name of the convolutional layer (\"Free Vatan - Williams\"). ppb (int): The number of trainable parameters per convolutional block (5). \"\"\" name: str = \"Free Vatan - Williams\" ppb: int = 5 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RZ(p[0], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(p[1], wires=w[0]) qml.RY(p[2], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[3], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(p[4], wires=w[0]) layer(p, w) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RZ(p[0], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(p[1], wires=w[0]) qml.RY(p[2], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[3], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(p[4], wires=w[0]) HurKimPark1 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (1)\"). ppb int The number of trainable parameters per convolutional block (2). Source code in src/conv_layers.py @dataclass class HurKimPark1: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (1)\"). ppb (int): The number of trainable parameters per convolutional block (2). \"\"\" name: str = \"Hur - Kim - Park (1)\" ppb: int = 2 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) layer(p, w) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) HurKimPark2 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (2)\"). ppb int The number of trainable parameters per convolutional block (2). Source code in src/conv_layers.py @dataclass class HurKimPark2: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (2)\"). ppb (int): The number of trainable parameters per convolutional block (2). \"\"\" name: str = \"Hur - Kim - Park (2)\" ppb: int = 2 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.Hadamard(wires=w[0]) qml.Hadamard(wires=w[1]) qml.CZ(wires=[w[0], w[1]]) qml.RX(p[0], wires=w[0]) qml.RX(p[1], wires=w[1]) layer(p, w) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.Hadamard(wires=w[0]) qml.Hadamard(wires=w[1]) qml.CZ(wires=[w[0], w[1]]) qml.RX(p[0], wires=w[0]) qml.RX(p[1], wires=w[1]) HurKimPark3 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (3)\"). ppb int The number of trainable parameters per convolutional block (4). Source code in src/conv_layers.py @dataclass class HurKimPark3: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (3)\"). ppb (int): The number of trainable parameters per convolutional block (4). \"\"\" name: str = \"Hur - Kim - Park (3)\" ppb: int = 4 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RY(p[2], wires=w[0]) qml.RY(p[3], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) layer(p, w) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RY(p[2], wires=w[0]) qml.RY(p[3], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) HurKimPark4 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (4)\"). ppb int The number of trainable parameters per convolutional block (6). Source code in src/conv_layers.py @dataclass class HurKimPark4: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (4)\"). ppb (int): The number of trainable parameters per convolutional block (6). \"\"\" name: str = \"Hur - Kim - Park (4)\" ppb: int = 6 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CRZ(p[2], wires=[w[1], w[0]]) qml.RY(p[3], wires=w[0]) qml.RY(p[4], wires=w[1]) qml.CRZ(p[5], wires=[w[0], w[1]]) layer(p, w) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CRZ(p[2], wires=[w[1], w[0]]) qml.RY(p[3], wires=w[0]) qml.RY(p[4], wires=w[1]) qml.CRZ(p[5], wires=[w[0], w[1]]) HurKimPark5 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (5)\"). ppb int The number of trainable parameters per convolutional block (6). Source code in src/conv_layers.py @dataclass class HurKimPark5: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (5)\"). ppb (int): The number of trainable parameters per convolutional block (6). \"\"\" name: str = \"Hur - Kim - Park (5)\" ppb: int = 6 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CRX(p[2], wires=[w[1], w[0]]) qml.RY(p[3], wires=w[0]) qml.RY(p[4], wires=w[1]) qml.CRX(p[5], wires=[w[0], w[1]]) layer(p, w) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CRX(p[2], wires=[w[1], w[0]]) qml.RY(p[3], wires=w[0]) qml.RY(p[4], wires=w[1]) qml.CRX(p[5], wires=[w[0], w[1]]) HurKimPark6 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (6)\"). ppb int The number of trainable parameters per convolutional block (6). Source code in src/conv_layers.py @dataclass class HurKimPark6: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (6)\"). ppb (int): The number of trainable parameters per convolutional block (6). \"\"\" name: str = \"Hur - Kim - Park (6)\" ppb: int = 6 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[2], wires=w[0]) qml.RY(p[3], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[4], wires=w[0]) qml.RY(p[5], wires=w[1]) layer(p, w) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[2], wires=w[0]) qml.RY(p[3], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[4], wires=w[0]) qml.RY(p[5], wires=w[1]) HurKimPark7 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (7)\"). ppb int The number of trainable parameters per convolutional block (10). Source code in src/conv_layers.py @dataclass class HurKimPark7: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (7)\"). ppb (int): The number of trainable parameters per convolutional block (10). \"\"\" name: str = \"Hur - Kim - Park (7)\" ppb: int = 10 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RX(p[0], wires=w[0]) qml.RX(p[1], wires=w[1]) qml.RZ(p[2], wires=w[0]) qml.RZ(p[3], wires=w[1]) qml.CRZ(p[4], wires=[w[1], w[0]]) qml.CRZ(p[5], wires=[w[0], w[1]]) qml.RX(p[6], wires=w[0]) qml.RX(p[7], wires=w[1]) qml.RZ(p[8], wires=w[0]) qml.RZ(p[9], wires=w[1]) layer(p, w) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RX(p[0], wires=w[0]) qml.RX(p[1], wires=w[1]) qml.RZ(p[2], wires=w[0]) qml.RZ(p[3], wires=w[1]) qml.CRZ(p[4], wires=[w[1], w[0]]) qml.CRZ(p[5], wires=[w[0], w[1]]) qml.RX(p[6], wires=w[0]) qml.RX(p[7], wires=w[1]) qml.RZ(p[8], wires=w[0]) qml.RZ(p[9], wires=w[1]) HurKimPark8 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (8)\"). ppb int The number of trainable parameters per convolutional block (10). Source code in src/conv_layers.py @dataclass class HurKimPark8: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (8)\"). ppb (int): The number of trainable parameters per convolutional block (10). \"\"\" name: str = \"Hur - Kim - Park (8)\" ppb: int = 10 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RX(p[0], wires=w[0]) qml.RX(p[1], wires=w[1]) qml.RZ(p[2], wires=w[0]) qml.RZ(p[3], wires=w[1]) qml.CRX(p[4], wires=[w[1], w[0]]) qml.CRX(p[5], wires=[w[0], w[1]]) qml.RX(p[6], wires=w[0]) qml.RX(p[7], wires=w[1]) qml.RZ(p[8], wires=w[0]) qml.RZ(p[9], wires=w[1]) layer(p, w) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RX(p[0], wires=w[0]) qml.RX(p[1], wires=w[1]) qml.RZ(p[2], wires=w[0]) qml.RZ(p[3], wires=w[1]) qml.CRX(p[4], wires=[w[1], w[0]]) qml.CRX(p[5], wires=[w[0], w[1]]) qml.RX(p[6], wires=w[0]) qml.RX(p[7], wires=w[1]) qml.RZ(p[8], wires=w[0]) qml.RZ(p[9], wires=w[1]) HurKimPark9 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (9)\"). ppb int The number of trainable parameters per convolutional block (15). Source code in src/conv_layers.py @dataclass class HurKimPark9: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (9)\"). ppb (int): The number of trainable parameters per convolutional block (15). \"\"\" name: str = \"Hur - Kim - Park (9)\" ppb: int = 15 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" # U30 qml.RZ(p[0], wires=w[0]) qml.RX(-np.pi/2, wires=w[0]) qml.RZ(p[1], wires=w[0]) qml.RX(np.pi/2, wires=w[0]) qml.RZ(p[2], wires=w[0]) # U31 qml.RZ(p[3], wires=w[1]) qml.RX(-np.pi/2, wires=w[1]) qml.RZ(p[4], wires=w[1]) qml.RX(np.pi/2, wires=w[1]) qml.RZ(p[5], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[6], wires=w[0]) qml.RZ(p[7], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RY(p[8], wires=w[0]) qml.CNOT(wires=[w[0], w[1]]) # U30 qml.RZ(p[9], wires=w[0]) qml.RX(-np.pi/2, wires=w[0]) qml.RZ(p[10], wires=w[0]) qml.RX(np.pi/2, wires=w[0]) qml.RZ(p[11], wires=w[0]) # U31 qml.RZ(p[12], wires=w[1]) qml.RX(-np.pi/2, wires=w[1]) qml.RZ(p[13], wires=w[1]) qml.RX(np.pi/2, wires=w[1]) qml.RZ(p[14], wires=w[1]) layer(p, w) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" # U30 qml.RZ(p[0], wires=w[0]) qml.RX(-np.pi/2, wires=w[0]) qml.RZ(p[1], wires=w[0]) qml.RX(np.pi/2, wires=w[0]) qml.RZ(p[2], wires=w[0]) # U31 qml.RZ(p[3], wires=w[1]) qml.RX(-np.pi/2, wires=w[1]) qml.RZ(p[4], wires=w[1]) qml.RX(np.pi/2, wires=w[1]) qml.RZ(p[5], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[6], wires=w[0]) qml.RZ(p[7], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RY(p[8], wires=w[0]) qml.CNOT(wires=[w[0], w[1]]) # U30 qml.RZ(p[9], wires=w[0]) qml.RX(-np.pi/2, wires=w[0]) qml.RZ(p[10], wires=w[0]) qml.RX(np.pi/2, wires=w[0]) qml.RZ(p[11], wires=w[0]) # U31 qml.RZ(p[12], wires=w[1]) qml.RX(-np.pi/2, wires=w[1]) qml.RZ(p[13], wires=w[1]) qml.RX(np.pi/2, wires=w[1]) qml.RZ(p[14], wires=w[1]) VatanWilliams dataclass Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf Attributes: Name Type Description name str The name of the convolutional layer (\"Vatan - Williams\"). ppb int The number of trainable parameters per convolutional block (3). Source code in src/conv_layers.py @dataclass class VatanWilliams: \"\"\" Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf Attributes: name (str): The name of the convolutional layer (\"Vatan - Williams\"). ppb (int): The number of trainable parameters per convolutional block (3). \"\"\" name: str = \"Vatan - Williams\" ppb: int = 3 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RZ(np.pi / 2, wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[2], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(-np.pi / 2, wires=w[0]) layer(p, w) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RZ(np.pi / 2, wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[2], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(-np.pi / 2, wires=w[0])","title":"conv_layer"},{"location":"module_conv_layer/#module-conv_layer","text":"Contains all convolutional layer circuits that can be used for training.","title":"Module conv_layer"},{"location":"module_conv_layer/#conv_layers.FreeVatanWilliams","text":"Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf. Modified so taht all roations are free trainable parameters. Attributes: Name Type Description name str The name of the convolutional layer (\"Free Vatan - Williams\"). ppb int The number of trainable parameters per convolutional block (5). Source code in src/conv_layers.py @dataclass class FreeVatanWilliams: \"\"\" Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf. Modified so taht all roations are free trainable parameters. Attributes: name (str): The name of the convolutional layer (\"Free Vatan - Williams\"). ppb (int): The number of trainable parameters per convolutional block (5). \"\"\" name: str = \"Free Vatan - Williams\" ppb: int = 5 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RZ(p[0], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(p[1], wires=w[0]) qml.RY(p[2], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[3], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(p[4], wires=w[0])","title":"FreeVatanWilliams"},{"location":"module_conv_layer/#conv_layers.FreeVatanWilliams.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RZ(p[0], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(p[1], wires=w[0]) qml.RY(p[2], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[3], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(p[4], wires=w[0])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark1","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (1)\"). ppb int The number of trainable parameters per convolutional block (2). Source code in src/conv_layers.py @dataclass class HurKimPark1: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (1)\"). ppb (int): The number of trainable parameters per convolutional block (2). \"\"\" name: str = \"Hur - Kim - Park (1)\" ppb: int = 2 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[0], w[1]])","title":"HurKimPark1"},{"location":"module_conv_layer/#conv_layers.HurKimPark1.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[0], w[1]])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark2","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (2)\"). ppb int The number of trainable parameters per convolutional block (2). Source code in src/conv_layers.py @dataclass class HurKimPark2: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (2)\"). ppb (int): The number of trainable parameters per convolutional block (2). \"\"\" name: str = \"Hur - Kim - Park (2)\" ppb: int = 2 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.Hadamard(wires=w[0]) qml.Hadamard(wires=w[1]) qml.CZ(wires=[w[0], w[1]]) qml.RX(p[0], wires=w[0]) qml.RX(p[1], wires=w[1])","title":"HurKimPark2"},{"location":"module_conv_layer/#conv_layers.HurKimPark2.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.Hadamard(wires=w[0]) qml.Hadamard(wires=w[1]) qml.CZ(wires=[w[0], w[1]]) qml.RX(p[0], wires=w[0]) qml.RX(p[1], wires=w[1])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark3","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (3)\"). ppb int The number of trainable parameters per convolutional block (4). Source code in src/conv_layers.py @dataclass class HurKimPark3: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (3)\"). ppb (int): The number of trainable parameters per convolutional block (4). \"\"\" name: str = \"Hur - Kim - Park (3)\" ppb: int = 4 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RY(p[2], wires=w[0]) qml.RY(p[3], wires=w[1]) qml.CNOT(wires=[w[0], w[1]])","title":"HurKimPark3"},{"location":"module_conv_layer/#conv_layers.HurKimPark3.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RY(p[2], wires=w[0]) qml.RY(p[3], wires=w[1]) qml.CNOT(wires=[w[0], w[1]])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark4","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (4)\"). ppb int The number of trainable parameters per convolutional block (6). Source code in src/conv_layers.py @dataclass class HurKimPark4: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (4)\"). ppb (int): The number of trainable parameters per convolutional block (6). \"\"\" name: str = \"Hur - Kim - Park (4)\" ppb: int = 6 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CRZ(p[2], wires=[w[1], w[0]]) qml.RY(p[3], wires=w[0]) qml.RY(p[4], wires=w[1]) qml.CRZ(p[5], wires=[w[0], w[1]])","title":"HurKimPark4"},{"location":"module_conv_layer/#conv_layers.HurKimPark4.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CRZ(p[2], wires=[w[1], w[0]]) qml.RY(p[3], wires=w[0]) qml.RY(p[4], wires=w[1]) qml.CRZ(p[5], wires=[w[0], w[1]])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark5","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (5)\"). ppb int The number of trainable parameters per convolutional block (6). Source code in src/conv_layers.py @dataclass class HurKimPark5: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (5)\"). ppb (int): The number of trainable parameters per convolutional block (6). \"\"\" name: str = \"Hur - Kim - Park (5)\" ppb: int = 6 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CRX(p[2], wires=[w[1], w[0]]) qml.RY(p[3], wires=w[0]) qml.RY(p[4], wires=w[1]) qml.CRX(p[5], wires=[w[0], w[1]])","title":"HurKimPark5"},{"location":"module_conv_layer/#conv_layers.HurKimPark5.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CRX(p[2], wires=[w[1], w[0]]) qml.RY(p[3], wires=w[0]) qml.RY(p[4], wires=w[1]) qml.CRX(p[5], wires=[w[0], w[1]])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark6","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (6)\"). ppb int The number of trainable parameters per convolutional block (6). Source code in src/conv_layers.py @dataclass class HurKimPark6: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (6)\"). ppb (int): The number of trainable parameters per convolutional block (6). \"\"\" name: str = \"Hur - Kim - Park (6)\" ppb: int = 6 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[2], wires=w[0]) qml.RY(p[3], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[4], wires=w[0]) qml.RY(p[5], wires=w[1])","title":"HurKimPark6"},{"location":"module_conv_layer/#conv_layers.HurKimPark6.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RY(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[2], wires=w[0]) qml.RY(p[3], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[4], wires=w[0]) qml.RY(p[5], wires=w[1])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark7","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (7)\"). ppb int The number of trainable parameters per convolutional block (10). Source code in src/conv_layers.py @dataclass class HurKimPark7: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (7)\"). ppb (int): The number of trainable parameters per convolutional block (10). \"\"\" name: str = \"Hur - Kim - Park (7)\" ppb: int = 10 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RX(p[0], wires=w[0]) qml.RX(p[1], wires=w[1]) qml.RZ(p[2], wires=w[0]) qml.RZ(p[3], wires=w[1]) qml.CRZ(p[4], wires=[w[1], w[0]]) qml.CRZ(p[5], wires=[w[0], w[1]]) qml.RX(p[6], wires=w[0]) qml.RX(p[7], wires=w[1]) qml.RZ(p[8], wires=w[0]) qml.RZ(p[9], wires=w[1])","title":"HurKimPark7"},{"location":"module_conv_layer/#conv_layers.HurKimPark7.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RX(p[0], wires=w[0]) qml.RX(p[1], wires=w[1]) qml.RZ(p[2], wires=w[0]) qml.RZ(p[3], wires=w[1]) qml.CRZ(p[4], wires=[w[1], w[0]]) qml.CRZ(p[5], wires=[w[0], w[1]]) qml.RX(p[6], wires=w[0]) qml.RX(p[7], wires=w[1]) qml.RZ(p[8], wires=w[0]) qml.RZ(p[9], wires=w[1])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark8","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (8)\"). ppb int The number of trainable parameters per convolutional block (10). Source code in src/conv_layers.py @dataclass class HurKimPark8: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (8)\"). ppb (int): The number of trainable parameters per convolutional block (10). \"\"\" name: str = \"Hur - Kim - Park (8)\" ppb: int = 10 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RX(p[0], wires=w[0]) qml.RX(p[1], wires=w[1]) qml.RZ(p[2], wires=w[0]) qml.RZ(p[3], wires=w[1]) qml.CRX(p[4], wires=[w[1], w[0]]) qml.CRX(p[5], wires=[w[0], w[1]]) qml.RX(p[6], wires=w[0]) qml.RX(p[7], wires=w[1]) qml.RZ(p[8], wires=w[0]) qml.RZ(p[9], wires=w[1])","title":"HurKimPark8"},{"location":"module_conv_layer/#conv_layers.HurKimPark8.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RX(p[0], wires=w[0]) qml.RX(p[1], wires=w[1]) qml.RZ(p[2], wires=w[0]) qml.RZ(p[3], wires=w[1]) qml.CRX(p[4], wires=[w[1], w[0]]) qml.CRX(p[5], wires=[w[0], w[1]]) qml.RX(p[6], wires=w[0]) qml.RX(p[7], wires=w[1]) qml.RZ(p[8], wires=w[0]) qml.RZ(p[9], wires=w[1])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark9","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (9)\"). ppb int The number of trainable parameters per convolutional block (15). Source code in src/conv_layers.py @dataclass class HurKimPark9: \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (9)\"). ppb (int): The number of trainable parameters per convolutional block (15). \"\"\" name: str = \"Hur - Kim - Park (9)\" ppb: int = 15 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" # U30 qml.RZ(p[0], wires=w[0]) qml.RX(-np.pi/2, wires=w[0]) qml.RZ(p[1], wires=w[0]) qml.RX(np.pi/2, wires=w[0]) qml.RZ(p[2], wires=w[0]) # U31 qml.RZ(p[3], wires=w[1]) qml.RX(-np.pi/2, wires=w[1]) qml.RZ(p[4], wires=w[1]) qml.RX(np.pi/2, wires=w[1]) qml.RZ(p[5], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[6], wires=w[0]) qml.RZ(p[7], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RY(p[8], wires=w[0]) qml.CNOT(wires=[w[0], w[1]]) # U30 qml.RZ(p[9], wires=w[0]) qml.RX(-np.pi/2, wires=w[0]) qml.RZ(p[10], wires=w[0]) qml.RX(np.pi/2, wires=w[0]) qml.RZ(p[11], wires=w[0]) # U31 qml.RZ(p[12], wires=w[1]) qml.RX(-np.pi/2, wires=w[1]) qml.RZ(p[13], wires=w[1]) qml.RX(np.pi/2, wires=w[1]) qml.RZ(p[14], wires=w[1])","title":"HurKimPark9"},{"location":"module_conv_layer/#conv_layers.HurKimPark9.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" # U30 qml.RZ(p[0], wires=w[0]) qml.RX(-np.pi/2, wires=w[0]) qml.RZ(p[1], wires=w[0]) qml.RX(np.pi/2, wires=w[0]) qml.RZ(p[2], wires=w[0]) # U31 qml.RZ(p[3], wires=w[1]) qml.RX(-np.pi/2, wires=w[1]) qml.RZ(p[4], wires=w[1]) qml.RX(np.pi/2, wires=w[1]) qml.RZ(p[5], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[6], wires=w[0]) qml.RZ(p[7], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RY(p[8], wires=w[0]) qml.CNOT(wires=[w[0], w[1]]) # U30 qml.RZ(p[9], wires=w[0]) qml.RX(-np.pi/2, wires=w[0]) qml.RZ(p[10], wires=w[0]) qml.RX(np.pi/2, wires=w[0]) qml.RZ(p[11], wires=w[0]) # U31 qml.RZ(p[12], wires=w[1]) qml.RX(-np.pi/2, wires=w[1]) qml.RZ(p[13], wires=w[1]) qml.RX(np.pi/2, wires=w[1]) qml.RZ(p[14], wires=w[1])","title":"layer"},{"location":"module_conv_layer/#conv_layers.VatanWilliams","text":"Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf Attributes: Name Type Description name str The name of the convolutional layer (\"Vatan - Williams\"). ppb int The number of trainable parameters per convolutional block (3). Source code in src/conv_layers.py @dataclass class VatanWilliams: \"\"\" Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf Attributes: name (str): The name of the convolutional layer (\"Vatan - Williams\"). ppb (int): The number of trainable parameters per convolutional block (3). \"\"\" name: str = \"Vatan - Williams\" ppb: int = 3 def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RZ(np.pi / 2, wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[2], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(-np.pi / 2, wires=w[0])","title":"VatanWilliams"},{"location":"module_conv_layer/#conv_layers.VatanWilliams.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py def layer(p, w): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml.RZ(np.pi / 2, wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(p[0], wires=w[0]) qml.RY(p[1], wires=w[1]) qml.CNOT(wires=[w[0], w[1]]) qml.RY(p[2], wires=w[1]) qml.CNOT(wires=[w[1], w[0]]) qml.RZ(-np.pi / 2, wires=w[0])","title":"layer"},{"location":"module_domain_map/","text":"Module domain_map Defines domain maps: Maps from a global computational domain to a local domain ranging from [-1, 1] where the actual training takes place and inverse transformations from local back to global domain. DomainMap Defines a general domain map Attributes: Name Type Description global_start float The left boundary of the global domain. global_end float The right boundary of the global domain. Source code in src/domain_map.py class DomainMap: \"\"\" Defines a general domain map Attributes: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" def __init__(self, global_start: float, global_end: float): \"\"\" Initialize the object. Parameters: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" self.global_start = global_start self.global_end = global_end def local2global(self, local_X): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return local_X def global2local(self, global_x): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return global_x def dlocal_dglobal(self, global_x): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 0.0 def d2local_dglobal2(self, global_x): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0 __init__(global_start, global_end) Initialize the object. Parameters: Name Type Description Default global_start float The left boundary of the global domain. required global_end float The right boundary of the global domain. required Source code in src/domain_map.py def __init__(self, global_start: float, global_end: float): \"\"\" Initialize the object. Parameters: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" self.global_start = global_start self.global_end = global_end d2local_dglobal2(global_x) The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The second derivative of global2local in the passed point. Source code in src/domain_map.py def d2local_dglobal2(self, global_x): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0 dlocal_dglobal(global_x) The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The derivative of global2local in the passed point. Source code in src/domain_map.py def dlocal_dglobal(self, global_x): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 0.0 global2local(global_x) Converts a point in global domain to local domain. Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The corresponding local domain point. Source code in src/domain_map.py def global2local(self, global_x): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return global_x local2global(local_X) Converts a point in local domain to global domain. Parameters: Name Type Description Default local_X float The local domain point. required Returns: Type Description float The corresponding global domain point. Source code in src/domain_map.py def local2global(self, local_X): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return local_X LinearMap Bases: DomainMap Defines a linear domain map, that is, link global and local domains using a linear coordiante transformation. Attributes: Name Type Description global_start float The left boundary of the global domain. global_end float The right boundary of the global domain. Source code in src/domain_map.py class LinearMap(DomainMap): \"\"\" Defines a linear domain map, that is, link global and local domains using a linear coordiante transformation. Attributes: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" def local2global(self, local_X): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return (self.global_start + self.global_end + (self.global_end - self.global_start) * local_X) / 2.0 def global2local(self, global_x): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return (self.global_start + self.global_end - 2.0 * global_x) / (self.global_start - self.global_end) def dlocal_dglobal(self, global_x): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 2.0 / (self.global_end - self.global_start) def d2local_dglobal2(self, global_x): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0 d2local_dglobal2(global_x) The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The second derivative of global2local in the passed point. Source code in src/domain_map.py def d2local_dglobal2(self, global_x): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0 dlocal_dglobal(global_x) The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The derivative of global2local in the passed point. Source code in src/domain_map.py def dlocal_dglobal(self, global_x): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 2.0 / (self.global_end - self.global_start) global2local(global_x) Converts a point in global domain to local domain. Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The corresponding local domain point. Source code in src/domain_map.py def global2local(self, global_x): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return (self.global_start + self.global_end - 2.0 * global_x) / (self.global_start - self.global_end) local2global(local_X) Converts a point in local domain to global domain. Parameters: Name Type Description Default local_X float The local domain point. required Returns: Type Description float The corresponding global domain point. Source code in src/domain_map.py def local2global(self, local_X): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return (self.global_start + self.global_end + (self.global_end - self.global_start) * local_X) / 2.0","title":"domain_map"},{"location":"module_domain_map/#module-domain_map","text":"Defines domain maps: Maps from a global computational domain to a local domain ranging from [-1, 1] where the actual training takes place and inverse transformations from local back to global domain.","title":"Module domain_map"},{"location":"module_domain_map/#domain_map.DomainMap","text":"Defines a general domain map Attributes: Name Type Description global_start float The left boundary of the global domain. global_end float The right boundary of the global domain. Source code in src/domain_map.py class DomainMap: \"\"\" Defines a general domain map Attributes: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" def __init__(self, global_start: float, global_end: float): \"\"\" Initialize the object. Parameters: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" self.global_start = global_start self.global_end = global_end def local2global(self, local_X): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return local_X def global2local(self, global_x): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return global_x def dlocal_dglobal(self, global_x): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 0.0 def d2local_dglobal2(self, global_x): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0","title":"DomainMap"},{"location":"module_domain_map/#domain_map.DomainMap.__init__","text":"Initialize the object. Parameters: Name Type Description Default global_start float The left boundary of the global domain. required global_end float The right boundary of the global domain. required Source code in src/domain_map.py def __init__(self, global_start: float, global_end: float): \"\"\" Initialize the object. Parameters: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" self.global_start = global_start self.global_end = global_end","title":"__init__"},{"location":"module_domain_map/#domain_map.DomainMap.d2local_dglobal2","text":"The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The second derivative of global2local in the passed point. Source code in src/domain_map.py def d2local_dglobal2(self, global_x): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0","title":"d2local_dglobal2"},{"location":"module_domain_map/#domain_map.DomainMap.dlocal_dglobal","text":"The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The derivative of global2local in the passed point. Source code in src/domain_map.py def dlocal_dglobal(self, global_x): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 0.0","title":"dlocal_dglobal"},{"location":"module_domain_map/#domain_map.DomainMap.global2local","text":"Converts a point in global domain to local domain. Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The corresponding local domain point. Source code in src/domain_map.py def global2local(self, global_x): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return global_x","title":"global2local"},{"location":"module_domain_map/#domain_map.DomainMap.local2global","text":"Converts a point in local domain to global domain. Parameters: Name Type Description Default local_X float The local domain point. required Returns: Type Description float The corresponding global domain point. Source code in src/domain_map.py def local2global(self, local_X): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return local_X","title":"local2global"},{"location":"module_domain_map/#domain_map.LinearMap","text":"Bases: DomainMap Defines a linear domain map, that is, link global and local domains using a linear coordiante transformation. Attributes: Name Type Description global_start float The left boundary of the global domain. global_end float The right boundary of the global domain. Source code in src/domain_map.py class LinearMap(DomainMap): \"\"\" Defines a linear domain map, that is, link global and local domains using a linear coordiante transformation. Attributes: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" def local2global(self, local_X): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return (self.global_start + self.global_end + (self.global_end - self.global_start) * local_X) / 2.0 def global2local(self, global_x): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return (self.global_start + self.global_end - 2.0 * global_x) / (self.global_start - self.global_end) def dlocal_dglobal(self, global_x): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 2.0 / (self.global_end - self.global_start) def d2local_dglobal2(self, global_x): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0","title":"LinearMap"},{"location":"module_domain_map/#domain_map.LinearMap.d2local_dglobal2","text":"The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The second derivative of global2local in the passed point. Source code in src/domain_map.py def d2local_dglobal2(self, global_x): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0","title":"d2local_dglobal2"},{"location":"module_domain_map/#domain_map.LinearMap.dlocal_dglobal","text":"The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The derivative of global2local in the passed point. Source code in src/domain_map.py def dlocal_dglobal(self, global_x): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 2.0 / (self.global_end - self.global_start)","title":"dlocal_dglobal"},{"location":"module_domain_map/#domain_map.LinearMap.global2local","text":"Converts a point in global domain to local domain. Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The corresponding local domain point. Source code in src/domain_map.py def global2local(self, global_x): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return (self.global_start + self.global_end - 2.0 * global_x) / (self.global_start - self.global_end)","title":"global2local"},{"location":"module_domain_map/#domain_map.LinearMap.local2global","text":"Converts a point in local domain to global domain. Parameters: Name Type Description Default local_X float The local domain point. required Returns: Type Description float The corresponding global domain point. Source code in src/domain_map.py def local2global(self, local_X): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return (self.global_start + self.global_end + (self.global_end - self.global_start) * local_X) / 2.0","title":"local2global"},{"location":"module_draw_and_plot/","text":"Module draw_and_plot Draws quantum circuits and plot trained functions. draw_circuit(output_name, circuit, num_qubits, *args) Draws a quantum circuit. Parameters: Name Type Description Default output_name str The folder where the plot will be created. required circuit quantum circuit function The quantum circuit to draw. required num_qubits int The number of qubits in the circuit. required args any Extra arguments for matplotlib. () Source code in src/draw_and_plot.py def draw_circuit(output_name: str, circuit, num_qubits, *args): \"\"\" Draws a quantum circuit. Parameters: output_name (str): The folder where the plot will be created. circuit (quantum circuit function): The quantum circuit to draw. num_qubits (int): The number of qubits in the circuit. args (any): Extra arguments for matplotlib. \"\"\" fig_name = \"model.pdf\" fig_path = os.path.join(output_name, fig_name) if not os.path.exists(fig_path): logger.info(f\"Drawing circuit image {fig_name}\") plt.close(\"all\") device = qml.device(\"default.qubit\", wires=num_qubits, shots=None) node = qml.QNode(circuit, device) fig, _ = qml.draw_mpl(node)(*args) fig.savefig(fig_path) plot_cost(output_name, iterations, cost_data) Plots a cost function Parameters: Name Type Description Default output_name str The folder where the plot will be created. required iterations array List of iteration indices in the cost data. required cost_data array Cost values at each iteration index. required Source code in src/draw_and_plot.py def plot_cost(output_name: str, iterations, cost_data): \"\"\" Plots a cost function Parameters: output_name (str): The folder where the plot will be created. iterations (array): List of iteration indices in the cost data. cost_data (array): Cost values at each iteration index. \"\"\" fig_name = \"cost.pdf\" fig_path = os.path.join(output_name, fig_name) logger.info(f\"Plotting cost data\") plt.close(\"all\") plt.plot( iterations, cost_data, color=line_color, linewidth=line_thickness ) plt.xlabel(\"Iterations\", fontsize=font_size) plt.ylabel(\"Cost\", fontsize=font_size) plt.tight_layout() plt.savefig(fig_path) plot_trained_error(config, ansatz, problem, weights, data, target) Plots the function currently represented in a quantum circuit together with a target function that the circuit should have achieved. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required weights array The trained weights of the quantum circuit. required data array The input data. required target array The target data, i.e., the data the circuit should have obtained if training was perfect. required Source code in src/draw_and_plot.py def plot_trained_error(config: cfg.ConfigData, ansatz: ans.Ansatz, problem: prob.Problem, weights, data, target): \"\"\" Plots the function currently represented in a quantum circuit together with a target function that the circuit should have achieved. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). weights (array): The trained weights of the quantum circuit. data (array): The input data. target (array): The target data, i.e., the data the circuit should have obtained if training was perfect. \"\"\" fig_name = \"trained_error.pdf\" fig_path = os.path.join(config.output_folder_name, fig_name) logger.info(f\"Plotting trained function\") device = qml.device(\"default.qubit\", wires=config.num_qubits, shots=None) node = qml.QNode(ansatz.ansatz, device) f = [ node(weights, x=problem.get_domain_map().global2local(x_)) for x_ in data ] plt.close(\"all\") plt.plot(data, f, color=line_color, linewidth=line_thickness, label=\"Trained\") plt.plot(data, target, color=target_color, linewidth=line_thickness, label=\"Target\") plt.xlabel(\"x\", fontsize=font_size) plt.ylabel(\"f(x)\", fontsize=font_size) plt.legend(loc=\"upper left\") plt.tight_layout() plt.savefig(fig_path) plot_trained_error_abs(config, ansatz, problem, weights, data, target) Plots the function currently represented in a quantum circuit and computes the absolute difference to a target function that the circuit should have achieved. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required weights array The trained weights of the quantum circuit. required data array The input data. required target array The target data, i.e., the data the circuit should have obtained if training was perfect. required Source code in src/draw_and_plot.py def plot_trained_error_abs(config: cfg.ConfigData, ansatz: ans.Ansatz, problem: prob.Problem, weights, data, target): \"\"\" Plots the function currently represented in a quantum circuit and computes the absolute difference to a target function that the circuit should have achieved. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). weights (array): The trained weights of the quantum circuit. data (array): The input data. target (array): The target data, i.e., the data the circuit should have obtained if training was perfect. \"\"\" fig_name = \"trained_error_abs.pdf\" fig_path = os.path.join(config.output_folder_name, fig_name) logger.info(f\"Plotting trained function\") device = qml.device(\"default.qubit\", wires=config.num_qubits, shots=None) node = qml.QNode(ansatz.ansatz, device) f = [ node(weights, x=problem.get_domain_map().global2local(x_)) for x_ in data ] plt.close(\"all\") plt.plot(data, np.abs(target - f), color=line_color, linewidth=line_thickness) plt.xlabel(\"x\", fontsize=font_size) plt.ylabel(\"Error\", fontsize=font_size) plt.tight_layout() plt.savefig(fig_path) plot_trained_function(config, ansatz, problem, weights, data) Plots the function currently represented in a quantum circuit. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required weights array The trained weights of the quantum circuit. required data array The input domain data. required Source code in src/draw_and_plot.py def plot_trained_function(config: cfg.ConfigData, ansatz: ans.Ansatz, problem: prob.Problem, weights, data): \"\"\" Plots the function currently represented in a quantum circuit. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). weights (array): The trained weights of the quantum circuit. data (array): The input domain data. \"\"\" fig_name = \"trained.pdf\" fig_path = os.path.join(config.output_folder_name, fig_name) logger.info(f\"Plotting trained function\") device = qml.device(\"default.qubit\", wires=config.num_qubits, shots=None) node = qml.QNode(ansatz.ansatz, device) f = [ node(weights, x=problem.get_domain_map().global2local(x_)) for x_ in data ] plt.close(\"all\") plt.plot(data, f, color=line_color, linewidth=line_thickness) plt.xlabel(\"x\", fontsize=font_size) plt.ylabel(\"f(x)\", fontsize=font_size) plt.tight_layout() plt.savefig(fig_path) recover_and_plot(config, ansatz, problem, data, target) Recovers training data from an ADIOS2 file and creates the relevant plots from it. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required data array The input data. required target array The target data, i.e., the data the circuit should have obtained if training was perfect. required Source code in src/draw_and_plot.py def recover_and_plot(config: cfg.ConfigData, ansatz: ans.Ansatz, problem: prob.Problem, data, target): \"\"\" Recovers training data from an ADIOS2 file and creates the relevant plots from it. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). data (array): The input data. target (array): The target data, i.e., the data the circuit should have obtained if training was perfect. \"\"\" # Find all .bp files file_list = list( filter( lambda x: os.path.splitext(x)[1] == \".bp\", os.listdir(config.output_folder_name) ) ) if len(file_list) == 0: logger.error( f\"Unable to find bp files to recover from in { config.output_folder_name}\" ) exit(1) # Recover cost iterations = [] cost_data = [] for file in file_list: file_path = os.path.join(config.output_folder_name, file) logger.info(f\"Recovering cost data from checkpoint file {file_path}\") with adios2.FileReader(file_path) as s: attrs = s.available_attributes() vars = s.available_variables() steps = int(vars[\"weights\"][\"AvailableStepsCount\"]) first_iter = int(attrs[\"first_iter\"][\"Value\"]) # cost in all steps costs = s.read(\"cost\", step_selection=[0, steps]) for i in range(len(costs)): iterations.append(first_iter + i) cost_data.append(costs[i]) # Recover the weights of the last iteration of the last checkpoint file weights = None with adios2.FileReader(file_path) as s: vars = s.available_variables() steps = int(vars[\"weights\"][\"AvailableStepsCount\"]) logger.info( f\"Recovering weight data from checkpoint file {file_path}\" ) weights = np.array( s.read(\"weights\", step_selection=[steps - 1, 1]), requires_grad=True ) plot_cost(config.output_folder_name, iterations, cost_data) plot_trained_function(config, ansatz, problem, weights, data) if target is not None: plot_trained_error(config, ansatz, problem, weights, data, target) plot_trained_error_abs(config, ansatz, problem, weights, data, target)","title":"draw_and_plot"},{"location":"module_draw_and_plot/#module-draw_and_plot","text":"Draws quantum circuits and plot trained functions.","title":"Module draw_and_plot"},{"location":"module_draw_and_plot/#draw_and_plot.draw_circuit","text":"Draws a quantum circuit. Parameters: Name Type Description Default output_name str The folder where the plot will be created. required circuit quantum circuit function The quantum circuit to draw. required num_qubits int The number of qubits in the circuit. required args any Extra arguments for matplotlib. () Source code in src/draw_and_plot.py def draw_circuit(output_name: str, circuit, num_qubits, *args): \"\"\" Draws a quantum circuit. Parameters: output_name (str): The folder where the plot will be created. circuit (quantum circuit function): The quantum circuit to draw. num_qubits (int): The number of qubits in the circuit. args (any): Extra arguments for matplotlib. \"\"\" fig_name = \"model.pdf\" fig_path = os.path.join(output_name, fig_name) if not os.path.exists(fig_path): logger.info(f\"Drawing circuit image {fig_name}\") plt.close(\"all\") device = qml.device(\"default.qubit\", wires=num_qubits, shots=None) node = qml.QNode(circuit, device) fig, _ = qml.draw_mpl(node)(*args) fig.savefig(fig_path)","title":"draw_circuit"},{"location":"module_draw_and_plot/#draw_and_plot.plot_cost","text":"Plots a cost function Parameters: Name Type Description Default output_name str The folder where the plot will be created. required iterations array List of iteration indices in the cost data. required cost_data array Cost values at each iteration index. required Source code in src/draw_and_plot.py def plot_cost(output_name: str, iterations, cost_data): \"\"\" Plots a cost function Parameters: output_name (str): The folder where the plot will be created. iterations (array): List of iteration indices in the cost data. cost_data (array): Cost values at each iteration index. \"\"\" fig_name = \"cost.pdf\" fig_path = os.path.join(output_name, fig_name) logger.info(f\"Plotting cost data\") plt.close(\"all\") plt.plot( iterations, cost_data, color=line_color, linewidth=line_thickness ) plt.xlabel(\"Iterations\", fontsize=font_size) plt.ylabel(\"Cost\", fontsize=font_size) plt.tight_layout() plt.savefig(fig_path)","title":"plot_cost"},{"location":"module_draw_and_plot/#draw_and_plot.plot_trained_error","text":"Plots the function currently represented in a quantum circuit together with a target function that the circuit should have achieved. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required weights array The trained weights of the quantum circuit. required data array The input data. required target array The target data, i.e., the data the circuit should have obtained if training was perfect. required Source code in src/draw_and_plot.py def plot_trained_error(config: cfg.ConfigData, ansatz: ans.Ansatz, problem: prob.Problem, weights, data, target): \"\"\" Plots the function currently represented in a quantum circuit together with a target function that the circuit should have achieved. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). weights (array): The trained weights of the quantum circuit. data (array): The input data. target (array): The target data, i.e., the data the circuit should have obtained if training was perfect. \"\"\" fig_name = \"trained_error.pdf\" fig_path = os.path.join(config.output_folder_name, fig_name) logger.info(f\"Plotting trained function\") device = qml.device(\"default.qubit\", wires=config.num_qubits, shots=None) node = qml.QNode(ansatz.ansatz, device) f = [ node(weights, x=problem.get_domain_map().global2local(x_)) for x_ in data ] plt.close(\"all\") plt.plot(data, f, color=line_color, linewidth=line_thickness, label=\"Trained\") plt.plot(data, target, color=target_color, linewidth=line_thickness, label=\"Target\") plt.xlabel(\"x\", fontsize=font_size) plt.ylabel(\"f(x)\", fontsize=font_size) plt.legend(loc=\"upper left\") plt.tight_layout() plt.savefig(fig_path)","title":"plot_trained_error"},{"location":"module_draw_and_plot/#draw_and_plot.plot_trained_error_abs","text":"Plots the function currently represented in a quantum circuit and computes the absolute difference to a target function that the circuit should have achieved. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required weights array The trained weights of the quantum circuit. required data array The input data. required target array The target data, i.e., the data the circuit should have obtained if training was perfect. required Source code in src/draw_and_plot.py def plot_trained_error_abs(config: cfg.ConfigData, ansatz: ans.Ansatz, problem: prob.Problem, weights, data, target): \"\"\" Plots the function currently represented in a quantum circuit and computes the absolute difference to a target function that the circuit should have achieved. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). weights (array): The trained weights of the quantum circuit. data (array): The input data. target (array): The target data, i.e., the data the circuit should have obtained if training was perfect. \"\"\" fig_name = \"trained_error_abs.pdf\" fig_path = os.path.join(config.output_folder_name, fig_name) logger.info(f\"Plotting trained function\") device = qml.device(\"default.qubit\", wires=config.num_qubits, shots=None) node = qml.QNode(ansatz.ansatz, device) f = [ node(weights, x=problem.get_domain_map().global2local(x_)) for x_ in data ] plt.close(\"all\") plt.plot(data, np.abs(target - f), color=line_color, linewidth=line_thickness) plt.xlabel(\"x\", fontsize=font_size) plt.ylabel(\"Error\", fontsize=font_size) plt.tight_layout() plt.savefig(fig_path)","title":"plot_trained_error_abs"},{"location":"module_draw_and_plot/#draw_and_plot.plot_trained_function","text":"Plots the function currently represented in a quantum circuit. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required weights array The trained weights of the quantum circuit. required data array The input domain data. required Source code in src/draw_and_plot.py def plot_trained_function(config: cfg.ConfigData, ansatz: ans.Ansatz, problem: prob.Problem, weights, data): \"\"\" Plots the function currently represented in a quantum circuit. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). weights (array): The trained weights of the quantum circuit. data (array): The input domain data. \"\"\" fig_name = \"trained.pdf\" fig_path = os.path.join(config.output_folder_name, fig_name) logger.info(f\"Plotting trained function\") device = qml.device(\"default.qubit\", wires=config.num_qubits, shots=None) node = qml.QNode(ansatz.ansatz, device) f = [ node(weights, x=problem.get_domain_map().global2local(x_)) for x_ in data ] plt.close(\"all\") plt.plot(data, f, color=line_color, linewidth=line_thickness) plt.xlabel(\"x\", fontsize=font_size) plt.ylabel(\"f(x)\", fontsize=font_size) plt.tight_layout() plt.savefig(fig_path)","title":"plot_trained_function"},{"location":"module_draw_and_plot/#draw_and_plot.recover_and_plot","text":"Recovers training data from an ADIOS2 file and creates the relevant plots from it. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required data array The input data. required target array The target data, i.e., the data the circuit should have obtained if training was perfect. required Source code in src/draw_and_plot.py def recover_and_plot(config: cfg.ConfigData, ansatz: ans.Ansatz, problem: prob.Problem, data, target): \"\"\" Recovers training data from an ADIOS2 file and creates the relevant plots from it. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). data (array): The input data. target (array): The target data, i.e., the data the circuit should have obtained if training was perfect. \"\"\" # Find all .bp files file_list = list( filter( lambda x: os.path.splitext(x)[1] == \".bp\", os.listdir(config.output_folder_name) ) ) if len(file_list) == 0: logger.error( f\"Unable to find bp files to recover from in { config.output_folder_name}\" ) exit(1) # Recover cost iterations = [] cost_data = [] for file in file_list: file_path = os.path.join(config.output_folder_name, file) logger.info(f\"Recovering cost data from checkpoint file {file_path}\") with adios2.FileReader(file_path) as s: attrs = s.available_attributes() vars = s.available_variables() steps = int(vars[\"weights\"][\"AvailableStepsCount\"]) first_iter = int(attrs[\"first_iter\"][\"Value\"]) # cost in all steps costs = s.read(\"cost\", step_selection=[0, steps]) for i in range(len(costs)): iterations.append(first_iter + i) cost_data.append(costs[i]) # Recover the weights of the last iteration of the last checkpoint file weights = None with adios2.FileReader(file_path) as s: vars = s.available_variables() steps = int(vars[\"weights\"][\"AvailableStepsCount\"]) logger.info( f\"Recovering weight data from checkpoint file {file_path}\" ) weights = np.array( s.read(\"weights\", step_selection=[steps - 1, 1]), requires_grad=True ) plot_cost(config.output_folder_name, iterations, cost_data) plot_trained_function(config, ansatz, problem, weights, data) if target is not None: plot_trained_error(config, ansatz, problem, weights, data, target) plot_trained_error_abs(config, ansatz, problem, weights, data, target)","title":"recover_and_plot"},{"location":"module_function_fitting/","text":"Module function_fitting A problem type defined by training a quantum circuit to fit a target function. FitToFunction Bases: Problem Defines a function fitting problem for the quantum circuit to solve. Source code in src/function_fitting.py class FitToFunction(prb.Problem): \"\"\" Defines a function fitting problem for the quantum circuit to solve. \"\"\" def __init__(self, x0: float, xf: float, x, optimizer: str): \"\"\" Initializes the problem object Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. x (array): List of input points in the[x0, xf] range optimizer (str): Name of the optimizer library to use. \"\"\" self.map = dm.LinearMap(x0, xf) self.target = f_numpy(x) if optimizer == \"numpy\": self.f = f_numpy elif optimizer == \"torch\": self.f = f_torch else: print(f\"Unrecognized optimizer \\\"{optimizer}\\\"\") exit(1) def get_domain_map(self): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self.map def cost_pointwise(self, node, weights, x): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" X = self.map.global2local(x) Y = node(weights, x=X) y = self.f(x) return (Y - y) def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" s = sum(self.cost_pointwise(node, weights, x) ** 2 for x in data) return s / N __init__(x0, xf, x, optimizer) Initializes the problem object Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. x (array): List of input points in the[x0, xf] range optimizer (str): Name of the optimizer library to use. Source code in src/function_fitting.py def __init__(self, x0: float, xf: float, x, optimizer: str): \"\"\" Initializes the problem object Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. x (array): List of input points in the[x0, xf] range optimizer (str): Name of the optimizer library to use. \"\"\" self.map = dm.LinearMap(x0, xf) self.target = f_numpy(x) if optimizer == \"numpy\": self.f = f_numpy elif optimizer == \"torch\": self.f = f_torch else: print(f\"Unrecognized optimizer \\\"{optimizer}\\\"\") exit(1) cost(node, weights, data, N) Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/function_fitting.py def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" s = sum(self.cost_pointwise(node, weights, x) ** 2 for x in data) return s / N cost_pointwise(node, weights, x) Returns the cost function of the problem at each point in the input domain. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required x float The point where to comput the cost function. required Source code in src/function_fitting.py def cost_pointwise(self, node, weights, x): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" X = self.map.global2local(x) Y = node(weights, x=X) y = self.f(x) return (Y - y) get_domain_map() Returns: Type Description DomainMap The linear domain map used in the problem. Source code in src/function_fitting.py def get_domain_map(self): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self.map f_numpy(x) The target function, using the torch library. Parameters: Name Type Description Default x float the point where to evaluate the function. required Source code in src/function_fitting.py def f_numpy(x): \"\"\" The target function, using the `torch` library. Parameters: x (float): the point where to evaluate the function. \"\"\" return np.exp(x * np.cos(3.0 * np.pi * x)) / 2.0 f_torch(x) The target function, using the torch library. Parameters: Name Type Description Default x float the point where to evaluate the function. required Source code in src/function_fitting.py def f_torch(x): \"\"\" The target function, using the `torch` library. Parameters: x (float): the point where to evaluate the function. \"\"\" return torch.exp(x * torch.cos(3.0 * torch.pi * x)) / 2.0","title":"function_fitting"},{"location":"module_function_fitting/#module-function_fitting","text":"A problem type defined by training a quantum circuit to fit a target function.","title":"Module function_fitting"},{"location":"module_function_fitting/#function_fitting.FitToFunction","text":"Bases: Problem Defines a function fitting problem for the quantum circuit to solve. Source code in src/function_fitting.py class FitToFunction(prb.Problem): \"\"\" Defines a function fitting problem for the quantum circuit to solve. \"\"\" def __init__(self, x0: float, xf: float, x, optimizer: str): \"\"\" Initializes the problem object Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. x (array): List of input points in the[x0, xf] range optimizer (str): Name of the optimizer library to use. \"\"\" self.map = dm.LinearMap(x0, xf) self.target = f_numpy(x) if optimizer == \"numpy\": self.f = f_numpy elif optimizer == \"torch\": self.f = f_torch else: print(f\"Unrecognized optimizer \\\"{optimizer}\\\"\") exit(1) def get_domain_map(self): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self.map def cost_pointwise(self, node, weights, x): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" X = self.map.global2local(x) Y = node(weights, x=X) y = self.f(x) return (Y - y) def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" s = sum(self.cost_pointwise(node, weights, x) ** 2 for x in data) return s / N","title":"FitToFunction"},{"location":"module_function_fitting/#function_fitting.FitToFunction.__init__","text":"Initializes the problem object Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. x (array): List of input points in the[x0, xf] range optimizer (str): Name of the optimizer library to use. Source code in src/function_fitting.py def __init__(self, x0: float, xf: float, x, optimizer: str): \"\"\" Initializes the problem object Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. x (array): List of input points in the[x0, xf] range optimizer (str): Name of the optimizer library to use. \"\"\" self.map = dm.LinearMap(x0, xf) self.target = f_numpy(x) if optimizer == \"numpy\": self.f = f_numpy elif optimizer == \"torch\": self.f = f_torch else: print(f\"Unrecognized optimizer \\\"{optimizer}\\\"\") exit(1)","title":"__init__"},{"location":"module_function_fitting/#function_fitting.FitToFunction.cost","text":"Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/function_fitting.py def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" s = sum(self.cost_pointwise(node, weights, x) ** 2 for x in data) return s / N","title":"cost"},{"location":"module_function_fitting/#function_fitting.FitToFunction.cost_pointwise","text":"Returns the cost function of the problem at each point in the input domain. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required x float The point where to comput the cost function. required Source code in src/function_fitting.py def cost_pointwise(self, node, weights, x): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" X = self.map.global2local(x) Y = node(weights, x=X) y = self.f(x) return (Y - y)","title":"cost_pointwise"},{"location":"module_function_fitting/#function_fitting.FitToFunction.get_domain_map","text":"Returns: Type Description DomainMap The linear domain map used in the problem. Source code in src/function_fitting.py def get_domain_map(self): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self.map","title":"get_domain_map"},{"location":"module_function_fitting/#function_fitting.f_numpy","text":"The target function, using the torch library. Parameters: Name Type Description Default x float the point where to evaluate the function. required Source code in src/function_fitting.py def f_numpy(x): \"\"\" The target function, using the `torch` library. Parameters: x (float): the point where to evaluate the function. \"\"\" return np.exp(x * np.cos(3.0 * np.pi * x)) / 2.0","title":"f_numpy"},{"location":"module_function_fitting/#function_fitting.f_torch","text":"The target function, using the torch library. Parameters: Name Type Description Default x float the point where to evaluate the function. required Source code in src/function_fitting.py def f_torch(x): \"\"\" The target function, using the `torch` library. Parameters: x (float): the point where to evaluate the function. \"\"\" return torch.exp(x * torch.cos(3.0 * torch.pi * x)) / 2.0","title":"f_torch"},{"location":"module_hagen_poiseuille/","text":"Module hagen_poiseuille A problem type defined by training a quantum circuit to solve the Hagen-Poiseuille ODE. HagenPoiseuille Bases: Problem Solves the Hagen-Poiseuille equation, as defined here . Source code in src/hagen_poiseuille.py class HagenPoiseuille(prb.Problem): \"\"\" Solves the Hagen-Poiseuille equation, as defined [here](https://en.wikipedia.org/wiki/Hagen%E2%80%93Poiseuille_equation). \"\"\" def __init__(self, x0: float, xf: float, G: float, R: float, mu: float): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self.map = dm.LinearMap(x0, xf) self.G = G self.R = R self.mu = mu def get_domain_map(self): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self.map def cost_int_pointwise(self, node, weights, x): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self.map.global2local(x) # Compute derivatives in local space l_dfdX = qd.df(node, weights, x=X) l_d2fdX2 = qd.d2f(node, weights, x=X) # Compute jacobians dldg = self.map.dlocal_dglobal(x) d2ldg2 = self.map.d2local_dglobal2(x) # Compute derivatives in global space g_dfdx = dldg * l_dfdX g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return (g_d2fdx2 + self.G/self.mu) * x + g_dfdx def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = (node(weights, x=self.map.global2local( self.map.global_start)) - self.G * self.R**2 / (4.0 * self.mu))**2 bc_r = (node(weights, x=self.map.global2local(self.map.global_end)))**2 bc_d = (qd.df(node, weights, x=self.map.global2local( self.map.global_start)))**2 # Interior cost int_cost = sum(self.cost_int_pointwise( node, weights, x) ** 2 for x in data) return (bc_l + bc_r + bc_d + int_cost) / N __init__(x0, xf, G, R, mu) Initializes the problem object. Parameters: Name Type Description Default x0 float Left boundary of the domain. required xf float Righr boundary of the domain. required G float Hagen Poiseuille G parameter. required R float Hagen Poiseuille R parameter. required mu float Hagen Poiseuille mu parameter. required Source code in src/hagen_poiseuille.py def __init__(self, x0: float, xf: float, G: float, R: float, mu: float): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self.map = dm.LinearMap(x0, xf) self.G = G self.R = R self.mu = mu cost(node, weights, data, N) Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/hagen_poiseuille.py def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = (node(weights, x=self.map.global2local( self.map.global_start)) - self.G * self.R**2 / (4.0 * self.mu))**2 bc_r = (node(weights, x=self.map.global2local(self.map.global_end)))**2 bc_d = (qd.df(node, weights, x=self.map.global2local( self.map.global_start)))**2 # Interior cost int_cost = sum(self.cost_int_pointwise( node, weights, x) ** 2 for x in data) return (bc_l + bc_r + bc_d + int_cost) / N cost_int_pointwise(node, weights, x) Returns the cost function of the problem at each point in the input domain. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required x float The point where to comput the cost function. required Source code in src/hagen_poiseuille.py def cost_int_pointwise(self, node, weights, x): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self.map.global2local(x) # Compute derivatives in local space l_dfdX = qd.df(node, weights, x=X) l_d2fdX2 = qd.d2f(node, weights, x=X) # Compute jacobians dldg = self.map.dlocal_dglobal(x) d2ldg2 = self.map.d2local_dglobal2(x) # Compute derivatives in global space g_dfdx = dldg * l_dfdX g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return (g_d2fdx2 + self.G/self.mu) * x + g_dfdx get_domain_map() Returns: Type Description DomainMap The linear domain map used in the problem. Source code in src/hagen_poiseuille.py def get_domain_map(self): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self.map PlaneHagenPoiseuille Bases: Problem Solves the Hagen-Poiseuille equation between to infinite plates as defined here . Source code in src/hagen_poiseuille.py class PlaneHagenPoiseuille(prb.Problem): \"\"\" Solves the Hagen-Poiseuille equation between to infinite plates as defined [here](https://en.wikipedia.org/wiki/Hagen%E2%80%93Poiseuille_equation). \"\"\" def __init__(self, x0: float, xf: float, x, G: float, R: float, mu: float): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self.map = dm.LinearMap(x0, xf) self.G = G self.R = R self.mu = mu self.target = self.G / (2 * self.mu) * x * (xf - x) def get_domain_map(self): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self.map def cost_int_pointwise(self, node, weights, x): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self.map.global2local(x) # Compute derivatives in local space l_dfdX = qd.df(node, weights, x=X) l_d2fdX2 = qd.d2f(node, weights, x=X) # Compute jacobians dldg = self.map.dlocal_dglobal(x) d2ldg2 = self.map.d2local_dglobal2(x) # Compute derivatives in global space g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return g_d2fdx2 + self.G/self.mu def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = (node(weights, x=self.map.global2local(self.map.global_start)))**2 bc_r = (node(weights, x=self.map.global2local(self.map.global_end)))**2 # Interior cost int_cost = sum(self.cost_int_pointwise( node, weights, x) ** 2 for x in data) return (bc_l + bc_r + int_cost) / N __init__(x0, xf, x, G, R, mu) Initializes the problem object. Parameters: Name Type Description Default x0 float Left boundary of the domain. required xf float Righr boundary of the domain. required G float Hagen Poiseuille G parameter. required R float Hagen Poiseuille R parameter. required mu float Hagen Poiseuille mu parameter. required Source code in src/hagen_poiseuille.py def __init__(self, x0: float, xf: float, x, G: float, R: float, mu: float): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self.map = dm.LinearMap(x0, xf) self.G = G self.R = R self.mu = mu self.target = self.G / (2 * self.mu) * x * (xf - x) cost(node, weights, data, N) Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/hagen_poiseuille.py def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = (node(weights, x=self.map.global2local(self.map.global_start)))**2 bc_r = (node(weights, x=self.map.global2local(self.map.global_end)))**2 # Interior cost int_cost = sum(self.cost_int_pointwise( node, weights, x) ** 2 for x in data) return (bc_l + bc_r + int_cost) / N cost_int_pointwise(node, weights, x) Returns the cost function of the problem at each point in the input domain. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required x float The point where to comput the cost function. required Source code in src/hagen_poiseuille.py def cost_int_pointwise(self, node, weights, x): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self.map.global2local(x) # Compute derivatives in local space l_dfdX = qd.df(node, weights, x=X) l_d2fdX2 = qd.d2f(node, weights, x=X) # Compute jacobians dldg = self.map.dlocal_dglobal(x) d2ldg2 = self.map.d2local_dglobal2(x) # Compute derivatives in global space g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return g_d2fdx2 + self.G/self.mu get_domain_map() Returns: Type Description DomainMap The linear domain map used in the problem. Source code in src/hagen_poiseuille.py def get_domain_map(self): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self.map","title":"hagen_poiseuille"},{"location":"module_hagen_poiseuille/#module-hagen_poiseuille","text":"A problem type defined by training a quantum circuit to solve the Hagen-Poiseuille ODE.","title":"Module hagen_poiseuille"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.HagenPoiseuille","text":"Bases: Problem Solves the Hagen-Poiseuille equation, as defined here . Source code in src/hagen_poiseuille.py class HagenPoiseuille(prb.Problem): \"\"\" Solves the Hagen-Poiseuille equation, as defined [here](https://en.wikipedia.org/wiki/Hagen%E2%80%93Poiseuille_equation). \"\"\" def __init__(self, x0: float, xf: float, G: float, R: float, mu: float): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self.map = dm.LinearMap(x0, xf) self.G = G self.R = R self.mu = mu def get_domain_map(self): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self.map def cost_int_pointwise(self, node, weights, x): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self.map.global2local(x) # Compute derivatives in local space l_dfdX = qd.df(node, weights, x=X) l_d2fdX2 = qd.d2f(node, weights, x=X) # Compute jacobians dldg = self.map.dlocal_dglobal(x) d2ldg2 = self.map.d2local_dglobal2(x) # Compute derivatives in global space g_dfdx = dldg * l_dfdX g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return (g_d2fdx2 + self.G/self.mu) * x + g_dfdx def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = (node(weights, x=self.map.global2local( self.map.global_start)) - self.G * self.R**2 / (4.0 * self.mu))**2 bc_r = (node(weights, x=self.map.global2local(self.map.global_end)))**2 bc_d = (qd.df(node, weights, x=self.map.global2local( self.map.global_start)))**2 # Interior cost int_cost = sum(self.cost_int_pointwise( node, weights, x) ** 2 for x in data) return (bc_l + bc_r + bc_d + int_cost) / N","title":"HagenPoiseuille"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.HagenPoiseuille.__init__","text":"Initializes the problem object. Parameters: Name Type Description Default x0 float Left boundary of the domain. required xf float Righr boundary of the domain. required G float Hagen Poiseuille G parameter. required R float Hagen Poiseuille R parameter. required mu float Hagen Poiseuille mu parameter. required Source code in src/hagen_poiseuille.py def __init__(self, x0: float, xf: float, G: float, R: float, mu: float): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self.map = dm.LinearMap(x0, xf) self.G = G self.R = R self.mu = mu","title":"__init__"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.HagenPoiseuille.cost","text":"Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/hagen_poiseuille.py def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = (node(weights, x=self.map.global2local( self.map.global_start)) - self.G * self.R**2 / (4.0 * self.mu))**2 bc_r = (node(weights, x=self.map.global2local(self.map.global_end)))**2 bc_d = (qd.df(node, weights, x=self.map.global2local( self.map.global_start)))**2 # Interior cost int_cost = sum(self.cost_int_pointwise( node, weights, x) ** 2 for x in data) return (bc_l + bc_r + bc_d + int_cost) / N","title":"cost"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.HagenPoiseuille.cost_int_pointwise","text":"Returns the cost function of the problem at each point in the input domain. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required x float The point where to comput the cost function. required Source code in src/hagen_poiseuille.py def cost_int_pointwise(self, node, weights, x): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self.map.global2local(x) # Compute derivatives in local space l_dfdX = qd.df(node, weights, x=X) l_d2fdX2 = qd.d2f(node, weights, x=X) # Compute jacobians dldg = self.map.dlocal_dglobal(x) d2ldg2 = self.map.d2local_dglobal2(x) # Compute derivatives in global space g_dfdx = dldg * l_dfdX g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return (g_d2fdx2 + self.G/self.mu) * x + g_dfdx","title":"cost_int_pointwise"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.HagenPoiseuille.get_domain_map","text":"Returns: Type Description DomainMap The linear domain map used in the problem. Source code in src/hagen_poiseuille.py def get_domain_map(self): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self.map","title":"get_domain_map"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.PlaneHagenPoiseuille","text":"Bases: Problem Solves the Hagen-Poiseuille equation between to infinite plates as defined here . Source code in src/hagen_poiseuille.py class PlaneHagenPoiseuille(prb.Problem): \"\"\" Solves the Hagen-Poiseuille equation between to infinite plates as defined [here](https://en.wikipedia.org/wiki/Hagen%E2%80%93Poiseuille_equation). \"\"\" def __init__(self, x0: float, xf: float, x, G: float, R: float, mu: float): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self.map = dm.LinearMap(x0, xf) self.G = G self.R = R self.mu = mu self.target = self.G / (2 * self.mu) * x * (xf - x) def get_domain_map(self): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self.map def cost_int_pointwise(self, node, weights, x): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self.map.global2local(x) # Compute derivatives in local space l_dfdX = qd.df(node, weights, x=X) l_d2fdX2 = qd.d2f(node, weights, x=X) # Compute jacobians dldg = self.map.dlocal_dglobal(x) d2ldg2 = self.map.d2local_dglobal2(x) # Compute derivatives in global space g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return g_d2fdx2 + self.G/self.mu def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = (node(weights, x=self.map.global2local(self.map.global_start)))**2 bc_r = (node(weights, x=self.map.global2local(self.map.global_end)))**2 # Interior cost int_cost = sum(self.cost_int_pointwise( node, weights, x) ** 2 for x in data) return (bc_l + bc_r + int_cost) / N","title":"PlaneHagenPoiseuille"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.PlaneHagenPoiseuille.__init__","text":"Initializes the problem object. Parameters: Name Type Description Default x0 float Left boundary of the domain. required xf float Righr boundary of the domain. required G float Hagen Poiseuille G parameter. required R float Hagen Poiseuille R parameter. required mu float Hagen Poiseuille mu parameter. required Source code in src/hagen_poiseuille.py def __init__(self, x0: float, xf: float, x, G: float, R: float, mu: float): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self.map = dm.LinearMap(x0, xf) self.G = G self.R = R self.mu = mu self.target = self.G / (2 * self.mu) * x * (xf - x)","title":"__init__"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.PlaneHagenPoiseuille.cost","text":"Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/hagen_poiseuille.py def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = (node(weights, x=self.map.global2local(self.map.global_start)))**2 bc_r = (node(weights, x=self.map.global2local(self.map.global_end)))**2 # Interior cost int_cost = sum(self.cost_int_pointwise( node, weights, x) ** 2 for x in data) return (bc_l + bc_r + int_cost) / N","title":"cost"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.PlaneHagenPoiseuille.cost_int_pointwise","text":"Returns the cost function of the problem at each point in the input domain. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required x float The point where to comput the cost function. required Source code in src/hagen_poiseuille.py def cost_int_pointwise(self, node, weights, x): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self.map.global2local(x) # Compute derivatives in local space l_dfdX = qd.df(node, weights, x=X) l_d2fdX2 = qd.d2f(node, weights, x=X) # Compute jacobians dldg = self.map.dlocal_dglobal(x) d2ldg2 = self.map.d2local_dglobal2(x) # Compute derivatives in global space g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return g_d2fdx2 + self.G/self.mu","title":"cost_int_pointwise"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.PlaneHagenPoiseuille.get_domain_map","text":"Returns: Type Description DomainMap The linear domain map used in the problem. Source code in src/hagen_poiseuille.py def get_domain_map(self): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self.map","title":"get_domain_map"},{"location":"module_hp_params/","text":"Module hp_params Contains Hagen Poiseuille problem data handlers. HagenPoiseuilleParams A databag for storing the needed parameters of the Hagen-Poiseuille problem. Attributes: Name Type Description G float The Hagen-Poiseuille G value. R float The Hagen-Poiseuille R value. mu float The Hagen-Poiseuille mu value. Source code in src/hp_params.py class HagenPoiseuilleParams: \"\"\" A databag for storing the needed parameters of the Hagen-Poiseuille problem. Attributes: G (float): The Hagen-Poiseuille `G` value. R (float): The Hagen-Poiseuille `R` value. mu (float): The Hagen-Poiseuille `mu` value. \"\"\" def __init__(self, G, R, mu): \"\"\" A databag for storing the needed parameters of the Hagen-Poiseuille problem. Parameters: G (float): The Hagen-Poiseuille `G` value. R (float): The Hagen-Poiseuille `R` value. mu (float): The Hagen-Poiseuille `mu` value. \"\"\" self.G = G self.R = R self.mu = mu __init__(G, R, mu) A databag for storing the needed parameters of the Hagen-Poiseuille problem. Parameters: Name Type Description Default G float The Hagen-Poiseuille G value. required R float The Hagen-Poiseuille R value. required mu float The Hagen-Poiseuille mu value. required Source code in src/hp_params.py def __init__(self, G, R, mu): \"\"\" A databag for storing the needed parameters of the Hagen-Poiseuille problem. Parameters: G (float): The Hagen-Poiseuille `G` value. R (float): The Hagen-Poiseuille `R` value. mu (float): The Hagen-Poiseuille `mu` value. \"\"\" self.G = G self.R = R self.mu = mu","title":"hp_params"},{"location":"module_hp_params/#module-hp_params","text":"Contains Hagen Poiseuille problem data handlers.","title":"Module hp_params"},{"location":"module_hp_params/#hp_params.HagenPoiseuilleParams","text":"A databag for storing the needed parameters of the Hagen-Poiseuille problem. Attributes: Name Type Description G float The Hagen-Poiseuille G value. R float The Hagen-Poiseuille R value. mu float The Hagen-Poiseuille mu value. Source code in src/hp_params.py class HagenPoiseuilleParams: \"\"\" A databag for storing the needed parameters of the Hagen-Poiseuille problem. Attributes: G (float): The Hagen-Poiseuille `G` value. R (float): The Hagen-Poiseuille `R` value. mu (float): The Hagen-Poiseuille `mu` value. \"\"\" def __init__(self, G, R, mu): \"\"\" A databag for storing the needed parameters of the Hagen-Poiseuille problem. Parameters: G (float): The Hagen-Poiseuille `G` value. R (float): The Hagen-Poiseuille `R` value. mu (float): The Hagen-Poiseuille `mu` value. \"\"\" self.G = G self.R = R self.mu = mu","title":"HagenPoiseuilleParams"},{"location":"module_hp_params/#hp_params.HagenPoiseuilleParams.__init__","text":"A databag for storing the needed parameters of the Hagen-Poiseuille problem. Parameters: Name Type Description Default G float The Hagen-Poiseuille G value. required R float The Hagen-Poiseuille R value. required mu float The Hagen-Poiseuille mu value. required Source code in src/hp_params.py def __init__(self, G, R, mu): \"\"\" A databag for storing the needed parameters of the Hagen-Poiseuille problem. Parameters: G (float): The Hagen-Poiseuille `G` value. R (float): The Hagen-Poiseuille `R` value. mu (float): The Hagen-Poiseuille `mu` value. \"\"\" self.G = G self.R = R self.mu = mu","title":"__init__"},{"location":"module_optimize/","text":"Module optimize Contains the main optimizer functionality for training circuits numpy_optimize(out, ansatz, problem, params, config, data, random_generator) Optimizes the quantum circuit to solve a problem using the Numpy library. Parameters: Name Type Description Default out Output The output object controlling where the training data will be saved to / recovered from. required ansatz Ansatz The trainable ansatz circuit for solving the problem. required problem Problem The problem object containing the problem type to be solved. required params OptimizerParams The configuration parameters of the optimizer. required config ConfigData The program configuration data. required data array The domain data points. required random_generator Generator A random number generator used for initializing the circuit weights. required Source code in src/optimize.py def numpy_optimize(out: out.Output, ansatz: ans.Ansatz, problem: prb.Problem, params: op.OptimizerParams, config: cfg.ConfigData, data, random_generator): \"\"\" Optimizes the quantum circuit to solve a problem using the Numpy library. Parameters: out (Output): The output object controlling where the training data will be saved to / recovered from. ansatz (Ansatz): The trainable ansatz circuit for solving the problem. problem (Problem): The problem object containing the problem type to be solved. params (OptimizerParams): The configuration parameters of the optimizer. config (ConfigData): The program configuration data. data (array): The domain data points. random_generator (numpy.random.Generator): A random number generator used for initializing the circuit weights. \"\"\" # Quantum device device = qml.device( \"lightning.kokkos\", wires=config.num_qubits, shots=None ) node = qml.QNode( ansatz.ansatz, device, diff_method=\"adjoint\" ) # Recovery if out.recovered: first_iter = out.first_iter weights = np.array(out.weights, requires_grad=True) else: first_iter = 0 weights = ansatz.weights last_iter = first_iter + params.max_iters out.output_stream.write_attribute(\"first_iter\", first_iter) out.output_stream.write_attribute(\"last_iter\", last_iter - 1) out.output_stream.write_attribute(\"weights_shape\", weights.shape) opt = qml.AdamOptimizer(params.step) stopping_criteria = \"max iterations reached\" N_data = len(data) for i in range(first_iter, last_iter): if params.batch_size != 0: batch_indices = random_generator.integers( 1, N_data - 2, size=params.batch_size, endpoint=True ) batch_data = data[batch_indices] N_batch = params.batch_size else: batch_data = data N_batch = N_data # save, and print the current cost c = np.sqrt(problem.cost(node, weights, batch_data, N_batch)) out.output_stream.begin_step() out.output_stream.write(\"iteration\", i) out.output_stream.write(\"cost\", c) out.output_stream.write( \"weights\", weights.numpy(), weights.shape, [0] * len(weights.shape), weights.shape ) out.output_stream.end_step() if np.abs(c) < params.abstol: stopping_criteria = \"absolute tolerance reached\" break else: weights = opt.step( lambda w: np.sqrt(problem.cost(node, w, data, N_data)), weights ) logger.info(f\"Loss in teration {i} = {c}\") # Results logger.info(\"Training done\") logger.info(f\"Stopping criteria: {stopping_criteria}\") torch_optimize(out, ansatz, problem, params, config, data_in, random_generator) Optimizes the quantum circuit to solve a problem using the Torch library. Parameters: Name Type Description Default out Output The output object controlling where the training data will be saved to / recovered from. required ansatz Ansatz The trainable ansatz circuit for solving the problem. required problem Problem The problem object containing the problem type to be solved. required params OptimizerParams The configuration parameters of the optimizer. required config ConfigData The program configuration data. required data_in array The domain data points. required random_generator Generator A random number generator used for initializing the circuit weights. required Source code in src/optimize.py def torch_optimize(out: out.Output, ansatz: ans.Ansatz, problem: prb.Problem, params: op.OptimizerParams, config: cfg.ConfigData, data_in, random_generator): \"\"\" Optimizes the quantum circuit to solve a problem using the Torch library. Parameters: out (Output): The output object controlling where the training data will be saved to / recovered from. ansatz (Ansatz): The trainable ansatz circuit for solving the problem. problem (Problem): The problem object containing the problem type to be solved. params (OptimizerParams): The configuration parameters of the optimizer. config (ConfigData): The program configuration data. data_in (array): The domain data points. random_generator (numpy.random.Generator): A random number generator used for initializing the circuit weights. \"\"\" # Quantum device device = qml.device( \"default.qubit\", wires=config.num_qubits, shots=None ) node = qml.QNode( ansatz.ansatz, device, interface=\"torch\", diff_method=\"backprop\" ) # Recovery if out.recovered: first_iter = out.first_iter if config.use_cuda: weights = torch.tensor( out.weights, requires_grad=True, device=\"cuda\") else: weights = torch.tensor( out.weights, requires_grad=True, device=\"cpu\") else: first_iter = 0 if config.use_cuda: weights = torch.tensor( ansatz.weights, requires_grad=True, device=\"cuda\") else: weights = torch.tensor( ansatz.weights, requires_grad=True, device=\"cpu\") last_iter = first_iter + params.max_iters out.output_stream.write_attribute(\"first_iter\", first_iter) out.output_stream.write_attribute(\"last_iter\", last_iter - 1) out.output_stream.write_attribute(\"weights_shape\", weights.shape) opt = torch.optim.LBFGS([weights], lr=params.step) # Adaptive LR. See # https://pytorch.org/docs/stable/generated/torch.optim.lr_scheduler.ReduceLROnPlateau.html#torch.optim.lr_scheduler.ReduceLROnPlateau sch = torch.optim.lr_scheduler.ReduceLROnPlateau( opt, \"min\", 0.1, 5, 1.0e-4, \"rel\", 0, 0.0, 1.0e-8 ) stopping_criteria = \"max iterations reached\" if config.use_cuda: data = torch.tensor(data_in, requires_grad=False, device=\"cuda\") else: data = torch.tensor(data_in, requires_grad=False, device=\"cpu\") N_data = len(data) # Optimization loop for i in range(first_iter, last_iter): if params.batch_size != 0: batch_indices = random_generator.integers( 1, N_data - 2, size=params.batch_size, endpoint=True ) if config.use_cuda: batch_data = torch.tensor( data[batch_indices], requires_grad=False, device=\"cuda\") else: batch_data = torch.tensor( data[batch_indices], requires_grad=False, device=\"cpu\") N_batch = params.batch_size else: batch_data = data N_batch = N_data def torch_cost(): opt.zero_grad() c = torch.sqrt(problem.cost( node, weights, batch_data, N_batch)) c.backward() return c # save, and print the current cost c = torch_cost().item() out.output_stream.begin_step() out.output_stream.write(\"iteration\", i) out.output_stream.write(\"cost\", c) out.output_stream.write( \"weights\", weights.cpu().detach().numpy(), weights.shape, [0] * len(weights.shape), weights.shape ) out.output_stream.end_step() if np.abs(c) < params.abstol: stopping_criteria = \"absolute tolerance reached\" break else: opt.step(torch_cost) sch.step(c) logger.info(f\"(Loss, LR) in iteration {i} = ({c}, {sch.get_last_lr()})\") # Results logger.info(\"Training done\") logger.info(f\"Stopping criteria: {stopping_criteria}\")","title":"optimize"},{"location":"module_optimize/#module-optimize","text":"Contains the main optimizer functionality for training circuits","title":"Module optimize"},{"location":"module_optimize/#optimize.numpy_optimize","text":"Optimizes the quantum circuit to solve a problem using the Numpy library. Parameters: Name Type Description Default out Output The output object controlling where the training data will be saved to / recovered from. required ansatz Ansatz The trainable ansatz circuit for solving the problem. required problem Problem The problem object containing the problem type to be solved. required params OptimizerParams The configuration parameters of the optimizer. required config ConfigData The program configuration data. required data array The domain data points. required random_generator Generator A random number generator used for initializing the circuit weights. required Source code in src/optimize.py def numpy_optimize(out: out.Output, ansatz: ans.Ansatz, problem: prb.Problem, params: op.OptimizerParams, config: cfg.ConfigData, data, random_generator): \"\"\" Optimizes the quantum circuit to solve a problem using the Numpy library. Parameters: out (Output): The output object controlling where the training data will be saved to / recovered from. ansatz (Ansatz): The trainable ansatz circuit for solving the problem. problem (Problem): The problem object containing the problem type to be solved. params (OptimizerParams): The configuration parameters of the optimizer. config (ConfigData): The program configuration data. data (array): The domain data points. random_generator (numpy.random.Generator): A random number generator used for initializing the circuit weights. \"\"\" # Quantum device device = qml.device( \"lightning.kokkos\", wires=config.num_qubits, shots=None ) node = qml.QNode( ansatz.ansatz, device, diff_method=\"adjoint\" ) # Recovery if out.recovered: first_iter = out.first_iter weights = np.array(out.weights, requires_grad=True) else: first_iter = 0 weights = ansatz.weights last_iter = first_iter + params.max_iters out.output_stream.write_attribute(\"first_iter\", first_iter) out.output_stream.write_attribute(\"last_iter\", last_iter - 1) out.output_stream.write_attribute(\"weights_shape\", weights.shape) opt = qml.AdamOptimizer(params.step) stopping_criteria = \"max iterations reached\" N_data = len(data) for i in range(first_iter, last_iter): if params.batch_size != 0: batch_indices = random_generator.integers( 1, N_data - 2, size=params.batch_size, endpoint=True ) batch_data = data[batch_indices] N_batch = params.batch_size else: batch_data = data N_batch = N_data # save, and print the current cost c = np.sqrt(problem.cost(node, weights, batch_data, N_batch)) out.output_stream.begin_step() out.output_stream.write(\"iteration\", i) out.output_stream.write(\"cost\", c) out.output_stream.write( \"weights\", weights.numpy(), weights.shape, [0] * len(weights.shape), weights.shape ) out.output_stream.end_step() if np.abs(c) < params.abstol: stopping_criteria = \"absolute tolerance reached\" break else: weights = opt.step( lambda w: np.sqrt(problem.cost(node, w, data, N_data)), weights ) logger.info(f\"Loss in teration {i} = {c}\") # Results logger.info(\"Training done\") logger.info(f\"Stopping criteria: {stopping_criteria}\")","title":"numpy_optimize"},{"location":"module_optimize/#optimize.torch_optimize","text":"Optimizes the quantum circuit to solve a problem using the Torch library. Parameters: Name Type Description Default out Output The output object controlling where the training data will be saved to / recovered from. required ansatz Ansatz The trainable ansatz circuit for solving the problem. required problem Problem The problem object containing the problem type to be solved. required params OptimizerParams The configuration parameters of the optimizer. required config ConfigData The program configuration data. required data_in array The domain data points. required random_generator Generator A random number generator used for initializing the circuit weights. required Source code in src/optimize.py def torch_optimize(out: out.Output, ansatz: ans.Ansatz, problem: prb.Problem, params: op.OptimizerParams, config: cfg.ConfigData, data_in, random_generator): \"\"\" Optimizes the quantum circuit to solve a problem using the Torch library. Parameters: out (Output): The output object controlling where the training data will be saved to / recovered from. ansatz (Ansatz): The trainable ansatz circuit for solving the problem. problem (Problem): The problem object containing the problem type to be solved. params (OptimizerParams): The configuration parameters of the optimizer. config (ConfigData): The program configuration data. data_in (array): The domain data points. random_generator (numpy.random.Generator): A random number generator used for initializing the circuit weights. \"\"\" # Quantum device device = qml.device( \"default.qubit\", wires=config.num_qubits, shots=None ) node = qml.QNode( ansatz.ansatz, device, interface=\"torch\", diff_method=\"backprop\" ) # Recovery if out.recovered: first_iter = out.first_iter if config.use_cuda: weights = torch.tensor( out.weights, requires_grad=True, device=\"cuda\") else: weights = torch.tensor( out.weights, requires_grad=True, device=\"cpu\") else: first_iter = 0 if config.use_cuda: weights = torch.tensor( ansatz.weights, requires_grad=True, device=\"cuda\") else: weights = torch.tensor( ansatz.weights, requires_grad=True, device=\"cpu\") last_iter = first_iter + params.max_iters out.output_stream.write_attribute(\"first_iter\", first_iter) out.output_stream.write_attribute(\"last_iter\", last_iter - 1) out.output_stream.write_attribute(\"weights_shape\", weights.shape) opt = torch.optim.LBFGS([weights], lr=params.step) # Adaptive LR. See # https://pytorch.org/docs/stable/generated/torch.optim.lr_scheduler.ReduceLROnPlateau.html#torch.optim.lr_scheduler.ReduceLROnPlateau sch = torch.optim.lr_scheduler.ReduceLROnPlateau( opt, \"min\", 0.1, 5, 1.0e-4, \"rel\", 0, 0.0, 1.0e-8 ) stopping_criteria = \"max iterations reached\" if config.use_cuda: data = torch.tensor(data_in, requires_grad=False, device=\"cuda\") else: data = torch.tensor(data_in, requires_grad=False, device=\"cpu\") N_data = len(data) # Optimization loop for i in range(first_iter, last_iter): if params.batch_size != 0: batch_indices = random_generator.integers( 1, N_data - 2, size=params.batch_size, endpoint=True ) if config.use_cuda: batch_data = torch.tensor( data[batch_indices], requires_grad=False, device=\"cuda\") else: batch_data = torch.tensor( data[batch_indices], requires_grad=False, device=\"cpu\") N_batch = params.batch_size else: batch_data = data N_batch = N_data def torch_cost(): opt.zero_grad() c = torch.sqrt(problem.cost( node, weights, batch_data, N_batch)) c.backward() return c # save, and print the current cost c = torch_cost().item() out.output_stream.begin_step() out.output_stream.write(\"iteration\", i) out.output_stream.write(\"cost\", c) out.output_stream.write( \"weights\", weights.cpu().detach().numpy(), weights.shape, [0] * len(weights.shape), weights.shape ) out.output_stream.end_step() if np.abs(c) < params.abstol: stopping_criteria = \"absolute tolerance reached\" break else: opt.step(torch_cost) sch.step(c) logger.info(f\"(Loss, LR) in iteration {i} = ({c}, {sch.get_last_lr()})\") # Results logger.info(\"Training done\") logger.info(f\"Stopping criteria: {stopping_criteria}\")","title":"torch_optimize"},{"location":"module_optimizer_params/","text":"Module optimizer_params Contains optimizer related configurations OptimizerParams A databag for holding circuit optimizer related data. Attributes: Name Type Description max_iters float The maximun number of steps the optimizer may take. abstol float The absolute tolerence of the error function below which training stops. step float Initial step size for the optimizer algorithim. batch_size int Size of the subdata array to use for batching. If 0 , batching is disabled. Source code in src/optimizer_params.py class OptimizerParams: \"\"\" A databag for holding circuit optimizer related data. Attributes: max_iters (float): The maximun number of steps the optimizer may take. abstol (float): The absolute tolerence of the error function below which training stops. step (float): Initial step size for the optimizer algorithim. batch_size (int): Size of the subdata array to use for batching. If `0`, batching is disabled. \"\"\" def __init__(self, max_iters: int, abstol: float, step: float, batch_size: int): \"\"\" Initialize the object. Parameters: max_iters (float): The maximun number of steps the optimizer may take. abstol (float): The absolute tolerence of the error function below which training stops. step (float): Initial step size for the optimizer algorithim. batch_size (int): Size of the subdata array to use for batching. If `0`, batching is disabled. \"\"\" self.max_iters = max_iters self.abstol = abstol self.step = step self.batch_size = batch_size __init__(max_iters, abstol, step, batch_size) Initialize the object. Parameters: Name Type Description Default max_iters float The maximun number of steps the optimizer may take. required abstol float The absolute tolerence of the error function below which training stops. required step float Initial step size for the optimizer algorithim. required batch_size int Size of the subdata array to use for batching. If 0 , batching is disabled. required Source code in src/optimizer_params.py def __init__(self, max_iters: int, abstol: float, step: float, batch_size: int): \"\"\" Initialize the object. Parameters: max_iters (float): The maximun number of steps the optimizer may take. abstol (float): The absolute tolerence of the error function below which training stops. step (float): Initial step size for the optimizer algorithim. batch_size (int): Size of the subdata array to use for batching. If `0`, batching is disabled. \"\"\" self.max_iters = max_iters self.abstol = abstol self.step = step self.batch_size = batch_size","title":"optimizer_params"},{"location":"module_optimizer_params/#module-optimizer_params","text":"Contains optimizer related configurations","title":"Module optimizer_params"},{"location":"module_optimizer_params/#optimizer_params.OptimizerParams","text":"A databag for holding circuit optimizer related data. Attributes: Name Type Description max_iters float The maximun number of steps the optimizer may take. abstol float The absolute tolerence of the error function below which training stops. step float Initial step size for the optimizer algorithim. batch_size int Size of the subdata array to use for batching. If 0 , batching is disabled. Source code in src/optimizer_params.py class OptimizerParams: \"\"\" A databag for holding circuit optimizer related data. Attributes: max_iters (float): The maximun number of steps the optimizer may take. abstol (float): The absolute tolerence of the error function below which training stops. step (float): Initial step size for the optimizer algorithim. batch_size (int): Size of the subdata array to use for batching. If `0`, batching is disabled. \"\"\" def __init__(self, max_iters: int, abstol: float, step: float, batch_size: int): \"\"\" Initialize the object. Parameters: max_iters (float): The maximun number of steps the optimizer may take. abstol (float): The absolute tolerence of the error function below which training stops. step (float): Initial step size for the optimizer algorithim. batch_size (int): Size of the subdata array to use for batching. If `0`, batching is disabled. \"\"\" self.max_iters = max_iters self.abstol = abstol self.step = step self.batch_size = batch_size","title":"OptimizerParams"},{"location":"module_optimizer_params/#optimizer_params.OptimizerParams.__init__","text":"Initialize the object. Parameters: Name Type Description Default max_iters float The maximun number of steps the optimizer may take. required abstol float The absolute tolerence of the error function below which training stops. required step float Initial step size for the optimizer algorithim. required batch_size int Size of the subdata array to use for batching. If 0 , batching is disabled. required Source code in src/optimizer_params.py def __init__(self, max_iters: int, abstol: float, step: float, batch_size: int): \"\"\" Initialize the object. Parameters: max_iters (float): The maximun number of steps the optimizer may take. abstol (float): The absolute tolerence of the error function below which training stops. step (float): Initial step size for the optimizer algorithim. batch_size (int): Size of the subdata array to use for batching. If `0`, batching is disabled. \"\"\" self.max_iters = max_iters self.abstol = abstol self.step = step self.batch_size = batch_size","title":"__init__"},{"location":"module_output/","text":"Module output Contains handlers for ouputting and recovering ADIOS2 training data. Output Holds a stream-writtable ADIOS2 file and creates new output files with the the correct naming convention for checkpointing. Source code in src/output.py class Output: \"\"\" Holds a stream-writtable ADIOS2 file and creates new output files with the the correct naming convention for checkpointing. \"\"\" def __init__(self, output_name: str, config_file: str): \"\"\" Initializes the object Parameters: output_name (str): The output folder name where data will be stored. config_file (str): The path of the configuration file, which will be copyied to the output data folder. \"\"\" self.output_name = output_name self.config_file = os.path.join( self.output_name, os.path.basename(config_file)) # Create output dir if not os.path.exists(self.output_name): os.makedirs(self.output_name) # Copy config if not os.path.exists(self.config_file): shutil.copy2(config_file, self.config_file) # Find all .bp files and extract last checkpoint from file name file_list = map(os.path.splitext, os.listdir(self.output_name)) file_list = filter(lambda x: x[1] == \".bp\", file_list) file_list = list(file_list) # Recover data from previous checkpoint if len(file_list) != 0: self.last_checkpoint = int(file_list[-1][0]) logger.info( f\"Recovering data from checkpoint {self.last_checkpoint}\" ) prev_output_file = os.path.join( self.output_name, f\"{self.last_checkpoint}.bp\" ) with adios2.FileReader(prev_output_file) as s: attrs = s.available_attributes() vars = s.available_variables() steps = int(vars[\"weights\"][\"AvailableStepsCount\"]) self.first_iter = int(attrs[\"last_iter\"][\"Value\"]) self.weights = s.read(\"weights\", step_selection=[steps - 1, 1]) self.recovered = True else: self.last_checkpoint = -1 self.first_iter = None self.weights = None self.recovered = False self.output_file = os.path.join( self.output_name, f\"{self.last_checkpoint + 1}.bp\" ) # Create ADIOS2 stream self.output_stream = adios2.Stream(self.output_file, \"w\") def __del__(self): \"\"\" Deinitializes the object and closes the ADIOS2 output stream. \"\"\" logger.info(\"Closing output stream\") self.output_stream.close() __del__() Deinitializes the object and closes the ADIOS2 output stream. Source code in src/output.py def __del__(self): \"\"\" Deinitializes the object and closes the ADIOS2 output stream. \"\"\" logger.info(\"Closing output stream\") self.output_stream.close() __init__(output_name, config_file) Initializes the object Parameters: Name Type Description Default output_name str The output folder name where data will be stored. required config_file str The path of the configuration file, which will be copyied to the output data folder. required Source code in src/output.py def __init__(self, output_name: str, config_file: str): \"\"\" Initializes the object Parameters: output_name (str): The output folder name where data will be stored. config_file (str): The path of the configuration file, which will be copyied to the output data folder. \"\"\" self.output_name = output_name self.config_file = os.path.join( self.output_name, os.path.basename(config_file)) # Create output dir if not os.path.exists(self.output_name): os.makedirs(self.output_name) # Copy config if not os.path.exists(self.config_file): shutil.copy2(config_file, self.config_file) # Find all .bp files and extract last checkpoint from file name file_list = map(os.path.splitext, os.listdir(self.output_name)) file_list = filter(lambda x: x[1] == \".bp\", file_list) file_list = list(file_list) # Recover data from previous checkpoint if len(file_list) != 0: self.last_checkpoint = int(file_list[-1][0]) logger.info( f\"Recovering data from checkpoint {self.last_checkpoint}\" ) prev_output_file = os.path.join( self.output_name, f\"{self.last_checkpoint}.bp\" ) with adios2.FileReader(prev_output_file) as s: attrs = s.available_attributes() vars = s.available_variables() steps = int(vars[\"weights\"][\"AvailableStepsCount\"]) self.first_iter = int(attrs[\"last_iter\"][\"Value\"]) self.weights = s.read(\"weights\", step_selection=[steps - 1, 1]) self.recovered = True else: self.last_checkpoint = -1 self.first_iter = None self.weights = None self.recovered = False self.output_file = os.path.join( self.output_name, f\"{self.last_checkpoint + 1}.bp\" ) # Create ADIOS2 stream self.output_stream = adios2.Stream(self.output_file, \"w\")","title":"output"},{"location":"module_output/#module-output","text":"Contains handlers for ouputting and recovering ADIOS2 training data.","title":"Module output"},{"location":"module_output/#output.Output","text":"Holds a stream-writtable ADIOS2 file and creates new output files with the the correct naming convention for checkpointing. Source code in src/output.py class Output: \"\"\" Holds a stream-writtable ADIOS2 file and creates new output files with the the correct naming convention for checkpointing. \"\"\" def __init__(self, output_name: str, config_file: str): \"\"\" Initializes the object Parameters: output_name (str): The output folder name where data will be stored. config_file (str): The path of the configuration file, which will be copyied to the output data folder. \"\"\" self.output_name = output_name self.config_file = os.path.join( self.output_name, os.path.basename(config_file)) # Create output dir if not os.path.exists(self.output_name): os.makedirs(self.output_name) # Copy config if not os.path.exists(self.config_file): shutil.copy2(config_file, self.config_file) # Find all .bp files and extract last checkpoint from file name file_list = map(os.path.splitext, os.listdir(self.output_name)) file_list = filter(lambda x: x[1] == \".bp\", file_list) file_list = list(file_list) # Recover data from previous checkpoint if len(file_list) != 0: self.last_checkpoint = int(file_list[-1][0]) logger.info( f\"Recovering data from checkpoint {self.last_checkpoint}\" ) prev_output_file = os.path.join( self.output_name, f\"{self.last_checkpoint}.bp\" ) with adios2.FileReader(prev_output_file) as s: attrs = s.available_attributes() vars = s.available_variables() steps = int(vars[\"weights\"][\"AvailableStepsCount\"]) self.first_iter = int(attrs[\"last_iter\"][\"Value\"]) self.weights = s.read(\"weights\", step_selection=[steps - 1, 1]) self.recovered = True else: self.last_checkpoint = -1 self.first_iter = None self.weights = None self.recovered = False self.output_file = os.path.join( self.output_name, f\"{self.last_checkpoint + 1}.bp\" ) # Create ADIOS2 stream self.output_stream = adios2.Stream(self.output_file, \"w\") def __del__(self): \"\"\" Deinitializes the object and closes the ADIOS2 output stream. \"\"\" logger.info(\"Closing output stream\") self.output_stream.close()","title":"Output"},{"location":"module_output/#output.Output.__del__","text":"Deinitializes the object and closes the ADIOS2 output stream. Source code in src/output.py def __del__(self): \"\"\" Deinitializes the object and closes the ADIOS2 output stream. \"\"\" logger.info(\"Closing output stream\") self.output_stream.close()","title":"__del__"},{"location":"module_output/#output.Output.__init__","text":"Initializes the object Parameters: Name Type Description Default output_name str The output folder name where data will be stored. required config_file str The path of the configuration file, which will be copyied to the output data folder. required Source code in src/output.py def __init__(self, output_name: str, config_file: str): \"\"\" Initializes the object Parameters: output_name (str): The output folder name where data will be stored. config_file (str): The path of the configuration file, which will be copyied to the output data folder. \"\"\" self.output_name = output_name self.config_file = os.path.join( self.output_name, os.path.basename(config_file)) # Create output dir if not os.path.exists(self.output_name): os.makedirs(self.output_name) # Copy config if not os.path.exists(self.config_file): shutil.copy2(config_file, self.config_file) # Find all .bp files and extract last checkpoint from file name file_list = map(os.path.splitext, os.listdir(self.output_name)) file_list = filter(lambda x: x[1] == \".bp\", file_list) file_list = list(file_list) # Recover data from previous checkpoint if len(file_list) != 0: self.last_checkpoint = int(file_list[-1][0]) logger.info( f\"Recovering data from checkpoint {self.last_checkpoint}\" ) prev_output_file = os.path.join( self.output_name, f\"{self.last_checkpoint}.bp\" ) with adios2.FileReader(prev_output_file) as s: attrs = s.available_attributes() vars = s.available_variables() steps = int(vars[\"weights\"][\"AvailableStepsCount\"]) self.first_iter = int(attrs[\"last_iter\"][\"Value\"]) self.weights = s.read(\"weights\", step_selection=[steps - 1, 1]) self.recovered = True else: self.last_checkpoint = -1 self.first_iter = None self.weights = None self.recovered = False self.output_file = os.path.join( self.output_name, f\"{self.last_checkpoint + 1}.bp\" ) # Create ADIOS2 stream self.output_stream = adios2.Stream(self.output_file, \"w\")","title":"__init__"},{"location":"module_problem/","text":"Module problem Generic problem solvable by training a quantum circuit. Problem Source code in src/problem.py class Problem(metaclass=abc.ABCMeta): def __init__(self): \"\"\" Initializes the problem object. Attributes: map (DomainMap): A domain map for the problem. target (array): List of taret values for the problem (the true solution of the problem). f (callable): A function that returns the true solution value when called for all points in `x`. \"\"\" self.map = None self.target = None self.f = None @abc.abstractmethod def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" pass @abc.abstractmethod def get_domain_map(self): \"\"\" Returns: (DomainMap): Returns the domain map of the problem. \"\"\" pass __init__() Initializes the problem object. Attributes: Name Type Description map DomainMap A domain map for the problem. target array List of taret values for the problem (the true solution of the problem). f callable A function that returns the true solution value when called for all points in x . Source code in src/problem.py def __init__(self): \"\"\" Initializes the problem object. Attributes: map (DomainMap): A domain map for the problem. target (array): List of taret values for the problem (the true solution of the problem). f (callable): A function that returns the true solution value when called for all points in `x`. \"\"\" self.map = None self.target = None self.f = None cost(node, weights, data, N) abstractmethod Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/problem.py @abc.abstractmethod def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" pass get_domain_map() abstractmethod Returns: (DomainMap): Returns the domain map of the problem. Source code in src/problem.py @abc.abstractmethod def get_domain_map(self): \"\"\" Returns: (DomainMap): Returns the domain map of the problem. \"\"\" pass","title":"problem"},{"location":"module_problem/#module-problem","text":"Generic problem solvable by training a quantum circuit.","title":"Module problem"},{"location":"module_problem/#problem.Problem","text":"Source code in src/problem.py class Problem(metaclass=abc.ABCMeta): def __init__(self): \"\"\" Initializes the problem object. Attributes: map (DomainMap): A domain map for the problem. target (array): List of taret values for the problem (the true solution of the problem). f (callable): A function that returns the true solution value when called for all points in `x`. \"\"\" self.map = None self.target = None self.f = None @abc.abstractmethod def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" pass @abc.abstractmethod def get_domain_map(self): \"\"\" Returns: (DomainMap): Returns the domain map of the problem. \"\"\" pass","title":"Problem"},{"location":"module_problem/#problem.Problem.__init__","text":"Initializes the problem object. Attributes: Name Type Description map DomainMap A domain map for the problem. target array List of taret values for the problem (the true solution of the problem). f callable A function that returns the true solution value when called for all points in x . Source code in src/problem.py def __init__(self): \"\"\" Initializes the problem object. Attributes: map (DomainMap): A domain map for the problem. target (array): List of taret values for the problem (the true solution of the problem). f (callable): A function that returns the true solution value when called for all points in `x`. \"\"\" self.map = None self.target = None self.f = None","title":"__init__"},{"location":"module_problem/#problem.Problem.cost","text":"Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/problem.py @abc.abstractmethod def cost(self, node, weights, data, N): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" pass","title":"cost"},{"location":"module_problem/#problem.Problem.get_domain_map","text":"Returns: (DomainMap): Returns the domain map of the problem. Source code in src/problem.py @abc.abstractmethod def get_domain_map(self): \"\"\" Returns: (DomainMap): Returns the domain map of the problem. \"\"\" pass","title":"get_domain_map"},{"location":"module_quantum_derivatives/","text":"Module quantum_derivatives Contains definitions for taking derivatives of quantum circuits that represent functions. d2f(node, weights, x) Takes the second derivative of a quantum circuit. Parameters: Name Type Description Default node QuantumNode The quantum node that will evaluate the circuit. required weights array A list of circuit weights. required x float The point where the derivative is to be computed. required Returns: Type Description flot The value of the second derivative of the function represented by the circuit in point x Source code in src/quantum_derivatives.py def d2f(node, weights, x): \"\"\" Takes the second derivative of a quantum circuit. Parameters: node (QuantumNode): The quantum node that will evaluate the circuit. weights (array): A list of circuit weights. x (float): The point where the derivative is to be computed. Returns: (flot): The value of the second derivative of the function represented by the circuit in point `x` \"\"\" f = node(weights, x=x) fp = node(weights, x=(x + np.pi)) fm = node(weights, x=(x - np.pi)) return (fm + fp - 2.0 * f) / 4.0 df(node, weights, x) Takes the first derivative of a quantum circuit. Parameters: Name Type Description Default node QuantumNode The quantum node that will evaluate the circuit. required weights array A list of circuit weights. required x float The point where the derivative is to be computed. required Returns: Type Description flot The value of the first derivative of the function represented by the circuit in point x Source code in src/quantum_derivatives.py def df(node, weights, x): \"\"\" Takes the first derivative of a quantum circuit. Parameters: node (QuantumNode): The quantum node that will evaluate the circuit. weights (array): A list of circuit weights. x (float): The point where the derivative is to be computed. Returns: (flot): The value of the first derivative of the function represented by the circuit in point `x` \"\"\" fp_2 = node(weights, x=(x + np.pi / 2.0)) fm_2 = node(weights, x=(x - np.pi / 2.0)) return (fp_2 + fm_2) / 2.0","title":"quantum_derivatives"},{"location":"module_quantum_derivatives/#module-quantum_derivatives","text":"Contains definitions for taking derivatives of quantum circuits that represent functions.","title":"Module quantum_derivatives"},{"location":"module_quantum_derivatives/#quantum_derivatives.d2f","text":"Takes the second derivative of a quantum circuit. Parameters: Name Type Description Default node QuantumNode The quantum node that will evaluate the circuit. required weights array A list of circuit weights. required x float The point where the derivative is to be computed. required Returns: Type Description flot The value of the second derivative of the function represented by the circuit in point x Source code in src/quantum_derivatives.py def d2f(node, weights, x): \"\"\" Takes the second derivative of a quantum circuit. Parameters: node (QuantumNode): The quantum node that will evaluate the circuit. weights (array): A list of circuit weights. x (float): The point where the derivative is to be computed. Returns: (flot): The value of the second derivative of the function represented by the circuit in point `x` \"\"\" f = node(weights, x=x) fp = node(weights, x=(x + np.pi)) fm = node(weights, x=(x - np.pi)) return (fm + fp - 2.0 * f) / 4.0","title":"d2f"},{"location":"module_quantum_derivatives/#quantum_derivatives.df","text":"Takes the first derivative of a quantum circuit. Parameters: Name Type Description Default node QuantumNode The quantum node that will evaluate the circuit. required weights array A list of circuit weights. required x float The point where the derivative is to be computed. required Returns: Type Description flot The value of the first derivative of the function represented by the circuit in point x Source code in src/quantum_derivatives.py def df(node, weights, x): \"\"\" Takes the first derivative of a quantum circuit. Parameters: node (QuantumNode): The quantum node that will evaluate the circuit. weights (array): A list of circuit weights. x (float): The point where the derivative is to be computed. Returns: (flot): The value of the first derivative of the function represented by the circuit in point `x` \"\"\" fp_2 = node(weights, x=(x + np.pi / 2.0)) fm_2 = node(weights, x=(x - np.pi / 2.0)) return (fp_2 + fm_2) / 2.0","title":"df"},{"location":"parameter_files/","text":"Parameter file description The operations of qcnn.py are controlled via YAML parameter files. Examples of such files can be found in the parfiles folder of QCNN-Metrics . In this page, you will find a complete description of all available parameters. Additionally, the qcnn.json file inside the parfiles folder provides a schema file that can be used in text editors for adding in their writing. In VSCode , for instance, they can be used with Red Hat's YAML Language server plugin. computer options These options describe the simulated quantum computer that shall be used. num_qubits : The number of qubits to use in the computer. Must be an integer larger or equal to 1. circuit options These options describe the types of quantum circuits that can be trained and their respective options. ansatz : The type of ansatz circuit to use. Can be one of the following: \"sel\" : A StronglyEntanglingLayer circuit. \"conv\" : A convolutional circuit without pooling layers. These circuits act on pairs of quibits and \"wrap around\", that is, the last qubit in the computer is paired with the first. num_layers : This parameter is only required if ansatz is \"sel\" . It configures the number of entangling layers to use. conv_layer : The name of the convolutional layer to use. The name of the layer must be one of the classes in the conv_layers.py file. This string is interpreted directly in the code. dataset options These options control the input dataset. dataset_size : The number of points in the discrete domain. batch_size : The size of training batches. A batch is a subset of the original input data that can be used for training instead of the whole data set. If set to 0, batching is disabled. training options These options control the optimizer algorithm used for training the circuit. optimizer : The underlying optimizer library to use. Can be one of the following. \"numpy\" : Uses the bundled Pennylane Numpy Adam optimizer. \"torch\" : Uses the adaptive L-BGFS optimizer from the PyTorch library. use_cuda : Uses CUDA tensors for training. This is only available if optimizer is \"torch\" . max_iters : The maximum number of optimizer steps to take. abstol : The value of the error function below which the optimizer will stop iterating. step_size : The initial step size of the optimizer. domain options The 1D domain where functions will be fitted or solved. x0 : Left boundary of the domain. xf : Right boundary of the domain. problem options These options control the problem type to solve and problem specific parameters. type : The type of problem to solve. Must be one of the following: \"fit\" : Fit a target function. \"hagen-poiseuille\" : Solve the tubular Hagen-Poiseuille equation. \"plane-hagen-poiseuille\" : Solve the Hagen-Poiseuille equation between two infinite planes. output options These options control the data output of the training. folder_name : The name of the folder where to save the training and plot data.","title":"Parameter Files"},{"location":"parameter_files/#parameter-file-description","text":"The operations of qcnn.py are controlled via YAML parameter files. Examples of such files can be found in the parfiles folder of QCNN-Metrics . In this page, you will find a complete description of all available parameters. Additionally, the qcnn.json file inside the parfiles folder provides a schema file that can be used in text editors for adding in their writing. In VSCode , for instance, they can be used with Red Hat's YAML Language server plugin.","title":"Parameter file description"},{"location":"parameter_files/#computer-options","text":"These options describe the simulated quantum computer that shall be used. num_qubits : The number of qubits to use in the computer. Must be an integer larger or equal to 1.","title":"computer options"},{"location":"parameter_files/#circuit-options","text":"These options describe the types of quantum circuits that can be trained and their respective options. ansatz : The type of ansatz circuit to use. Can be one of the following: \"sel\" : A StronglyEntanglingLayer circuit. \"conv\" : A convolutional circuit without pooling layers. These circuits act on pairs of quibits and \"wrap around\", that is, the last qubit in the computer is paired with the first. num_layers : This parameter is only required if ansatz is \"sel\" . It configures the number of entangling layers to use. conv_layer : The name of the convolutional layer to use. The name of the layer must be one of the classes in the conv_layers.py file. This string is interpreted directly in the code.","title":"circuit options"},{"location":"parameter_files/#dataset-options","text":"These options control the input dataset. dataset_size : The number of points in the discrete domain. batch_size : The size of training batches. A batch is a subset of the original input data that can be used for training instead of the whole data set. If set to 0, batching is disabled.","title":"dataset options"},{"location":"parameter_files/#training-options","text":"These options control the optimizer algorithm used for training the circuit. optimizer : The underlying optimizer library to use. Can be one of the following. \"numpy\" : Uses the bundled Pennylane Numpy Adam optimizer. \"torch\" : Uses the adaptive L-BGFS optimizer from the PyTorch library. use_cuda : Uses CUDA tensors for training. This is only available if optimizer is \"torch\" . max_iters : The maximum number of optimizer steps to take. abstol : The value of the error function below which the optimizer will stop iterating. step_size : The initial step size of the optimizer.","title":"training options"},{"location":"parameter_files/#domain-options","text":"The 1D domain where functions will be fitted or solved. x0 : Left boundary of the domain. xf : Right boundary of the domain.","title":"domain options"},{"location":"parameter_files/#problem-options","text":"These options control the problem type to solve and problem specific parameters. type : The type of problem to solve. Must be one of the following: \"fit\" : Fit a target function. \"hagen-poiseuille\" : Solve the tubular Hagen-Poiseuille equation. \"plane-hagen-poiseuille\" : Solve the Hagen-Poiseuille equation between two infinite planes.","title":"problem options"},{"location":"parameter_files/#output-options","text":"These options control the data output of the training. folder_name : The name of the folder where to save the training and plot data.","title":"output options"}]}