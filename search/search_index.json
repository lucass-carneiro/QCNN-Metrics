{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to QCNN-Metrics This is a python package for training quantum convolutional neural networks. It uses Pennylane for building quantum circuits and can be trained with Numpy or Torch backends on CPUs or GPUs. The code also supports checkpoints, recovery and streaming IO via the ADIOS2 library. This program trains quantum circuits to solve the following problems: 1D Function fitting ODE solving","title":"Home"},{"location":"#welcome-to-qcnn-metrics","text":"This is a python package for training quantum convolutional neural networks. It uses Pennylane for building quantum circuits and can be trained with Numpy or Torch backends on CPUs or GPUs. The code also supports checkpoints, recovery and streaming IO via the ADIOS2 library. This program trains quantum circuits to solve the following problems: 1D Function fitting ODE solving","title":"Welcome to QCNN-Metrics"},{"location":"getting_started/","text":"Introduction The main interaction point of this package is the qcnn.py script, provided in the src folder of this repository. This script takes a single argument, a configuration file, that completely drives the behavior of the program. The next few sections will teach you to use its usage. Installing dependencies In order to use the qcnn.py script, dependencies need to be installed. The recommended way to install the required dependencies is by creating a virtual environment and using pip to install dependencies to that virtual environment. All the package's dependencies are specified in the requirements.txt file within the repository. To create a suitable virtual environment, issue the following commands from within the QCNN-Metrics repository folder: python -m venv venv source venv/bin/activate pip install --upgrade pip pip install --upgrade -r requirements.txt # Issue python commands using the libraries installed in the virtual environment deactivate # When done with using the environment Note that the virtual environment does not necessarily need to be named venv or located inside the QCNN-Metrics folder. Just be sure to point to the correct location of the requirements.txt file when creating the environment and to activate the correct environment prior to interacting with the code. Usage Activate the virtual environment with the dependencies installed and call the qcnn.py script. Issue the deactivate command when done. To activate the environment, issue source venv/bin/activate Where venv is the virtual environment folder where dependencies where installed. Next, to see the available options issue pyhton src/qcnn.py --help When all operations are done exit out of the virtual environment with deactivate Parameter files The operations of qcnn.py are controlled via TOML parameter files. Examples of such files can be found in the parfiles folder of QCNN-Metrics . Bellow is a description of each tunable parameter Key Description Possible Values computer/num_qubits The number of quibits to use in the circuit Positive integers circuit/ansatz The type of convolutional ansatz to use \"conv\" for convolutional circuits or \"sel\" for strongly entangling layers. circuit/num_layers The number of convolutional layers. Only used if circuit/ansatz = \"sel\" Positive integers circuit/conv_layer The type of convolutional layer to use. Only used if circuit/ansatz = \"conv\" See src/conv_layers.py for possible convolutional layers dataset/dataset_size The number of points in the training dataset. Positive integers dataset/batch_size The size of the training batch. If zero, batching is disabled. Integers training/optimizer The provider of the optimization algorithms. \"numpy\" for Numpy or \"torch\" for Torch training/max_iters The maximmun number of training steps to take before exiting. Integers training/abstol This parameter governs the value of the loss function below which the training stops. Positive reals training/stepsize The initial optimization step size Positive real. domain/x0 The leftmost point in the domain Real domain/xf The rightmost point in the domain Real problem/problem_type The type of problem to solve with the QCNN \"fit\" , \"hagen-poiseuille\" output/folder_name Absolute path of the output folder of the training data String Running on clusters When running in an HPC cluster, users often don't have access to administrative rights. This can cause issues if the system-wide version of python is too old or if the cluster does not have pip enabled. To avoid such problems, QCNN-Metrics provides a recipe for building a Singularity image in the sing folder, together with a Slurm script and a bash script that takes care of job submission and virtual environment activation on a cluster. Note that the cluster must have Singularity installed for this to work. Building the image In a machine where you have root access (this is mandatory), from inside the QCNN-Metrics folder issue sudo singularity build qcnn.simg singularity/qcnn.recipe After the image is built, copy it over to the cluster where you will be running the code. Submitting the job TODO: This section needs more detail sbatch --job-name=fit_0 job.slurm /home/lucas.t/qcnn.simg /home/lucas.t/fit.toml /home/lucas.t/QCNN-Metrics","title":"Getting started"},{"location":"getting_started/#introduction","text":"The main interaction point of this package is the qcnn.py script, provided in the src folder of this repository. This script takes a single argument, a configuration file, that completely drives the behavior of the program. The next few sections will teach you to use its usage.","title":"Introduction"},{"location":"getting_started/#installing-dependencies","text":"In order to use the qcnn.py script, dependencies need to be installed. The recommended way to install the required dependencies is by creating a virtual environment and using pip to install dependencies to that virtual environment. All the package's dependencies are specified in the requirements.txt file within the repository. To create a suitable virtual environment, issue the following commands from within the QCNN-Metrics repository folder: python -m venv venv source venv/bin/activate pip install --upgrade pip pip install --upgrade -r requirements.txt # Issue python commands using the libraries installed in the virtual environment deactivate # When done with using the environment Note that the virtual environment does not necessarily need to be named venv or located inside the QCNN-Metrics folder. Just be sure to point to the correct location of the requirements.txt file when creating the environment and to activate the correct environment prior to interacting with the code.","title":"Installing dependencies"},{"location":"getting_started/#usage","text":"Activate the virtual environment with the dependencies installed and call the qcnn.py script. Issue the deactivate command when done. To activate the environment, issue source venv/bin/activate Where venv is the virtual environment folder where dependencies where installed. Next, to see the available options issue pyhton src/qcnn.py --help When all operations are done exit out of the virtual environment with deactivate","title":"Usage"},{"location":"getting_started/#parameter-files","text":"The operations of qcnn.py are controlled via TOML parameter files. Examples of such files can be found in the parfiles folder of QCNN-Metrics . Bellow is a description of each tunable parameter Key Description Possible Values computer/num_qubits The number of quibits to use in the circuit Positive integers circuit/ansatz The type of convolutional ansatz to use \"conv\" for convolutional circuits or \"sel\" for strongly entangling layers. circuit/num_layers The number of convolutional layers. Only used if circuit/ansatz = \"sel\" Positive integers circuit/conv_layer The type of convolutional layer to use. Only used if circuit/ansatz = \"conv\" See src/conv_layers.py for possible convolutional layers dataset/dataset_size The number of points in the training dataset. Positive integers dataset/batch_size The size of the training batch. If zero, batching is disabled. Integers training/optimizer The provider of the optimization algorithms. \"numpy\" for Numpy or \"torch\" for Torch training/max_iters The maximmun number of training steps to take before exiting. Integers training/abstol This parameter governs the value of the loss function below which the training stops. Positive reals training/stepsize The initial optimization step size Positive real. domain/x0 The leftmost point in the domain Real domain/xf The rightmost point in the domain Real problem/problem_type The type of problem to solve with the QCNN \"fit\" , \"hagen-poiseuille\" output/folder_name Absolute path of the output folder of the training data String","title":"Parameter files"},{"location":"getting_started/#running-on-clusters","text":"When running in an HPC cluster, users often don't have access to administrative rights. This can cause issues if the system-wide version of python is too old or if the cluster does not have pip enabled. To avoid such problems, QCNN-Metrics provides a recipe for building a Singularity image in the sing folder, together with a Slurm script and a bash script that takes care of job submission and virtual environment activation on a cluster. Note that the cluster must have Singularity installed for this to work.","title":"Running on clusters"},{"location":"getting_started/#building-the-image","text":"In a machine where you have root access (this is mandatory), from inside the QCNN-Metrics folder issue sudo singularity build qcnn.simg singularity/qcnn.recipe After the image is built, copy it over to the cluster where you will be running the code.","title":"Building the image"},{"location":"getting_started/#submitting-the-job","text":"TODO: This section needs more detail sbatch --job-name=fit_0 job.slurm /home/lucas.t/qcnn.simg /home/lucas.t/fit.toml /home/lucas.t/QCNN-Metrics","title":"Submitting the job"},{"location":"module_ansatz/","text":"Module ansatz This module defines an abstract anstz circuit. An ansatz circuit is the combination of training and encoding blocks as defined here Ansatz Abstract class defining an ansatz quantum circuit that combines encoding and training blocks. See here for details Source code in src/ansatz.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Ansatz ( metaclass = abc . ABCMeta ): \"\"\" Abstract class defining an `ansatz` quantum circuit that combines encoding and training blocks. See [here](https://arxiv.org/abs/2008.08605) for details \"\"\" @abc . abstractmethod def S ( self , x ): \"\"\" The enconder block for the ansatz circuit. Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" pass @abc . abstractmethod def W ( self , theta ): \"\"\" The trainable block for the ansatz circuit. Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" pass @abc . abstractmethod def ansatz ( self , w , x ): \"\"\" The ansatz circuit containing enconding and trainable blocks. Parameters: w (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" pass S ( x ) abstractmethod The enconder block for the ansatz circuit. Parameters: Name Type Description Default x array An array-like object containing the datapoints to encode. required Source code in src/ansatz.py 17 18 19 20 21 22 23 24 25 @abc . abstractmethod def S ( self , x ): \"\"\" The enconder block for the ansatz circuit. Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" pass W ( theta ) abstractmethod The trainable block for the ansatz circuit. Parameters: Name Type Description Default theta array An array-like object containing the list of trainable parameters. required Source code in src/ansatz.py 27 28 29 30 31 32 33 34 35 @abc . abstractmethod def W ( self , theta ): \"\"\" The trainable block for the ansatz circuit. Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" pass ansatz ( w , x ) abstractmethod The ansatz circuit containing enconding and trainable blocks. Parameters: Name Type Description Default w array An object containing the list of trainable parameters. required x array An object containing the list of datapoints to encode. required Returns: Type Description ExpectationMP The expected value of the quantum circuit Source code in src/ansatz.py 37 38 39 40 41 42 43 44 45 46 47 48 49 @abc . abstractmethod def ansatz ( self , w , x ): \"\"\" The ansatz circuit containing enconding and trainable blocks. Parameters: w (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" pass","title":"ansatz"},{"location":"module_ansatz/#module-ansatz","text":"This module defines an abstract anstz circuit. An ansatz circuit is the combination of training and encoding blocks as defined here","title":"Module ansatz"},{"location":"module_ansatz/#ansatz.Ansatz","text":"Abstract class defining an ansatz quantum circuit that combines encoding and training blocks. See here for details Source code in src/ansatz.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Ansatz ( metaclass = abc . ABCMeta ): \"\"\" Abstract class defining an `ansatz` quantum circuit that combines encoding and training blocks. See [here](https://arxiv.org/abs/2008.08605) for details \"\"\" @abc . abstractmethod def S ( self , x ): \"\"\" The enconder block for the ansatz circuit. Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" pass @abc . abstractmethod def W ( self , theta ): \"\"\" The trainable block for the ansatz circuit. Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" pass @abc . abstractmethod def ansatz ( self , w , x ): \"\"\" The ansatz circuit containing enconding and trainable blocks. Parameters: w (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" pass","title":"Ansatz"},{"location":"module_ansatz/#ansatz.Ansatz.S","text":"The enconder block for the ansatz circuit. Parameters: Name Type Description Default x array An array-like object containing the datapoints to encode. required Source code in src/ansatz.py 17 18 19 20 21 22 23 24 25 @abc . abstractmethod def S ( self , x ): \"\"\" The enconder block for the ansatz circuit. Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" pass","title":"S"},{"location":"module_ansatz/#ansatz.Ansatz.W","text":"The trainable block for the ansatz circuit. Parameters: Name Type Description Default theta array An array-like object containing the list of trainable parameters. required Source code in src/ansatz.py 27 28 29 30 31 32 33 34 35 @abc . abstractmethod def W ( self , theta ): \"\"\" The trainable block for the ansatz circuit. Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" pass","title":"W"},{"location":"module_ansatz/#ansatz.Ansatz.ansatz","text":"The ansatz circuit containing enconding and trainable blocks. Parameters: Name Type Description Default w array An object containing the list of trainable parameters. required x array An object containing the list of datapoints to encode. required Returns: Type Description ExpectationMP The expected value of the quantum circuit Source code in src/ansatz.py 37 38 39 40 41 42 43 44 45 46 47 48 49 @abc . abstractmethod def ansatz ( self , w , x ): \"\"\" The ansatz circuit containing enconding and trainable blocks. Parameters: w (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" pass","title":"ansatz"},{"location":"module_ansatzes/","text":"Module ansatzes This module defines the actual ansatzes supported in the code. All ansatzes are specializations of the ansatz.Ansatz abstract base class. AnsatzConv Bases: Ansatz This anstaz uses Pauli X rotations as encoding and convolutional layers from the conv_layer module as trainable blocks Source code in src/ansatzes.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 class AnsatzConv ( ansatz . Ansatz ): \"\"\" This anstaz uses Pauli X rotations as encoding and convolutional layers from the `conv_layer` module as trainable blocks \"\"\" def __init__ ( self , num_qubits : int , conv_layer , random_generator ): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. conv_layer (any): The convolutional layer to use in the circuit. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self . num_qubits = num_qubits self . conv_layer = conv_layer self . param_shape = ( 2 , num_qubits , conv_layer . ppb ) self . weights = 2 * np . pi * \\ random_generator . random ( size = self . param_shape ) def S ( self , x ): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x: An array-like object containing the datapoints to encode. \"\"\" for w in range ( self . num_qubits ): qml . RX ( x , wires = w ) def conv_block ( self , p ): \"\"\" Constructs the trainable part of the circuit. Each convolutional layer is applied to a pair of quibits. As a \"boundary condition\", the last quibit pairs with the first. \"\"\" qml . Barrier ( wires = range ( self . num_qubits )) for i in range ( self . num_qubits ): self . conv_layer . layer ( p [ i ], [ i , ( i + 1 ) % self . num_qubits ]) qml . Barrier ( wires = range ( self . num_qubits )) def W ( self , theta ): \"\"\" The trainable block for the ansatz circuit, using convolutional layers Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" self . conv_block ( theta ) def ansatz ( self , weights , x = None ): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self . W ( weights [ 0 ]) self . S ( x ) self . W ( weights [ 1 ]) return qml . expval ( qml . PauliZ ( wires = 0 )) S ( x ) The enconder block for the ansatz circuit, using Pauli X rotations x: An array-like object containing the datapoints to encode. Source code in src/ansatzes.py 93 94 95 96 97 98 99 100 101 102 def S ( self , x ): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x: An array-like object containing the datapoints to encode. \"\"\" for w in range ( self . num_qubits ): qml . RX ( x , wires = w ) W ( theta ) The trainable block for the ansatz circuit, using convolutional layers Parameters: Name Type Description Default theta array An array-like object containing the list of trainable parameters. required Source code in src/ansatzes.py 115 116 117 118 119 120 121 122 def W ( self , theta ): \"\"\" The trainable block for the ansatz circuit, using convolutional layers Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" self . conv_block ( theta ) __init__ ( num_qubits , conv_layer , random_generator ) Initialize the object Parameters: Name Type Description Default num_qubits int The number of qubits to use in the quantum circuit. required conv_layer any The convolutional layer to use in the circuit. required random_generator Generator A random number generator to use for trainable parameter initialization. required Source code in src/ansatzes.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def __init__ ( self , num_qubits : int , conv_layer , random_generator ): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. conv_layer (any): The convolutional layer to use in the circuit. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self . num_qubits = num_qubits self . conv_layer = conv_layer self . param_shape = ( 2 , num_qubits , conv_layer . ppb ) self . weights = 2 * np . pi * \\ random_generator . random ( size = self . param_shape ) ansatz ( weights , x = None ) The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: Name Type Description Default weights array An object containing the list of trainable parameters. required x array An object containing the list of datapoints to encode. None Returns: Type Description ExpectationMP The expected value of the quantum circuit Source code in src/ansatzes.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def ansatz ( self , weights , x = None ): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self . W ( weights [ 0 ]) self . S ( x ) self . W ( weights [ 1 ]) return qml . expval ( qml . PauliZ ( wires = 0 )) conv_block ( p ) Constructs the trainable part of the circuit. Each convolutional layer is applied to a pair of quibits. As a \"boundary condition\", the last quibit pairs with the first. Source code in src/ansatzes.py 104 105 106 107 108 109 110 111 112 113 def conv_block ( self , p ): \"\"\" Constructs the trainable part of the circuit. Each convolutional layer is applied to a pair of quibits. As a \"boundary condition\", the last quibit pairs with the first. \"\"\" qml . Barrier ( wires = range ( self . num_qubits )) for i in range ( self . num_qubits ): self . conv_layer . layer ( p [ i ], [ i , ( i + 1 ) % self . num_qubits ]) qml . Barrier ( wires = range ( self . num_qubits )) AnsatzSEL Bases: Ansatz This anstaz uses Pauli X rotations as encoding and strongly entangling layers as trainable blocks Source code in src/ansatzes.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class AnsatzSEL ( ansatz . Ansatz ): \"\"\" This anstaz uses Pauli X rotations as encoding and [strongly entangling layers](https://docs.pennylane.ai/en/stable/code/api/pennylane.StronglyEntanglingLayers.html) as trainable blocks \"\"\" def __init__ ( self , num_qubits : int , num_layers : int , random_generator ): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. num_layers (int): The number of layers to use. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self . num_qubits = num_qubits self . num_layers = num_layers self . param_shape = ( 2 , num_layers , num_qubits , 3 ) self . weights = 2 * np . pi * \\ random_generator . random ( size = self . param_shape ) def S ( self , x ): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" for w in range ( self . num_qubits ): qml . RX ( x , wires = w ) def W ( self , theta ): \"\"\" The trainable block for the ansatz circuit, using `StronglyEntanglingLayers` Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" StronglyEntanglingLayers ( theta , wires = range ( self . num_qubits )) def ansatz ( self , weights , x = None ): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self . W ( weights [ 0 ]) self . S ( x ) self . W ( weights [ 1 ]) return qml . expval ( qml . PauliZ ( wires = 0 )) S ( x ) The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x (array): An array-like object containing the datapoints to encode. Source code in src/ansatzes.py 35 36 37 38 39 40 41 42 43 def S ( self , x ): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" for w in range ( self . num_qubits ): qml . RX ( x , wires = w ) W ( theta ) The trainable block for the ansatz circuit, using StronglyEntanglingLayers Parameters: Name Type Description Default theta array An array-like object containing the list of trainable parameters. required Source code in src/ansatzes.py 45 46 47 48 49 50 51 52 def W ( self , theta ): \"\"\" The trainable block for the ansatz circuit, using `StronglyEntanglingLayers` Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" StronglyEntanglingLayers ( theta , wires = range ( self . num_qubits )) __init__ ( num_qubits , num_layers , random_generator ) Initialize the object Parameters: Name Type Description Default num_qubits int The number of qubits to use in the quantum circuit. required num_layers int The number of layers to use. required random_generator Generator A random number generator to use for trainable parameter initialization. required Source code in src/ansatzes.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def __init__ ( self , num_qubits : int , num_layers : int , random_generator ): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. num_layers (int): The number of layers to use. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self . num_qubits = num_qubits self . num_layers = num_layers self . param_shape = ( 2 , num_layers , num_qubits , 3 ) self . weights = 2 * np . pi * \\ random_generator . random ( size = self . param_shape ) ansatz ( weights , x = None ) The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: Name Type Description Default weights array An object containing the list of trainable parameters. required x array An object containing the list of datapoints to encode. None Returns: Type Description ExpectationMP The expected value of the quantum circuit Source code in src/ansatzes.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def ansatz ( self , weights , x = None ): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self . W ( weights [ 0 ]) self . S ( x ) self . W ( weights [ 1 ]) return qml . expval ( qml . PauliZ ( wires = 0 ))","title":"ansatzes"},{"location":"module_ansatzes/#module-ansatzes","text":"This module defines the actual ansatzes supported in the code. All ansatzes are specializations of the ansatz.Ansatz abstract base class.","title":"Module ansatzes"},{"location":"module_ansatzes/#ansatzes.AnsatzConv","text":"Bases: Ansatz This anstaz uses Pauli X rotations as encoding and convolutional layers from the conv_layer module as trainable blocks Source code in src/ansatzes.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 class AnsatzConv ( ansatz . Ansatz ): \"\"\" This anstaz uses Pauli X rotations as encoding and convolutional layers from the `conv_layer` module as trainable blocks \"\"\" def __init__ ( self , num_qubits : int , conv_layer , random_generator ): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. conv_layer (any): The convolutional layer to use in the circuit. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self . num_qubits = num_qubits self . conv_layer = conv_layer self . param_shape = ( 2 , num_qubits , conv_layer . ppb ) self . weights = 2 * np . pi * \\ random_generator . random ( size = self . param_shape ) def S ( self , x ): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x: An array-like object containing the datapoints to encode. \"\"\" for w in range ( self . num_qubits ): qml . RX ( x , wires = w ) def conv_block ( self , p ): \"\"\" Constructs the trainable part of the circuit. Each convolutional layer is applied to a pair of quibits. As a \"boundary condition\", the last quibit pairs with the first. \"\"\" qml . Barrier ( wires = range ( self . num_qubits )) for i in range ( self . num_qubits ): self . conv_layer . layer ( p [ i ], [ i , ( i + 1 ) % self . num_qubits ]) qml . Barrier ( wires = range ( self . num_qubits )) def W ( self , theta ): \"\"\" The trainable block for the ansatz circuit, using convolutional layers Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" self . conv_block ( theta ) def ansatz ( self , weights , x = None ): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self . W ( weights [ 0 ]) self . S ( x ) self . W ( weights [ 1 ]) return qml . expval ( qml . PauliZ ( wires = 0 ))","title":"AnsatzConv"},{"location":"module_ansatzes/#ansatzes.AnsatzConv.S","text":"The enconder block for the ansatz circuit, using Pauli X rotations x: An array-like object containing the datapoints to encode. Source code in src/ansatzes.py 93 94 95 96 97 98 99 100 101 102 def S ( self , x ): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x: An array-like object containing the datapoints to encode. \"\"\" for w in range ( self . num_qubits ): qml . RX ( x , wires = w )","title":"S"},{"location":"module_ansatzes/#ansatzes.AnsatzConv.W","text":"The trainable block for the ansatz circuit, using convolutional layers Parameters: Name Type Description Default theta array An array-like object containing the list of trainable parameters. required Source code in src/ansatzes.py 115 116 117 118 119 120 121 122 def W ( self , theta ): \"\"\" The trainable block for the ansatz circuit, using convolutional layers Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" self . conv_block ( theta )","title":"W"},{"location":"module_ansatzes/#ansatzes.AnsatzConv.__init__","text":"Initialize the object Parameters: Name Type Description Default num_qubits int The number of qubits to use in the quantum circuit. required conv_layer any The convolutional layer to use in the circuit. required random_generator Generator A random number generator to use for trainable parameter initialization. required Source code in src/ansatzes.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def __init__ ( self , num_qubits : int , conv_layer , random_generator ): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. conv_layer (any): The convolutional layer to use in the circuit. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self . num_qubits = num_qubits self . conv_layer = conv_layer self . param_shape = ( 2 , num_qubits , conv_layer . ppb ) self . weights = 2 * np . pi * \\ random_generator . random ( size = self . param_shape )","title":"__init__"},{"location":"module_ansatzes/#ansatzes.AnsatzConv.ansatz","text":"The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: Name Type Description Default weights array An object containing the list of trainable parameters. required x array An object containing the list of datapoints to encode. None Returns: Type Description ExpectationMP The expected value of the quantum circuit Source code in src/ansatzes.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def ansatz ( self , weights , x = None ): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self . W ( weights [ 0 ]) self . S ( x ) self . W ( weights [ 1 ]) return qml . expval ( qml . PauliZ ( wires = 0 ))","title":"ansatz"},{"location":"module_ansatzes/#ansatzes.AnsatzConv.conv_block","text":"Constructs the trainable part of the circuit. Each convolutional layer is applied to a pair of quibits. As a \"boundary condition\", the last quibit pairs with the first. Source code in src/ansatzes.py 104 105 106 107 108 109 110 111 112 113 def conv_block ( self , p ): \"\"\" Constructs the trainable part of the circuit. Each convolutional layer is applied to a pair of quibits. As a \"boundary condition\", the last quibit pairs with the first. \"\"\" qml . Barrier ( wires = range ( self . num_qubits )) for i in range ( self . num_qubits ): self . conv_layer . layer ( p [ i ], [ i , ( i + 1 ) % self . num_qubits ]) qml . Barrier ( wires = range ( self . num_qubits ))","title":"conv_block"},{"location":"module_ansatzes/#ansatzes.AnsatzSEL","text":"Bases: Ansatz This anstaz uses Pauli X rotations as encoding and strongly entangling layers as trainable blocks Source code in src/ansatzes.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class AnsatzSEL ( ansatz . Ansatz ): \"\"\" This anstaz uses Pauli X rotations as encoding and [strongly entangling layers](https://docs.pennylane.ai/en/stable/code/api/pennylane.StronglyEntanglingLayers.html) as trainable blocks \"\"\" def __init__ ( self , num_qubits : int , num_layers : int , random_generator ): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. num_layers (int): The number of layers to use. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self . num_qubits = num_qubits self . num_layers = num_layers self . param_shape = ( 2 , num_layers , num_qubits , 3 ) self . weights = 2 * np . pi * \\ random_generator . random ( size = self . param_shape ) def S ( self , x ): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" for w in range ( self . num_qubits ): qml . RX ( x , wires = w ) def W ( self , theta ): \"\"\" The trainable block for the ansatz circuit, using `StronglyEntanglingLayers` Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" StronglyEntanglingLayers ( theta , wires = range ( self . num_qubits )) def ansatz ( self , weights , x = None ): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self . W ( weights [ 0 ]) self . S ( x ) self . W ( weights [ 1 ]) return qml . expval ( qml . PauliZ ( wires = 0 ))","title":"AnsatzSEL"},{"location":"module_ansatzes/#ansatzes.AnsatzSEL.S","text":"The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x (array): An array-like object containing the datapoints to encode. Source code in src/ansatzes.py 35 36 37 38 39 40 41 42 43 def S ( self , x ): \"\"\" The enconder block for the ansatz circuit, using Pauli X rotations Parameters: x (array): An array-like object containing the datapoints to encode. \"\"\" for w in range ( self . num_qubits ): qml . RX ( x , wires = w )","title":"S"},{"location":"module_ansatzes/#ansatzes.AnsatzSEL.W","text":"The trainable block for the ansatz circuit, using StronglyEntanglingLayers Parameters: Name Type Description Default theta array An array-like object containing the list of trainable parameters. required Source code in src/ansatzes.py 45 46 47 48 49 50 51 52 def W ( self , theta ): \"\"\" The trainable block for the ansatz circuit, using `StronglyEntanglingLayers` Parameters: theta (array): An array-like object containing the list of trainable parameters. \"\"\" StronglyEntanglingLayers ( theta , wires = range ( self . num_qubits ))","title":"W"},{"location":"module_ansatzes/#ansatzes.AnsatzSEL.__init__","text":"Initialize the object Parameters: Name Type Description Default num_qubits int The number of qubits to use in the quantum circuit. required num_layers int The number of layers to use. required random_generator Generator A random number generator to use for trainable parameter initialization. required Source code in src/ansatzes.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def __init__ ( self , num_qubits : int , num_layers : int , random_generator ): \"\"\" Initialize the object Parameters: num_qubits (int): The number of qubits to use in the quantum circuit. num_layers (int): The number of layers to use. random_generator (numpy.random.Generator): A random number generator to use for trainable parameter initialization. \"\"\" self . num_qubits = num_qubits self . num_layers = num_layers self . param_shape = ( 2 , num_layers , num_qubits , 3 ) self . weights = 2 * np . pi * \\ random_generator . random ( size = self . param_shape )","title":"__init__"},{"location":"module_ansatzes/#ansatzes.AnsatzSEL.ansatz","text":"The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: Name Type Description Default weights array An object containing the list of trainable parameters. required x array An object containing the list of datapoints to encode. None Returns: Type Description ExpectationMP The expected value of the quantum circuit Source code in src/ansatzes.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def ansatz ( self , weights , x = None ): \"\"\" The ansatz circuit containing enconding and trainable blocks. The circuit computs the expected value of the Pauli sigma z operator Parameters: weights (array): An object containing the list of trainable parameters. x (array): An object containing the list of datapoints to encode. Returns: (pennylane.ExpectationMP): The expected value of the quantum circuit \"\"\" self . W ( weights [ 0 ]) self . S ( x ) self . W ( weights [ 1 ]) return qml . expval ( qml . PauliZ ( wires = 0 ))","title":"ansatz"},{"location":"module_config/","text":"Module config Contains definitions relating to the configuration of how and what types of training will be performed ConfigData Read and process configurations from the config.toml file. These files are used to drive the training, selecting which type of training to do and how to do it. Source code in src/config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class ConfigData : \"\"\" Read and process configurations from the `config.toml` file. These files are used to drive the training, selecting which type of training to do and how to do it. \"\"\" def __init__ ( self , config_file_path : str ): \"\"\" Initialize the object. Parameters: config_file_path (str): String with the path to a TOML configuration file. Attributes: config_file (dict[str, Any]): The loaded TOML configuration file as a dictionary of options. num_qubits (int): The total number of qubits to use for training. ansatz (str): The type of ansatz to use. conv_layer (str): The name of the convolutional layer to use. Ignored if `ansatz != \"conv\"`. num_layers (int): The number of entangling layers to use. Ignored if `ansatz != \"sel\"`. dataset_size (int): The number of datapoints to use during training. batch_size (int): The number of subsamples to use during batching. If set to `0`, no batching is used. optimizer (str): The training library to use for optimization. max_iters (int): The maximum number of steps the optimizer is allowed to take. abstol (float): The error function value bellow which training stops. setp_size (float): Initial step size for the optimizing algorithm. x0 (float): Left domain boundary. xf (float): Right domain boundary. problem_type (str): The type of problem to solve. output_folder_name (str): The folder where training output will be generated. hp_params: (HagenPoiseuilleParams): The parameters for the Hagen-Poiseuille problem to be solved. Only used if `problem_type = \"plane-hagen-poiseuille\" or \"plane-hagen-poiseuille\"` \"\"\" with open ( config_file_path , \"rb\" ) as f : self . config_file = tomllib . load ( f ) self . num_qubits = self . config_file [ \"computer\" ][ \"num_qubits\" ] self . ansatz = self . config_file [ \"circuit\" ][ \"ansatz\" ] self . conv_layer = self . config_file [ \"circuit\" ][ \"conv_layer\" ] self . num_layers = self . config_file [ \"circuit\" ][ \"num_layers\" ] self . dataset_size = self . config_file [ \"dataset\" ][ \"dataset_size\" ] self . batch_size = self . config_file [ \"dataset\" ][ \"batch_size\" ] self . optimizer = self . config_file [ \"training\" ][ \"optimizer\" ] self . max_iters = self . config_file [ \"training\" ][ \"max_iters\" ] self . abstol = self . config_file [ \"training\" ][ \"abstol\" ] self . step_size = self . config_file [ \"training\" ][ \"step_size\" ] self . x0 = self . config_file [ \"domain\" ][ \"x0\" ] self . xf = self . config_file [ \"domain\" ][ \"xf\" ] self . problem_type = self . config_file [ \"problem\" ][ \"problem_type\" ] self . output_folder_name = self . config_file [ \"output\" ][ \"folder_name\" ] if self . problem_type == \"hagen-poiseuille\" or self . problem_type == \"plane-hagen-poiseuille\" : self . hp_params = hp_params . HagenPoiseuilleParams ( self . config_file [ \"hagen-poiseuille-params\" ][ \"G\" ], self . config_file [ \"hagen-poiseuille-params\" ][ \"R\" ], self . config_file [ \"hagen-poiseuille-params\" ][ \"mu\" ] ) __init__ ( config_file_path ) Initialize the object. Parameters: Name Type Description Default config_file_path str String with the path to a TOML configuration file. required Attributes: Name Type Description config_file dict [ str , Any ] The loaded TOML configuration file as a dictionary of options. num_qubits int The total number of qubits to use for training. ansatz str The type of ansatz to use. conv_layer str The name of the convolutional layer to use. Ignored if ansatz != \"conv\" . num_layers int The number of entangling layers to use. Ignored if ansatz != \"sel\" . dataset_size int The number of datapoints to use during training. batch_size int The number of subsamples to use during batching. If set to 0 , no batching is used. optimizer str The training library to use for optimization. max_iters int The maximum number of steps the optimizer is allowed to take. abstol float The error function value bellow which training stops. setp_size float Initial step size for the optimizing algorithm. x0 float Left domain boundary. xf float Right domain boundary. problem_type str The type of problem to solve. output_folder_name str The folder where training output will be generated. hp_params str (HagenPoiseuilleParams): The parameters for the Hagen-Poiseuille problem to be solved. Only used if problem_type = \"plane-hagen-poiseuille\" or \"plane-hagen-poiseuille\" Source code in src/config.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __init__ ( self , config_file_path : str ): \"\"\" Initialize the object. Parameters: config_file_path (str): String with the path to a TOML configuration file. Attributes: config_file (dict[str, Any]): The loaded TOML configuration file as a dictionary of options. num_qubits (int): The total number of qubits to use for training. ansatz (str): The type of ansatz to use. conv_layer (str): The name of the convolutional layer to use. Ignored if `ansatz != \"conv\"`. num_layers (int): The number of entangling layers to use. Ignored if `ansatz != \"sel\"`. dataset_size (int): The number of datapoints to use during training. batch_size (int): The number of subsamples to use during batching. If set to `0`, no batching is used. optimizer (str): The training library to use for optimization. max_iters (int): The maximum number of steps the optimizer is allowed to take. abstol (float): The error function value bellow which training stops. setp_size (float): Initial step size for the optimizing algorithm. x0 (float): Left domain boundary. xf (float): Right domain boundary. problem_type (str): The type of problem to solve. output_folder_name (str): The folder where training output will be generated. hp_params: (HagenPoiseuilleParams): The parameters for the Hagen-Poiseuille problem to be solved. Only used if `problem_type = \"plane-hagen-poiseuille\" or \"plane-hagen-poiseuille\"` \"\"\" with open ( config_file_path , \"rb\" ) as f : self . config_file = tomllib . load ( f ) self . num_qubits = self . config_file [ \"computer\" ][ \"num_qubits\" ] self . ansatz = self . config_file [ \"circuit\" ][ \"ansatz\" ] self . conv_layer = self . config_file [ \"circuit\" ][ \"conv_layer\" ] self . num_layers = self . config_file [ \"circuit\" ][ \"num_layers\" ] self . dataset_size = self . config_file [ \"dataset\" ][ \"dataset_size\" ] self . batch_size = self . config_file [ \"dataset\" ][ \"batch_size\" ] self . optimizer = self . config_file [ \"training\" ][ \"optimizer\" ] self . max_iters = self . config_file [ \"training\" ][ \"max_iters\" ] self . abstol = self . config_file [ \"training\" ][ \"abstol\" ] self . step_size = self . config_file [ \"training\" ][ \"step_size\" ] self . x0 = self . config_file [ \"domain\" ][ \"x0\" ] self . xf = self . config_file [ \"domain\" ][ \"xf\" ] self . problem_type = self . config_file [ \"problem\" ][ \"problem_type\" ] self . output_folder_name = self . config_file [ \"output\" ][ \"folder_name\" ] if self . problem_type == \"hagen-poiseuille\" or self . problem_type == \"plane-hagen-poiseuille\" : self . hp_params = hp_params . HagenPoiseuilleParams ( self . config_file [ \"hagen-poiseuille-params\" ][ \"G\" ], self . config_file [ \"hagen-poiseuille-params\" ][ \"R\" ], self . config_file [ \"hagen-poiseuille-params\" ][ \"mu\" ] )","title":"config"},{"location":"module_config/#module-config","text":"Contains definitions relating to the configuration of how and what types of training will be performed","title":"Module config"},{"location":"module_config/#config.ConfigData","text":"Read and process configurations from the config.toml file. These files are used to drive the training, selecting which type of training to do and how to do it. Source code in src/config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class ConfigData : \"\"\" Read and process configurations from the `config.toml` file. These files are used to drive the training, selecting which type of training to do and how to do it. \"\"\" def __init__ ( self , config_file_path : str ): \"\"\" Initialize the object. Parameters: config_file_path (str): String with the path to a TOML configuration file. Attributes: config_file (dict[str, Any]): The loaded TOML configuration file as a dictionary of options. num_qubits (int): The total number of qubits to use for training. ansatz (str): The type of ansatz to use. conv_layer (str): The name of the convolutional layer to use. Ignored if `ansatz != \"conv\"`. num_layers (int): The number of entangling layers to use. Ignored if `ansatz != \"sel\"`. dataset_size (int): The number of datapoints to use during training. batch_size (int): The number of subsamples to use during batching. If set to `0`, no batching is used. optimizer (str): The training library to use for optimization. max_iters (int): The maximum number of steps the optimizer is allowed to take. abstol (float): The error function value bellow which training stops. setp_size (float): Initial step size for the optimizing algorithm. x0 (float): Left domain boundary. xf (float): Right domain boundary. problem_type (str): The type of problem to solve. output_folder_name (str): The folder where training output will be generated. hp_params: (HagenPoiseuilleParams): The parameters for the Hagen-Poiseuille problem to be solved. Only used if `problem_type = \"plane-hagen-poiseuille\" or \"plane-hagen-poiseuille\"` \"\"\" with open ( config_file_path , \"rb\" ) as f : self . config_file = tomllib . load ( f ) self . num_qubits = self . config_file [ \"computer\" ][ \"num_qubits\" ] self . ansatz = self . config_file [ \"circuit\" ][ \"ansatz\" ] self . conv_layer = self . config_file [ \"circuit\" ][ \"conv_layer\" ] self . num_layers = self . config_file [ \"circuit\" ][ \"num_layers\" ] self . dataset_size = self . config_file [ \"dataset\" ][ \"dataset_size\" ] self . batch_size = self . config_file [ \"dataset\" ][ \"batch_size\" ] self . optimizer = self . config_file [ \"training\" ][ \"optimizer\" ] self . max_iters = self . config_file [ \"training\" ][ \"max_iters\" ] self . abstol = self . config_file [ \"training\" ][ \"abstol\" ] self . step_size = self . config_file [ \"training\" ][ \"step_size\" ] self . x0 = self . config_file [ \"domain\" ][ \"x0\" ] self . xf = self . config_file [ \"domain\" ][ \"xf\" ] self . problem_type = self . config_file [ \"problem\" ][ \"problem_type\" ] self . output_folder_name = self . config_file [ \"output\" ][ \"folder_name\" ] if self . problem_type == \"hagen-poiseuille\" or self . problem_type == \"plane-hagen-poiseuille\" : self . hp_params = hp_params . HagenPoiseuilleParams ( self . config_file [ \"hagen-poiseuille-params\" ][ \"G\" ], self . config_file [ \"hagen-poiseuille-params\" ][ \"R\" ], self . config_file [ \"hagen-poiseuille-params\" ][ \"mu\" ] )","title":"ConfigData"},{"location":"module_config/#config.ConfigData.__init__","text":"Initialize the object. Parameters: Name Type Description Default config_file_path str String with the path to a TOML configuration file. required Attributes: Name Type Description config_file dict [ str , Any ] The loaded TOML configuration file as a dictionary of options. num_qubits int The total number of qubits to use for training. ansatz str The type of ansatz to use. conv_layer str The name of the convolutional layer to use. Ignored if ansatz != \"conv\" . num_layers int The number of entangling layers to use. Ignored if ansatz != \"sel\" . dataset_size int The number of datapoints to use during training. batch_size int The number of subsamples to use during batching. If set to 0 , no batching is used. optimizer str The training library to use for optimization. max_iters int The maximum number of steps the optimizer is allowed to take. abstol float The error function value bellow which training stops. setp_size float Initial step size for the optimizing algorithm. x0 float Left domain boundary. xf float Right domain boundary. problem_type str The type of problem to solve. output_folder_name str The folder where training output will be generated. hp_params str (HagenPoiseuilleParams): The parameters for the Hagen-Poiseuille problem to be solved. Only used if problem_type = \"plane-hagen-poiseuille\" or \"plane-hagen-poiseuille\" Source code in src/config.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __init__ ( self , config_file_path : str ): \"\"\" Initialize the object. Parameters: config_file_path (str): String with the path to a TOML configuration file. Attributes: config_file (dict[str, Any]): The loaded TOML configuration file as a dictionary of options. num_qubits (int): The total number of qubits to use for training. ansatz (str): The type of ansatz to use. conv_layer (str): The name of the convolutional layer to use. Ignored if `ansatz != \"conv\"`. num_layers (int): The number of entangling layers to use. Ignored if `ansatz != \"sel\"`. dataset_size (int): The number of datapoints to use during training. batch_size (int): The number of subsamples to use during batching. If set to `0`, no batching is used. optimizer (str): The training library to use for optimization. max_iters (int): The maximum number of steps the optimizer is allowed to take. abstol (float): The error function value bellow which training stops. setp_size (float): Initial step size for the optimizing algorithm. x0 (float): Left domain boundary. xf (float): Right domain boundary. problem_type (str): The type of problem to solve. output_folder_name (str): The folder where training output will be generated. hp_params: (HagenPoiseuilleParams): The parameters for the Hagen-Poiseuille problem to be solved. Only used if `problem_type = \"plane-hagen-poiseuille\" or \"plane-hagen-poiseuille\"` \"\"\" with open ( config_file_path , \"rb\" ) as f : self . config_file = tomllib . load ( f ) self . num_qubits = self . config_file [ \"computer\" ][ \"num_qubits\" ] self . ansatz = self . config_file [ \"circuit\" ][ \"ansatz\" ] self . conv_layer = self . config_file [ \"circuit\" ][ \"conv_layer\" ] self . num_layers = self . config_file [ \"circuit\" ][ \"num_layers\" ] self . dataset_size = self . config_file [ \"dataset\" ][ \"dataset_size\" ] self . batch_size = self . config_file [ \"dataset\" ][ \"batch_size\" ] self . optimizer = self . config_file [ \"training\" ][ \"optimizer\" ] self . max_iters = self . config_file [ \"training\" ][ \"max_iters\" ] self . abstol = self . config_file [ \"training\" ][ \"abstol\" ] self . step_size = self . config_file [ \"training\" ][ \"step_size\" ] self . x0 = self . config_file [ \"domain\" ][ \"x0\" ] self . xf = self . config_file [ \"domain\" ][ \"xf\" ] self . problem_type = self . config_file [ \"problem\" ][ \"problem_type\" ] self . output_folder_name = self . config_file [ \"output\" ][ \"folder_name\" ] if self . problem_type == \"hagen-poiseuille\" or self . problem_type == \"plane-hagen-poiseuille\" : self . hp_params = hp_params . HagenPoiseuilleParams ( self . config_file [ \"hagen-poiseuille-params\" ][ \"G\" ], self . config_file [ \"hagen-poiseuille-params\" ][ \"R\" ], self . config_file [ \"hagen-poiseuille-params\" ][ \"mu\" ] )","title":"__init__"},{"location":"module_conv_layer/","text":"Module conv_layer Contains all convolutional layer circuits that can be used for training. FreeVatanWilliams dataclass Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf. Modified so taht all roations are free trainable parameters. Attributes: Name Type Description name str The name of the convolutional layer (\"Free Vatan - Williams\"). ppb int The number of trainable parameters per convolutional block (5). Source code in src/conv_layers.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 @dataclass class FreeVatanWilliams : \"\"\" Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf. Modified so taht all roations are free trainable parameters. Attributes: name (str): The name of the convolutional layer (\"Free Vatan - Williams\"). ppb (int): The number of trainable parameters per convolutional block (5). \"\"\" name : str = \"Free Vatan - Williams\" ppb : int = 5 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RZ ( p [ 0 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( p [ 1 ], wires = w [ 0 ]) qml . RY ( p [ 2 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 3 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( p [ 4 ], wires = w [ 0 ]) layer ( p , w ) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RZ ( p [ 0 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( p [ 1 ], wires = w [ 0 ]) qml . RY ( p [ 2 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 3 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( p [ 4 ], wires = w [ 0 ]) HurKimPark1 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (1)\"). ppb int The number of trainable parameters per convolutional block (2). Source code in src/conv_layers.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @dataclass class HurKimPark1 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (1)\"). ppb (int): The number of trainable parameters per convolutional block (2). \"\"\" name : str = \"Hur - Kim - Park (1)\" ppb : int = 2 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) layer ( p , w ) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 87 88 89 90 91 92 93 94 95 96 97 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) HurKimPark2 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (2)\"). ppb int The number of trainable parameters per convolutional block (2). Source code in src/conv_layers.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 @dataclass class HurKimPark2 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (2)\"). ppb (int): The number of trainable parameters per convolutional block (2). \"\"\" name : str = \"Hur - Kim - Park (2)\" ppb : int = 2 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . Hadamard ( wires = w [ 0 ]) qml . Hadamard ( wires = w [ 1 ]) qml . CZ ( wires = [ w [ 0 ], w [ 1 ]]) qml . RX ( p [ 0 ], wires = w [ 0 ]) qml . RX ( p [ 1 ], wires = w [ 1 ]) layer ( p , w ) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 113 114 115 116 117 118 119 120 121 122 123 124 125 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . Hadamard ( wires = w [ 0 ]) qml . Hadamard ( wires = w [ 1 ]) qml . CZ ( wires = [ w [ 0 ], w [ 1 ]]) qml . RX ( p [ 0 ], wires = w [ 0 ]) qml . RX ( p [ 1 ], wires = w [ 1 ]) HurKimPark3 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (3)\"). ppb int The number of trainable parameters per convolutional block (4). Source code in src/conv_layers.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @dataclass class HurKimPark3 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (3)\"). ppb (int): The number of trainable parameters per convolutional block (4). \"\"\" name : str = \"Hur - Kim - Park (3)\" ppb : int = 4 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 2 ], wires = w [ 0 ]) qml . RY ( p [ 3 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) layer ( p , w ) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 2 ], wires = w [ 0 ]) qml . RY ( p [ 3 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) HurKimPark4 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (4)\"). ppb int The number of trainable parameters per convolutional block (6). Source code in src/conv_layers.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @dataclass class HurKimPark4 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (4)\"). ppb (int): The number of trainable parameters per convolutional block (6). \"\"\" name : str = \"Hur - Kim - Park (4)\" ppb : int = 6 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CRZ ( p [ 2 ], wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 3 ], wires = w [ 0 ]) qml . RY ( p [ 4 ], wires = w [ 1 ]) qml . CRZ ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]]) layer ( p , w ) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CRZ ( p [ 2 ], wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 3 ], wires = w [ 0 ]) qml . RY ( p [ 4 ], wires = w [ 1 ]) qml . CRZ ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]]) HurKimPark5 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (5)\"). ppb int The number of trainable parameters per convolutional block (6). Source code in src/conv_layers.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 @dataclass class HurKimPark5 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (5)\"). ppb (int): The number of trainable parameters per convolutional block (6). \"\"\" name : str = \"Hur - Kim - Park (5)\" ppb : int = 6 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CRX ( p [ 2 ], wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 3 ], wires = w [ 0 ]) qml . RY ( p [ 4 ], wires = w [ 1 ]) qml . CRX ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]]) layer ( p , w ) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CRX ( p [ 2 ], wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 3 ], wires = w [ 0 ]) qml . RY ( p [ 4 ], wires = w [ 1 ]) qml . CRX ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]]) HurKimPark6 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (6)\"). ppb int The number of trainable parameters per convolutional block (6). Source code in src/conv_layers.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 @dataclass class HurKimPark6 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (6)\"). ppb (int): The number of trainable parameters per convolutional block (6). \"\"\" name : str = \"Hur - Kim - Park (6)\" ppb : int = 6 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 2 ], wires = w [ 0 ]) qml . RY ( p [ 3 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 4 ], wires = w [ 0 ]) qml . RY ( p [ 5 ], wires = w [ 1 ]) layer ( p , w ) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 2 ], wires = w [ 0 ]) qml . RY ( p [ 3 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 4 ], wires = w [ 0 ]) qml . RY ( p [ 5 ], wires = w [ 1 ]) HurKimPark7 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (7)\"). ppb int The number of trainable parameters per convolutional block (10). Source code in src/conv_layers.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 @dataclass class HurKimPark7 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (7)\"). ppb (int): The number of trainable parameters per convolutional block (10). \"\"\" name : str = \"Hur - Kim - Park (7)\" ppb : int = 10 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RX ( p [ 0 ], wires = w [ 0 ]) qml . RX ( p [ 1 ], wires = w [ 1 ]) qml . RZ ( p [ 2 ], wires = w [ 0 ]) qml . RZ ( p [ 3 ], wires = w [ 1 ]) qml . CRZ ( p [ 4 ], wires = [ w [ 1 ], w [ 0 ]]) qml . CRZ ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]]) qml . RX ( p [ 6 ], wires = w [ 0 ]) qml . RX ( p [ 7 ], wires = w [ 1 ]) qml . RZ ( p [ 8 ], wires = w [ 0 ]) qml . RZ ( p [ 9 ], wires = w [ 1 ]) layer ( p , w ) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RX ( p [ 0 ], wires = w [ 0 ]) qml . RX ( p [ 1 ], wires = w [ 1 ]) qml . RZ ( p [ 2 ], wires = w [ 0 ]) qml . RZ ( p [ 3 ], wires = w [ 1 ]) qml . CRZ ( p [ 4 ], wires = [ w [ 1 ], w [ 0 ]]) qml . CRZ ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]]) qml . RX ( p [ 6 ], wires = w [ 0 ]) qml . RX ( p [ 7 ], wires = w [ 1 ]) qml . RZ ( p [ 8 ], wires = w [ 0 ]) qml . RZ ( p [ 9 ], wires = w [ 1 ]) HurKimPark8 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (8)\"). ppb int The number of trainable parameters per convolutional block (10). Source code in src/conv_layers.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 @dataclass class HurKimPark8 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (8)\"). ppb (int): The number of trainable parameters per convolutional block (10). \"\"\" name : str = \"Hur - Kim - Park (8)\" ppb : int = 10 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RX ( p [ 0 ], wires = w [ 0 ]) qml . RX ( p [ 1 ], wires = w [ 1 ]) qml . RZ ( p [ 2 ], wires = w [ 0 ]) qml . RZ ( p [ 3 ], wires = w [ 1 ]) qml . CRX ( p [ 4 ], wires = [ w [ 1 ], w [ 0 ]]) qml . CRX ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]]) qml . RX ( p [ 6 ], wires = w [ 0 ]) qml . RX ( p [ 7 ], wires = w [ 1 ]) qml . RZ ( p [ 8 ], wires = w [ 0 ]) qml . RZ ( p [ 9 ], wires = w [ 1 ]) layer ( p , w ) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RX ( p [ 0 ], wires = w [ 0 ]) qml . RX ( p [ 1 ], wires = w [ 1 ]) qml . RZ ( p [ 2 ], wires = w [ 0 ]) qml . RZ ( p [ 3 ], wires = w [ 1 ]) qml . CRX ( p [ 4 ], wires = [ w [ 1 ], w [ 0 ]]) qml . CRX ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]]) qml . RX ( p [ 6 ], wires = w [ 0 ]) qml . RX ( p [ 7 ], wires = w [ 1 ]) qml . RZ ( p [ 8 ], wires = w [ 0 ]) qml . RZ ( p [ 9 ], wires = w [ 1 ]) HurKimPark9 dataclass Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (9)\"). ppb int The number of trainable parameters per convolutional block (15). Source code in src/conv_layers.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 @dataclass class HurKimPark9 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (9)\"). ppb (int): The number of trainable parameters per convolutional block (15). \"\"\" name : str = \"Hur - Kim - Park (9)\" ppb : int = 15 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" # U30 qml . RZ ( p [ 0 ], wires = w [ 0 ]) qml . RX ( - np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 1 ], wires = w [ 0 ]) qml . RX ( np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 2 ], wires = w [ 0 ]) # U31 qml . RZ ( p [ 3 ], wires = w [ 1 ]) qml . RX ( - np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 4 ], wires = w [ 1 ]) qml . RX ( np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 5 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 6 ], wires = w [ 0 ]) qml . RZ ( p [ 7 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 8 ], wires = w [ 0 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) # U30 qml . RZ ( p [ 9 ], wires = w [ 0 ]) qml . RX ( - np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 10 ], wires = w [ 0 ]) qml . RX ( np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 11 ], wires = w [ 0 ]) # U31 qml . RZ ( p [ 12 ], wires = w [ 1 ]) qml . RX ( - np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 13 ], wires = w [ 1 ]) qml . RX ( np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 14 ], wires = w [ 1 ]) layer ( p , w ) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" # U30 qml . RZ ( p [ 0 ], wires = w [ 0 ]) qml . RX ( - np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 1 ], wires = w [ 0 ]) qml . RX ( np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 2 ], wires = w [ 0 ]) # U31 qml . RZ ( p [ 3 ], wires = w [ 1 ]) qml . RX ( - np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 4 ], wires = w [ 1 ]) qml . RX ( np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 5 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 6 ], wires = w [ 0 ]) qml . RZ ( p [ 7 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 8 ], wires = w [ 0 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) # U30 qml . RZ ( p [ 9 ], wires = w [ 0 ]) qml . RX ( - np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 10 ], wires = w [ 0 ]) qml . RX ( np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 11 ], wires = w [ 0 ]) # U31 qml . RZ ( p [ 12 ], wires = w [ 1 ]) qml . RX ( - np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 13 ], wires = w [ 1 ]) qml . RX ( np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 14 ], wires = w [ 1 ]) VatanWilliams dataclass Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf Attributes: Name Type Description name str The name of the convolutional layer (\"Vatan - Williams\"). ppb int The number of trainable parameters per convolutional block (3). Source code in src/conv_layers.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @dataclass class VatanWilliams : \"\"\" Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf Attributes: name (str): The name of the convolutional layer (\"Vatan - Williams\"). ppb (int): The number of trainable parameters per convolutional block (3). \"\"\" name : str = \"Vatan - Williams\" ppb : int = 3 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RZ ( np . pi / 2 , wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 2 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( - np . pi / 2 , wires = w [ 0 ]) layer ( p , w ) Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RZ ( np . pi / 2 , wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 2 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( - np . pi / 2 , wires = w [ 0 ])","title":"conv_layer"},{"location":"module_conv_layer/#module-conv_layer","text":"Contains all convolutional layer circuits that can be used for training.","title":"Module conv_layer"},{"location":"module_conv_layer/#conv_layers.FreeVatanWilliams","text":"Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf. Modified so taht all roations are free trainable parameters. Attributes: Name Type Description name str The name of the convolutional layer (\"Free Vatan - Williams\"). ppb int The number of trainable parameters per convolutional block (5). Source code in src/conv_layers.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 @dataclass class FreeVatanWilliams : \"\"\" Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf. Modified so taht all roations are free trainable parameters. Attributes: name (str): The name of the convolutional layer (\"Free Vatan - Williams\"). ppb (int): The number of trainable parameters per convolutional block (5). \"\"\" name : str = \"Free Vatan - Williams\" ppb : int = 5 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RZ ( p [ 0 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( p [ 1 ], wires = w [ 0 ]) qml . RY ( p [ 2 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 3 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( p [ 4 ], wires = w [ 0 ])","title":"FreeVatanWilliams"},{"location":"module_conv_layer/#conv_layers.FreeVatanWilliams.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RZ ( p [ 0 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( p [ 1 ], wires = w [ 0 ]) qml . RY ( p [ 2 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 3 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( p [ 4 ], wires = w [ 0 ])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark1","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (1)\"). ppb int The number of trainable parameters per convolutional block (2). Source code in src/conv_layers.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @dataclass class HurKimPark1 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (1)\"). ppb (int): The number of trainable parameters per convolutional block (2). \"\"\" name : str = \"Hur - Kim - Park (1)\" ppb : int = 2 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]])","title":"HurKimPark1"},{"location":"module_conv_layer/#conv_layers.HurKimPark1.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 87 88 89 90 91 92 93 94 95 96 97 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark2","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (2)\"). ppb int The number of trainable parameters per convolutional block (2). Source code in src/conv_layers.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 @dataclass class HurKimPark2 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (2)\"). ppb (int): The number of trainable parameters per convolutional block (2). \"\"\" name : str = \"Hur - Kim - Park (2)\" ppb : int = 2 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . Hadamard ( wires = w [ 0 ]) qml . Hadamard ( wires = w [ 1 ]) qml . CZ ( wires = [ w [ 0 ], w [ 1 ]]) qml . RX ( p [ 0 ], wires = w [ 0 ]) qml . RX ( p [ 1 ], wires = w [ 1 ])","title":"HurKimPark2"},{"location":"module_conv_layer/#conv_layers.HurKimPark2.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 113 114 115 116 117 118 119 120 121 122 123 124 125 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . Hadamard ( wires = w [ 0 ]) qml . Hadamard ( wires = w [ 1 ]) qml . CZ ( wires = [ w [ 0 ], w [ 1 ]]) qml . RX ( p [ 0 ], wires = w [ 0 ]) qml . RX ( p [ 1 ], wires = w [ 1 ])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark3","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (3)\"). ppb int The number of trainable parameters per convolutional block (4). Source code in src/conv_layers.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @dataclass class HurKimPark3 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (3)\"). ppb (int): The number of trainable parameters per convolutional block (4). \"\"\" name : str = \"Hur - Kim - Park (3)\" ppb : int = 4 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 2 ], wires = w [ 0 ]) qml . RY ( p [ 3 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]])","title":"HurKimPark3"},{"location":"module_conv_layer/#conv_layers.HurKimPark3.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 2 ], wires = w [ 0 ]) qml . RY ( p [ 3 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark4","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (4)\"). ppb int The number of trainable parameters per convolutional block (6). Source code in src/conv_layers.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @dataclass class HurKimPark4 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (4)\"). ppb (int): The number of trainable parameters per convolutional block (6). \"\"\" name : str = \"Hur - Kim - Park (4)\" ppb : int = 6 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CRZ ( p [ 2 ], wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 3 ], wires = w [ 0 ]) qml . RY ( p [ 4 ], wires = w [ 1 ]) qml . CRZ ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]])","title":"HurKimPark4"},{"location":"module_conv_layer/#conv_layers.HurKimPark4.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CRZ ( p [ 2 ], wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 3 ], wires = w [ 0 ]) qml . RY ( p [ 4 ], wires = w [ 1 ]) qml . CRZ ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark5","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (5)\"). ppb int The number of trainable parameters per convolutional block (6). Source code in src/conv_layers.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 @dataclass class HurKimPark5 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (5)\"). ppb (int): The number of trainable parameters per convolutional block (6). \"\"\" name : str = \"Hur - Kim - Park (5)\" ppb : int = 6 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CRX ( p [ 2 ], wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 3 ], wires = w [ 0 ]) qml . RY ( p [ 4 ], wires = w [ 1 ]) qml . CRX ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]])","title":"HurKimPark5"},{"location":"module_conv_layer/#conv_layers.HurKimPark5.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CRX ( p [ 2 ], wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 3 ], wires = w [ 0 ]) qml . RY ( p [ 4 ], wires = w [ 1 ]) qml . CRX ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark6","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (6)\"). ppb int The number of trainable parameters per convolutional block (6). Source code in src/conv_layers.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 @dataclass class HurKimPark6 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (6)\"). ppb (int): The number of trainable parameters per convolutional block (6). \"\"\" name : str = \"Hur - Kim - Park (6)\" ppb : int = 6 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 2 ], wires = w [ 0 ]) qml . RY ( p [ 3 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 4 ], wires = w [ 0 ]) qml . RY ( p [ 5 ], wires = w [ 1 ])","title":"HurKimPark6"},{"location":"module_conv_layer/#conv_layers.HurKimPark6.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RY ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 2 ], wires = w [ 0 ]) qml . RY ( p [ 3 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 4 ], wires = w [ 0 ]) qml . RY ( p [ 5 ], wires = w [ 1 ])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark7","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (7)\"). ppb int The number of trainable parameters per convolutional block (10). Source code in src/conv_layers.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 @dataclass class HurKimPark7 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (7)\"). ppb (int): The number of trainable parameters per convolutional block (10). \"\"\" name : str = \"Hur - Kim - Park (7)\" ppb : int = 10 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RX ( p [ 0 ], wires = w [ 0 ]) qml . RX ( p [ 1 ], wires = w [ 1 ]) qml . RZ ( p [ 2 ], wires = w [ 0 ]) qml . RZ ( p [ 3 ], wires = w [ 1 ]) qml . CRZ ( p [ 4 ], wires = [ w [ 1 ], w [ 0 ]]) qml . CRZ ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]]) qml . RX ( p [ 6 ], wires = w [ 0 ]) qml . RX ( p [ 7 ], wires = w [ 1 ]) qml . RZ ( p [ 8 ], wires = w [ 0 ]) qml . RZ ( p [ 9 ], wires = w [ 1 ])","title":"HurKimPark7"},{"location":"module_conv_layer/#conv_layers.HurKimPark7.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RX ( p [ 0 ], wires = w [ 0 ]) qml . RX ( p [ 1 ], wires = w [ 1 ]) qml . RZ ( p [ 2 ], wires = w [ 0 ]) qml . RZ ( p [ 3 ], wires = w [ 1 ]) qml . CRZ ( p [ 4 ], wires = [ w [ 1 ], w [ 0 ]]) qml . CRZ ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]]) qml . RX ( p [ 6 ], wires = w [ 0 ]) qml . RX ( p [ 7 ], wires = w [ 1 ]) qml . RZ ( p [ 8 ], wires = w [ 0 ]) qml . RZ ( p [ 9 ], wires = w [ 1 ])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark8","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (8)\"). ppb int The number of trainable parameters per convolutional block (10). Source code in src/conv_layers.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 @dataclass class HurKimPark8 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (8)\"). ppb (int): The number of trainable parameters per convolutional block (10). \"\"\" name : str = \"Hur - Kim - Park (8)\" ppb : int = 10 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RX ( p [ 0 ], wires = w [ 0 ]) qml . RX ( p [ 1 ], wires = w [ 1 ]) qml . RZ ( p [ 2 ], wires = w [ 0 ]) qml . RZ ( p [ 3 ], wires = w [ 1 ]) qml . CRX ( p [ 4 ], wires = [ w [ 1 ], w [ 0 ]]) qml . CRX ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]]) qml . RX ( p [ 6 ], wires = w [ 0 ]) qml . RX ( p [ 7 ], wires = w [ 1 ]) qml . RZ ( p [ 8 ], wires = w [ 0 ]) qml . RZ ( p [ 9 ], wires = w [ 1 ])","title":"HurKimPark8"},{"location":"module_conv_layer/#conv_layers.HurKimPark8.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RX ( p [ 0 ], wires = w [ 0 ]) qml . RX ( p [ 1 ], wires = w [ 1 ]) qml . RZ ( p [ 2 ], wires = w [ 0 ]) qml . RZ ( p [ 3 ], wires = w [ 1 ]) qml . CRX ( p [ 4 ], wires = [ w [ 1 ], w [ 0 ]]) qml . CRX ( p [ 5 ], wires = [ w [ 0 ], w [ 1 ]]) qml . RX ( p [ 6 ], wires = w [ 0 ]) qml . RX ( p [ 7 ], wires = w [ 1 ]) qml . RZ ( p [ 8 ], wires = w [ 0 ]) qml . RZ ( p [ 9 ], wires = w [ 1 ])","title":"layer"},{"location":"module_conv_layer/#conv_layers.HurKimPark9","text":"Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: Name Type Description name str The name of the convolutional layer (\"Hur - Kim - Park (9)\"). ppb int The number of trainable parameters per convolutional block (15). Source code in src/conv_layers.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 @dataclass class HurKimPark9 : \"\"\" Convolutional layer defined in https://arxiv.org/abs/2108.00661. Attributes: name (str): The name of the convolutional layer (\"Hur - Kim - Park (9)\"). ppb (int): The number of trainable parameters per convolutional block (15). \"\"\" name : str = \"Hur - Kim - Park (9)\" ppb : int = 15 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" # U30 qml . RZ ( p [ 0 ], wires = w [ 0 ]) qml . RX ( - np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 1 ], wires = w [ 0 ]) qml . RX ( np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 2 ], wires = w [ 0 ]) # U31 qml . RZ ( p [ 3 ], wires = w [ 1 ]) qml . RX ( - np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 4 ], wires = w [ 1 ]) qml . RX ( np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 5 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 6 ], wires = w [ 0 ]) qml . RZ ( p [ 7 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 8 ], wires = w [ 0 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) # U30 qml . RZ ( p [ 9 ], wires = w [ 0 ]) qml . RX ( - np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 10 ], wires = w [ 0 ]) qml . RX ( np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 11 ], wires = w [ 0 ]) # U31 qml . RZ ( p [ 12 ], wires = w [ 1 ]) qml . RX ( - np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 13 ], wires = w [ 1 ]) qml . RX ( np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 14 ], wires = w [ 1 ])","title":"HurKimPark9"},{"location":"module_conv_layer/#conv_layers.HurKimPark9.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" # U30 qml . RZ ( p [ 0 ], wires = w [ 0 ]) qml . RX ( - np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 1 ], wires = w [ 0 ]) qml . RX ( np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 2 ], wires = w [ 0 ]) # U31 qml . RZ ( p [ 3 ], wires = w [ 1 ]) qml . RX ( - np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 4 ], wires = w [ 1 ]) qml . RX ( np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 5 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 6 ], wires = w [ 0 ]) qml . RZ ( p [ 7 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RY ( p [ 8 ], wires = w [ 0 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) # U30 qml . RZ ( p [ 9 ], wires = w [ 0 ]) qml . RX ( - np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 10 ], wires = w [ 0 ]) qml . RX ( np . pi / 2 , wires = w [ 0 ]) qml . RZ ( p [ 11 ], wires = w [ 0 ]) # U31 qml . RZ ( p [ 12 ], wires = w [ 1 ]) qml . RX ( - np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 13 ], wires = w [ 1 ]) qml . RX ( np . pi / 2 , wires = w [ 1 ]) qml . RZ ( p [ 14 ], wires = w [ 1 ])","title":"layer"},{"location":"module_conv_layer/#conv_layers.VatanWilliams","text":"Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf Attributes: Name Type Description name str The name of the convolutional layer (\"Vatan - Williams\"). ppb int The number of trainable parameters per convolutional block (3). Source code in src/conv_layers.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @dataclass class VatanWilliams : \"\"\" Convolutional layer defined in https://arxiv.org/pdf/quant-ph/0308006.pdf Attributes: name (str): The name of the convolutional layer (\"Vatan - Williams\"). ppb (int): The number of trainable parameters per convolutional block (3). \"\"\" name : str = \"Vatan - Williams\" ppb : int = 3 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RZ ( np . pi / 2 , wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 2 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( - np . pi / 2 , wires = w [ 0 ])","title":"VatanWilliams"},{"location":"module_conv_layer/#conv_layers.VatanWilliams.layer","text":"Circuit defining the convolutional layer. Parameters: Name Type Description Default p array List of values for the trainable parameters of the circuit. required w array List of qubit indices where the circuit is to be applied to. required Source code in src/conv_layers.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def layer ( p , w ): \"\"\" Circuit defining the convolutional layer. Parameters: p (array): List of values for the trainable parameters of the circuit. w (array): List of qubit indices where the circuit is to be applied to. \"\"\" qml . RZ ( np . pi / 2 , wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( p [ 0 ], wires = w [ 0 ]) qml . RY ( p [ 1 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 0 ], w [ 1 ]]) qml . RY ( p [ 2 ], wires = w [ 1 ]) qml . CNOT ( wires = [ w [ 1 ], w [ 0 ]]) qml . RZ ( - np . pi / 2 , wires = w [ 0 ])","title":"layer"},{"location":"module_domain_map/","text":"Module domain_map Defines domain maps: Maps from a global computational domain to a local domain ranging from [-1, 1] where the actual training takes place and inverse transformations from local back to global domain. DomainMap Defines a general domain map Attributes: Name Type Description global_start float The left boundary of the global domain. global_end float The right boundary of the global domain. Source code in src/domain_map.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class DomainMap : \"\"\" Defines a general domain map Attributes: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" def __init__ ( self , global_start : float , global_end : float ): \"\"\" Initialize the object. Parameters: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" self . global_start = global_start self . global_end = global_end def local2global ( self , local_X ): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return local_X def global2local ( self , global_x ): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return global_x def dlocal_dglobal ( self , global_x ): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 0.0 def d2local_dglobal2 ( self , global_x ): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0 __init__ ( global_start , global_end ) Initialize the object. Parameters: Name Type Description Default global_start float The left boundary of the global domain. required global_end float The right boundary of the global domain. required Source code in src/domain_map.py 17 18 19 20 21 22 23 24 25 26 def __init__ ( self , global_start : float , global_end : float ): \"\"\" Initialize the object. Parameters: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" self . global_start = global_start self . global_end = global_end d2local_dglobal2 ( global_x ) The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The second derivative of global2local in the passed point. Source code in src/domain_map.py 65 66 67 68 69 70 71 72 73 74 75 76 def d2local_dglobal2 ( self , global_x ): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0 dlocal_dglobal ( global_x ) The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The derivative of global2local in the passed point. Source code in src/domain_map.py 52 53 54 55 56 57 58 59 60 61 62 63 def dlocal_dglobal ( self , global_x ): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 0.0 global2local ( global_x ) Converts a point in global domain to local domain. Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The corresponding local domain point. Source code in src/domain_map.py 40 41 42 43 44 45 46 47 48 49 50 def global2local ( self , global_x ): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return global_x local2global ( local_X ) Converts a point in local domain to global domain. Parameters: Name Type Description Default local_X float The local domain point. required Returns: Type Description float The corresponding global domain point. Source code in src/domain_map.py 28 29 30 31 32 33 34 35 36 37 38 def local2global ( self , local_X ): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return local_X LinearMap Bases: DomainMap Defines a linear domain map, that is, link global and local domains using a linear coordiante transformation. Attributes: Name Type Description global_start float The left boundary of the global domain. global_end float The right boundary of the global domain. Source code in src/domain_map.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class LinearMap ( DomainMap ): \"\"\" Defines a linear domain map, that is, link global and local domains using a linear coordiante transformation. Attributes: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" def local2global ( self , local_X ): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return ( self . global_start + self . global_end + ( self . global_end - self . global_start ) * local_X ) / 2.0 def global2local ( self , global_x ): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return ( self . global_start + self . global_end - 2.0 * global_x ) / ( self . global_start - self . global_end ) def dlocal_dglobal ( self , global_x ): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 2.0 / ( self . global_end - self . global_start ) def d2local_dglobal2 ( self , global_x ): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0 d2local_dglobal2 ( global_x ) The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The second derivative of global2local in the passed point. Source code in src/domain_map.py 126 127 128 129 130 131 132 133 134 135 136 137 def d2local_dglobal2 ( self , global_x ): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0 dlocal_dglobal ( global_x ) The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The derivative of global2local in the passed point. Source code in src/domain_map.py 113 114 115 116 117 118 119 120 121 122 123 124 def dlocal_dglobal ( self , global_x ): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 2.0 / ( self . global_end - self . global_start ) global2local ( global_x ) Converts a point in global domain to local domain. Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The corresponding local domain point. Source code in src/domain_map.py 101 102 103 104 105 106 107 108 109 110 111 def global2local ( self , global_x ): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return ( self . global_start + self . global_end - 2.0 * global_x ) / ( self . global_start - self . global_end ) local2global ( local_X ) Converts a point in local domain to global domain. Parameters: Name Type Description Default local_X float The local domain point. required Returns: Type Description float The corresponding global domain point. Source code in src/domain_map.py 89 90 91 92 93 94 95 96 97 98 99 def local2global ( self , local_X ): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return ( self . global_start + self . global_end + ( self . global_end - self . global_start ) * local_X ) / 2.0","title":"domain_map"},{"location":"module_domain_map/#module-domain_map","text":"Defines domain maps: Maps from a global computational domain to a local domain ranging from [-1, 1] where the actual training takes place and inverse transformations from local back to global domain.","title":"Module domain_map"},{"location":"module_domain_map/#domain_map.DomainMap","text":"Defines a general domain map Attributes: Name Type Description global_start float The left boundary of the global domain. global_end float The right boundary of the global domain. Source code in src/domain_map.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class DomainMap : \"\"\" Defines a general domain map Attributes: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" def __init__ ( self , global_start : float , global_end : float ): \"\"\" Initialize the object. Parameters: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" self . global_start = global_start self . global_end = global_end def local2global ( self , local_X ): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return local_X def global2local ( self , global_x ): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return global_x def dlocal_dglobal ( self , global_x ): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 0.0 def d2local_dglobal2 ( self , global_x ): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0","title":"DomainMap"},{"location":"module_domain_map/#domain_map.DomainMap.__init__","text":"Initialize the object. Parameters: Name Type Description Default global_start float The left boundary of the global domain. required global_end float The right boundary of the global domain. required Source code in src/domain_map.py 17 18 19 20 21 22 23 24 25 26 def __init__ ( self , global_start : float , global_end : float ): \"\"\" Initialize the object. Parameters: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" self . global_start = global_start self . global_end = global_end","title":"__init__"},{"location":"module_domain_map/#domain_map.DomainMap.d2local_dglobal2","text":"The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The second derivative of global2local in the passed point. Source code in src/domain_map.py 65 66 67 68 69 70 71 72 73 74 75 76 def d2local_dglobal2 ( self , global_x ): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0","title":"d2local_dglobal2"},{"location":"module_domain_map/#domain_map.DomainMap.dlocal_dglobal","text":"The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The derivative of global2local in the passed point. Source code in src/domain_map.py 52 53 54 55 56 57 58 59 60 61 62 63 def dlocal_dglobal ( self , global_x ): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 0.0","title":"dlocal_dglobal"},{"location":"module_domain_map/#domain_map.DomainMap.global2local","text":"Converts a point in global domain to local domain. Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The corresponding local domain point. Source code in src/domain_map.py 40 41 42 43 44 45 46 47 48 49 50 def global2local ( self , global_x ): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return global_x","title":"global2local"},{"location":"module_domain_map/#domain_map.DomainMap.local2global","text":"Converts a point in local domain to global domain. Parameters: Name Type Description Default local_X float The local domain point. required Returns: Type Description float The corresponding global domain point. Source code in src/domain_map.py 28 29 30 31 32 33 34 35 36 37 38 def local2global ( self , local_X ): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return local_X","title":"local2global"},{"location":"module_domain_map/#domain_map.LinearMap","text":"Bases: DomainMap Defines a linear domain map, that is, link global and local domains using a linear coordiante transformation. Attributes: Name Type Description global_start float The left boundary of the global domain. global_end float The right boundary of the global domain. Source code in src/domain_map.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class LinearMap ( DomainMap ): \"\"\" Defines a linear domain map, that is, link global and local domains using a linear coordiante transformation. Attributes: global_start (float): The left boundary of the global domain. global_end (float): The right boundary of the global domain. \"\"\" def local2global ( self , local_X ): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return ( self . global_start + self . global_end + ( self . global_end - self . global_start ) * local_X ) / 2.0 def global2local ( self , global_x ): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return ( self . global_start + self . global_end - 2.0 * global_x ) / ( self . global_start - self . global_end ) def dlocal_dglobal ( self , global_x ): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 2.0 / ( self . global_end - self . global_start ) def d2local_dglobal2 ( self , global_x ): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0","title":"LinearMap"},{"location":"module_domain_map/#domain_map.LinearMap.d2local_dglobal2","text":"The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The second derivative of global2local in the passed point. Source code in src/domain_map.py 126 127 128 129 130 131 132 133 134 135 136 137 def d2local_dglobal2 ( self , global_x ): \"\"\" The second derivative of local coordinates with respect to global coordinates. Obtained by computing the second derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The second derivative of `global2local` in the passed point. \"\"\" return 0.0","title":"d2local_dglobal2"},{"location":"module_domain_map/#domain_map.LinearMap.dlocal_dglobal","text":"The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of global2local Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The derivative of global2local in the passed point. Source code in src/domain_map.py 113 114 115 116 117 118 119 120 121 122 123 124 def dlocal_dglobal ( self , global_x ): \"\"\" The derivative of local coordinates with respect to global coordinates. Obtained by computing the derivative of `global2local` Parameters: global_x (float): The global domain point. Returns: (float): The derivative of `global2local` in the passed point. \"\"\" return 2.0 / ( self . global_end - self . global_start )","title":"dlocal_dglobal"},{"location":"module_domain_map/#domain_map.LinearMap.global2local","text":"Converts a point in global domain to local domain. Parameters: Name Type Description Default global_x float The global domain point. required Returns: Type Description float The corresponding local domain point. Source code in src/domain_map.py 101 102 103 104 105 106 107 108 109 110 111 def global2local ( self , global_x ): \"\"\" Converts a point in global domain to local domain. Parameters: global_x (float): The global domain point. Returns: (float): The corresponding local domain point. \"\"\" return ( self . global_start + self . global_end - 2.0 * global_x ) / ( self . global_start - self . global_end )","title":"global2local"},{"location":"module_domain_map/#domain_map.LinearMap.local2global","text":"Converts a point in local domain to global domain. Parameters: Name Type Description Default local_X float The local domain point. required Returns: Type Description float The corresponding global domain point. Source code in src/domain_map.py 89 90 91 92 93 94 95 96 97 98 99 def local2global ( self , local_X ): \"\"\" Converts a point in local domain to global domain. Parameters: local_X (float): The local domain point. Returns: (float): The corresponding global domain point. \"\"\" return ( self . global_start + self . global_end + ( self . global_end - self . global_start ) * local_X ) / 2.0","title":"local2global"},{"location":"module_draw_and_plot/","text":"Module draw_and_plot Draws quantum circuits and plot trained functions. draw_circuit ( output_name , circuit , num_qubits , * args ) Draws a quantum circuit. Parameters: Name Type Description Default output_name str The folder where the plot will be created. required circuit quantum circuit function The quantum circuit to draw. required num_qubits int The number of qubits in the circuit. required args any Extra arguments for matplotlib. () Source code in src/draw_and_plot.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def draw_circuit ( output_name : str , circuit , num_qubits , * args ): \"\"\" Draws a quantum circuit. Parameters: output_name (str): The folder where the plot will be created. circuit (quantum circuit function): The quantum circuit to draw. num_qubits (int): The number of qubits in the circuit. args (any): Extra arguments for matplotlib. \"\"\" fig_name = \"model.pdf\" fig_path = os . path . join ( output_name , fig_name ) if not os . path . exists ( fig_path ): logger . info ( f \"Drawing circuit image { fig_name } \" ) plt . close ( \"all\" ) device = qml . device ( \"default.qubit\" , wires = num_qubits , shots = None ) node = qml . QNode ( circuit , device ) fig , _ = qml . draw_mpl ( node )( * args ) fig . savefig ( fig_path ) plot_cost ( output_name , iterations , cost_data ) Plots a cost function Parameters: Name Type Description Default output_name str The folder where the plot will be created. required iterations array List of iteration indices in the cost data. required cost_data array Cost values at each iteration index. required Source code in src/draw_and_plot.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def plot_cost ( output_name : str , iterations , cost_data ): \"\"\" Plots a cost function Parameters: output_name (str): The folder where the plot will be created. iterations (array): List of iteration indices in the cost data. cost_data (array): Cost values at each iteration index. \"\"\" fig_name = \"cost.pdf\" fig_path = os . path . join ( output_name , fig_name ) logger . info ( f \"Plotting cost data\" ) plt . close ( \"all\" ) plt . plot ( iterations , cost_data , color = line_color , linewidth = line_thickness ) plt . xlabel ( \"Iterations\" , fontsize = font_size ) plt . ylabel ( \"Cost\" , fontsize = font_size ) plt . tight_layout () plt . savefig ( fig_path ) plot_trained_error ( config , ansatz , problem , weights , data , target ) Plots the function currently represented in a quantum circuit together with a target function that the circuit should have achieved. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required weights array The trained weights of the quantum circuit. required data array The input data. required target array The target data, i.e., the data the circuit should have obtained if training was perfect. required Source code in src/draw_and_plot.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def plot_trained_error ( config : cfg . ConfigData , ansatz : ans . Ansatz , problem : prob . Problem , weights , data , target ): \"\"\" Plots the function currently represented in a quantum circuit together with a target function that the circuit should have achieved. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). weights (array): The trained weights of the quantum circuit. data (array): The input data. target (array): The target data, i.e., the data the circuit should have obtained if training was perfect. \"\"\" fig_name = \"trained_error.pdf\" fig_path = os . path . join ( config . output_folder_name , fig_name ) logger . info ( f \"Plotting trained function\" ) device = qml . device ( \"default.qubit\" , wires = config . num_qubits , shots = None ) node = qml . QNode ( ansatz . ansatz , device ) f = [ node ( weights , x = problem . get_domain_map () . global2local ( x_ )) for x_ in data ] plt . close ( \"all\" ) plt . plot ( data , f , color = line_color , linewidth = line_thickness , label = \"Trained\" ) plt . plot ( data , target , color = target_color , linewidth = line_thickness , label = \"Target\" ) plt . xlabel ( \"x\" , fontsize = font_size ) plt . ylabel ( \"f(x)\" , fontsize = font_size ) plt . legend ( loc = \"upper left\" ) plt . tight_layout () plt . savefig ( fig_path ) plot_trained_error_abs ( config , ansatz , problem , weights , data , target ) Plots the function currently represented in a quantum circuit and computes the absolute difference to a target function that the circuit should have achieved. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required weights array The trained weights of the quantum circuit. required data array The input data. required target array The target data, i.e., the data the circuit should have obtained if training was perfect. required Source code in src/draw_and_plot.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def plot_trained_error_abs ( config : cfg . ConfigData , ansatz : ans . Ansatz , problem : prob . Problem , weights , data , target ): \"\"\" Plots the function currently represented in a quantum circuit and computes the absolute difference to a target function that the circuit should have achieved. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). weights (array): The trained weights of the quantum circuit. data (array): The input data. target (array): The target data, i.e., the data the circuit should have obtained if training was perfect. \"\"\" fig_name = \"trained_error_abs.pdf\" fig_path = os . path . join ( config . output_folder_name , fig_name ) logger . info ( f \"Plotting trained function\" ) device = qml . device ( \"default.qubit\" , wires = config . num_qubits , shots = None ) node = qml . QNode ( ansatz . ansatz , device ) f = [ node ( weights , x = problem . get_domain_map () . global2local ( x_ )) for x_ in data ] plt . close ( \"all\" ) plt . plot ( data , np . abs ( target - f ), color = line_color , linewidth = line_thickness ) plt . xlabel ( \"x\" , fontsize = font_size ) plt . ylabel ( \"Error\" , fontsize = font_size ) plt . tight_layout () plt . savefig ( fig_path ) plot_trained_function ( config , ansatz , problem , weights , data ) Plots the function currently represented in a quantum circuit. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required weights array The trained weights of the quantum circuit. required data array The input domain data. required Source code in src/draw_and_plot.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def plot_trained_function ( config : cfg . ConfigData , ansatz : ans . Ansatz , problem : prob . Problem , weights , data ): \"\"\" Plots the function currently represented in a quantum circuit. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). weights (array): The trained weights of the quantum circuit. data (array): The input domain data. \"\"\" fig_name = \"trained.pdf\" fig_path = os . path . join ( config . output_folder_name , fig_name ) logger . info ( f \"Plotting trained function\" ) device = qml . device ( \"default.qubit\" , wires = config . num_qubits , shots = None ) node = qml . QNode ( ansatz . ansatz , device ) f = [ node ( weights , x = problem . get_domain_map () . global2local ( x_ )) for x_ in data ] plt . close ( \"all\" ) plt . plot ( data , f , color = line_color , linewidth = line_thickness ) plt . xlabel ( \"x\" , fontsize = font_size ) plt . ylabel ( \"f(x)\" , fontsize = font_size ) plt . tight_layout () plt . savefig ( fig_path ) recover_and_plot ( output_name , config , ansatz , problem , data , target ) Recovers training data from an ADIOS2 file and creates the relevant plots from it. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required data array The input data. required target array The target data, i.e., the data the circuit should have obtained if training was perfect. required Source code in src/draw_and_plot.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def recover_and_plot ( output_name : str , config : cfg . ConfigData , ansatz : ans . Ansatz , problem : prob . Problem , data , target ): \"\"\" Recovers training data from an ADIOS2 file and creates the relevant plots from it. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). data (array): The input data. target (array): The target data, i.e., the data the circuit should have obtained if training was perfect. \"\"\" # Find all .bp files file_list = list ( filter ( lambda x : os . path . splitext ( x )[ 1 ] == \".bp\" , os . listdir ( config . output_folder_name ) ) ) if len ( file_list ) == 0 : logger . error ( f \"Unable to find bp files to recover from in { config . output_folder_name } \" ) exit ( 1 ) # Recover cost iterations = [] cost_data = [] for file in file_list : file_path = os . path . join ( output_name , file ) logger . info ( f \"Recovering cost data from checkpoint file { file_path } \" ) with adios2 . FileReader ( file_path ) as s : attrs = s . available_attributes () vars = s . available_variables () steps = int ( vars [ \"weights\" ][ \"AvailableStepsCount\" ]) first_iter = int ( attrs [ \"first_iter\" ][ \"Value\" ]) # cost in all steps costs = s . read ( \"cost\" , step_selection = [ 0 , steps ]) for i in range ( len ( costs )): iterations . append ( first_iter + i ) cost_data . append ( costs [ i ]) # Recover the weights of the last iteration of the last checkpoint file weights = None with adios2 . FileReader ( file_path ) as s : vars = s . available_variables () steps = int ( vars [ \"weights\" ][ \"AvailableStepsCount\" ]) logger . info ( f \"Recovering weight data from checkpoint file { file_path } \" ) weights = np . array ( s . read ( \"weights\" , step_selection = [ steps - 1 , 1 ]), requires_grad = True ) plot_cost ( output_name , iterations , cost_data ) plot_trained_function ( output_name , config , ansatz , problem , weights , data ) if target is not None : plot_trained_error ( output_name , config , ansatz , problem , weights , data , target ) plot_trained_error_abs ( output_name , config , ansatz , problem , weights , data , target )","title":"draw_and_plot"},{"location":"module_draw_and_plot/#module-draw_and_plot","text":"Draws quantum circuits and plot trained functions.","title":"Module draw_and_plot"},{"location":"module_draw_and_plot/#draw_and_plot.draw_circuit","text":"Draws a quantum circuit. Parameters: Name Type Description Default output_name str The folder where the plot will be created. required circuit quantum circuit function The quantum circuit to draw. required num_qubits int The number of qubits in the circuit. required args any Extra arguments for matplotlib. () Source code in src/draw_and_plot.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def draw_circuit ( output_name : str , circuit , num_qubits , * args ): \"\"\" Draws a quantum circuit. Parameters: output_name (str): The folder where the plot will be created. circuit (quantum circuit function): The quantum circuit to draw. num_qubits (int): The number of qubits in the circuit. args (any): Extra arguments for matplotlib. \"\"\" fig_name = \"model.pdf\" fig_path = os . path . join ( output_name , fig_name ) if not os . path . exists ( fig_path ): logger . info ( f \"Drawing circuit image { fig_name } \" ) plt . close ( \"all\" ) device = qml . device ( \"default.qubit\" , wires = num_qubits , shots = None ) node = qml . QNode ( circuit , device ) fig , _ = qml . draw_mpl ( node )( * args ) fig . savefig ( fig_path )","title":"draw_circuit"},{"location":"module_draw_and_plot/#draw_and_plot.plot_cost","text":"Plots a cost function Parameters: Name Type Description Default output_name str The folder where the plot will be created. required iterations array List of iteration indices in the cost data. required cost_data array Cost values at each iteration index. required Source code in src/draw_and_plot.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def plot_cost ( output_name : str , iterations , cost_data ): \"\"\" Plots a cost function Parameters: output_name (str): The folder where the plot will be created. iterations (array): List of iteration indices in the cost data. cost_data (array): Cost values at each iteration index. \"\"\" fig_name = \"cost.pdf\" fig_path = os . path . join ( output_name , fig_name ) logger . info ( f \"Plotting cost data\" ) plt . close ( \"all\" ) plt . plot ( iterations , cost_data , color = line_color , linewidth = line_thickness ) plt . xlabel ( \"Iterations\" , fontsize = font_size ) plt . ylabel ( \"Cost\" , fontsize = font_size ) plt . tight_layout () plt . savefig ( fig_path )","title":"plot_cost"},{"location":"module_draw_and_plot/#draw_and_plot.plot_trained_error","text":"Plots the function currently represented in a quantum circuit together with a target function that the circuit should have achieved. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required weights array The trained weights of the quantum circuit. required data array The input data. required target array The target data, i.e., the data the circuit should have obtained if training was perfect. required Source code in src/draw_and_plot.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def plot_trained_error ( config : cfg . ConfigData , ansatz : ans . Ansatz , problem : prob . Problem , weights , data , target ): \"\"\" Plots the function currently represented in a quantum circuit together with a target function that the circuit should have achieved. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). weights (array): The trained weights of the quantum circuit. data (array): The input data. target (array): The target data, i.e., the data the circuit should have obtained if training was perfect. \"\"\" fig_name = \"trained_error.pdf\" fig_path = os . path . join ( config . output_folder_name , fig_name ) logger . info ( f \"Plotting trained function\" ) device = qml . device ( \"default.qubit\" , wires = config . num_qubits , shots = None ) node = qml . QNode ( ansatz . ansatz , device ) f = [ node ( weights , x = problem . get_domain_map () . global2local ( x_ )) for x_ in data ] plt . close ( \"all\" ) plt . plot ( data , f , color = line_color , linewidth = line_thickness , label = \"Trained\" ) plt . plot ( data , target , color = target_color , linewidth = line_thickness , label = \"Target\" ) plt . xlabel ( \"x\" , fontsize = font_size ) plt . ylabel ( \"f(x)\" , fontsize = font_size ) plt . legend ( loc = \"upper left\" ) plt . tight_layout () plt . savefig ( fig_path )","title":"plot_trained_error"},{"location":"module_draw_and_plot/#draw_and_plot.plot_trained_error_abs","text":"Plots the function currently represented in a quantum circuit and computes the absolute difference to a target function that the circuit should have achieved. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required weights array The trained weights of the quantum circuit. required data array The input data. required target array The target data, i.e., the data the circuit should have obtained if training was perfect. required Source code in src/draw_and_plot.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def plot_trained_error_abs ( config : cfg . ConfigData , ansatz : ans . Ansatz , problem : prob . Problem , weights , data , target ): \"\"\" Plots the function currently represented in a quantum circuit and computes the absolute difference to a target function that the circuit should have achieved. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). weights (array): The trained weights of the quantum circuit. data (array): The input data. target (array): The target data, i.e., the data the circuit should have obtained if training was perfect. \"\"\" fig_name = \"trained_error_abs.pdf\" fig_path = os . path . join ( config . output_folder_name , fig_name ) logger . info ( f \"Plotting trained function\" ) device = qml . device ( \"default.qubit\" , wires = config . num_qubits , shots = None ) node = qml . QNode ( ansatz . ansatz , device ) f = [ node ( weights , x = problem . get_domain_map () . global2local ( x_ )) for x_ in data ] plt . close ( \"all\" ) plt . plot ( data , np . abs ( target - f ), color = line_color , linewidth = line_thickness ) plt . xlabel ( \"x\" , fontsize = font_size ) plt . ylabel ( \"Error\" , fontsize = font_size ) plt . tight_layout () plt . savefig ( fig_path )","title":"plot_trained_error_abs"},{"location":"module_draw_and_plot/#draw_and_plot.plot_trained_function","text":"Plots the function currently represented in a quantum circuit. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required weights array The trained weights of the quantum circuit. required data array The input domain data. required Source code in src/draw_and_plot.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def plot_trained_function ( config : cfg . ConfigData , ansatz : ans . Ansatz , problem : prob . Problem , weights , data ): \"\"\" Plots the function currently represented in a quantum circuit. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). weights (array): The trained weights of the quantum circuit. data (array): The input domain data. \"\"\" fig_name = \"trained.pdf\" fig_path = os . path . join ( config . output_folder_name , fig_name ) logger . info ( f \"Plotting trained function\" ) device = qml . device ( \"default.qubit\" , wires = config . num_qubits , shots = None ) node = qml . QNode ( ansatz . ansatz , device ) f = [ node ( weights , x = problem . get_domain_map () . global2local ( x_ )) for x_ in data ] plt . close ( \"all\" ) plt . plot ( data , f , color = line_color , linewidth = line_thickness ) plt . xlabel ( \"x\" , fontsize = font_size ) plt . ylabel ( \"f(x)\" , fontsize = font_size ) plt . tight_layout () plt . savefig ( fig_path )","title":"plot_trained_function"},{"location":"module_draw_and_plot/#draw_and_plot.recover_and_plot","text":"Recovers training data from an ADIOS2 file and creates the relevant plots from it. Parameters: Name Type Description Default config ConfigData The configuration data used for training. required ansatz Ansatz The ansatz circuit trained. required problem Problem The type of problem that was solved (trained for). required data array The input data. required target array The target data, i.e., the data the circuit should have obtained if training was perfect. required Source code in src/draw_and_plot.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def recover_and_plot ( output_name : str , config : cfg . ConfigData , ansatz : ans . Ansatz , problem : prob . Problem , data , target ): \"\"\" Recovers training data from an ADIOS2 file and creates the relevant plots from it. Parameters: config (ConfigData): The configuration data used for training. ansatz (Ansatz): The ansatz circuit trained. problem (Problem): The type of problem that was solved (trained for). data (array): The input data. target (array): The target data, i.e., the data the circuit should have obtained if training was perfect. \"\"\" # Find all .bp files file_list = list ( filter ( lambda x : os . path . splitext ( x )[ 1 ] == \".bp\" , os . listdir ( config . output_folder_name ) ) ) if len ( file_list ) == 0 : logger . error ( f \"Unable to find bp files to recover from in { config . output_folder_name } \" ) exit ( 1 ) # Recover cost iterations = [] cost_data = [] for file in file_list : file_path = os . path . join ( output_name , file ) logger . info ( f \"Recovering cost data from checkpoint file { file_path } \" ) with adios2 . FileReader ( file_path ) as s : attrs = s . available_attributes () vars = s . available_variables () steps = int ( vars [ \"weights\" ][ \"AvailableStepsCount\" ]) first_iter = int ( attrs [ \"first_iter\" ][ \"Value\" ]) # cost in all steps costs = s . read ( \"cost\" , step_selection = [ 0 , steps ]) for i in range ( len ( costs )): iterations . append ( first_iter + i ) cost_data . append ( costs [ i ]) # Recover the weights of the last iteration of the last checkpoint file weights = None with adios2 . FileReader ( file_path ) as s : vars = s . available_variables () steps = int ( vars [ \"weights\" ][ \"AvailableStepsCount\" ]) logger . info ( f \"Recovering weight data from checkpoint file { file_path } \" ) weights = np . array ( s . read ( \"weights\" , step_selection = [ steps - 1 , 1 ]), requires_grad = True ) plot_cost ( output_name , iterations , cost_data ) plot_trained_function ( output_name , config , ansatz , problem , weights , data ) if target is not None : plot_trained_error ( output_name , config , ansatz , problem , weights , data , target ) plot_trained_error_abs ( output_name , config , ansatz , problem , weights , data , target )","title":"recover_and_plot"},{"location":"module_function_fitting/","text":"Module function_fitting A problem type defined by training a quantum circuit to fit a target function. FitToFunction Bases: Problem Defines a function fitting problem for the quantum circuit to solve. Source code in src/function_fitting.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class FitToFunction ( prb . Problem ): \"\"\" Defines a function fitting problem for the quantum circuit to solve. \"\"\" def __init__ ( self , x0 : float , xf : float , x , optimizer : str ): \"\"\" Initializes the problem object Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. x (array): List of input points in the[x0, xf] range optimizer (str): Name of the optimizer library to use. \"\"\" self . map = dm . LinearMap ( x0 , xf ) self . target = f_numpy ( x ) if optimizer == \"numpy\" : self . f = f_numpy elif optimizer == \"torch\" : self . f = f_torch else : print ( f \"Unrecognized optimizer \\\" { optimizer } \\\" \" ) exit ( 1 ) def get_domain_map ( self ): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self . map def cost_pointwise ( self , node , weights , x ): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" X = self . map . global2local ( x ) Y = node ( weights , x = X ) y = self . f ( x ) return ( Y - y ) def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" s = sum ( self . cost_pointwise ( node , weights , x ) ** 2 for x in data ) return s / N __init__ ( x0 , xf , x , optimizer ) Initializes the problem object Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. x (array): List of input points in the[x0, xf] range optimizer (str): Name of the optimizer library to use. Source code in src/function_fitting.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def __init__ ( self , x0 : float , xf : float , x , optimizer : str ): \"\"\" Initializes the problem object Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. x (array): List of input points in the[x0, xf] range optimizer (str): Name of the optimizer library to use. \"\"\" self . map = dm . LinearMap ( x0 , xf ) self . target = f_numpy ( x ) if optimizer == \"numpy\" : self . f = f_numpy elif optimizer == \"torch\" : self . f = f_torch else : print ( f \"Unrecognized optimizer \\\" { optimizer } \\\" \" ) exit ( 1 ) cost ( node , weights , data , N ) Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/function_fitting.py 82 83 84 85 86 87 88 89 90 91 92 93 def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" s = sum ( self . cost_pointwise ( node , weights , x ) ** 2 for x in data ) return s / N cost_pointwise ( node , weights , x ) Returns the cost function of the problem at each point in the input domain. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required x float The point where to comput the cost function. required Source code in src/function_fitting.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def cost_pointwise ( self , node , weights , x ): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" X = self . map . global2local ( x ) Y = node ( weights , x = X ) y = self . f ( x ) return ( Y - y ) get_domain_map () Returns: Type Description DomainMap The linear domain map used in the problem. Source code in src/function_fitting.py 59 60 61 62 63 64 def get_domain_map ( self ): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self . map f_numpy ( x ) The target function, using the torch library. Parameters: Name Type Description Default x float the point where to evaluate the function. required Source code in src/function_fitting.py 23 24 25 26 27 28 29 30 def f_numpy ( x ): \"\"\" The target function, using the `torch` library. Parameters: x (float): the point where to evaluate the function. \"\"\" return np . exp ( x * np . cos ( 3.0 * np . pi * x )) / 2.0 f_torch ( x ) The target function, using the torch library. Parameters: Name Type Description Default x float the point where to evaluate the function. required Source code in src/function_fitting.py 13 14 15 16 17 18 19 20 def f_torch ( x ): \"\"\" The target function, using the `torch` library. Parameters: x (float): the point where to evaluate the function. \"\"\" return torch . exp ( x * torch . cos ( 3.0 * torch . pi * x )) / 2.0","title":"function_fitting"},{"location":"module_function_fitting/#module-function_fitting","text":"A problem type defined by training a quantum circuit to fit a target function.","title":"Module function_fitting"},{"location":"module_function_fitting/#function_fitting.FitToFunction","text":"Bases: Problem Defines a function fitting problem for the quantum circuit to solve. Source code in src/function_fitting.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class FitToFunction ( prb . Problem ): \"\"\" Defines a function fitting problem for the quantum circuit to solve. \"\"\" def __init__ ( self , x0 : float , xf : float , x , optimizer : str ): \"\"\" Initializes the problem object Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. x (array): List of input points in the[x0, xf] range optimizer (str): Name of the optimizer library to use. \"\"\" self . map = dm . LinearMap ( x0 , xf ) self . target = f_numpy ( x ) if optimizer == \"numpy\" : self . f = f_numpy elif optimizer == \"torch\" : self . f = f_torch else : print ( f \"Unrecognized optimizer \\\" { optimizer } \\\" \" ) exit ( 1 ) def get_domain_map ( self ): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self . map def cost_pointwise ( self , node , weights , x ): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" X = self . map . global2local ( x ) Y = node ( weights , x = X ) y = self . f ( x ) return ( Y - y ) def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" s = sum ( self . cost_pointwise ( node , weights , x ) ** 2 for x in data ) return s / N","title":"FitToFunction"},{"location":"module_function_fitting/#function_fitting.FitToFunction.__init__","text":"Initializes the problem object Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. x (array): List of input points in the[x0, xf] range optimizer (str): Name of the optimizer library to use. Source code in src/function_fitting.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def __init__ ( self , x0 : float , xf : float , x , optimizer : str ): \"\"\" Initializes the problem object Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. x (array): List of input points in the[x0, xf] range optimizer (str): Name of the optimizer library to use. \"\"\" self . map = dm . LinearMap ( x0 , xf ) self . target = f_numpy ( x ) if optimizer == \"numpy\" : self . f = f_numpy elif optimizer == \"torch\" : self . f = f_torch else : print ( f \"Unrecognized optimizer \\\" { optimizer } \\\" \" ) exit ( 1 )","title":"__init__"},{"location":"module_function_fitting/#function_fitting.FitToFunction.cost","text":"Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/function_fitting.py 82 83 84 85 86 87 88 89 90 91 92 93 def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" s = sum ( self . cost_pointwise ( node , weights , x ) ** 2 for x in data ) return s / N","title":"cost"},{"location":"module_function_fitting/#function_fitting.FitToFunction.cost_pointwise","text":"Returns the cost function of the problem at each point in the input domain. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required x float The point where to comput the cost function. required Source code in src/function_fitting.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def cost_pointwise ( self , node , weights , x ): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" X = self . map . global2local ( x ) Y = node ( weights , x = X ) y = self . f ( x ) return ( Y - y )","title":"cost_pointwise"},{"location":"module_function_fitting/#function_fitting.FitToFunction.get_domain_map","text":"Returns: Type Description DomainMap The linear domain map used in the problem. Source code in src/function_fitting.py 59 60 61 62 63 64 def get_domain_map ( self ): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self . map","title":"get_domain_map"},{"location":"module_function_fitting/#function_fitting.f_numpy","text":"The target function, using the torch library. Parameters: Name Type Description Default x float the point where to evaluate the function. required Source code in src/function_fitting.py 23 24 25 26 27 28 29 30 def f_numpy ( x ): \"\"\" The target function, using the `torch` library. Parameters: x (float): the point where to evaluate the function. \"\"\" return np . exp ( x * np . cos ( 3.0 * np . pi * x )) / 2.0","title":"f_numpy"},{"location":"module_function_fitting/#function_fitting.f_torch","text":"The target function, using the torch library. Parameters: Name Type Description Default x float the point where to evaluate the function. required Source code in src/function_fitting.py 13 14 15 16 17 18 19 20 def f_torch ( x ): \"\"\" The target function, using the `torch` library. Parameters: x (float): the point where to evaluate the function. \"\"\" return torch . exp ( x * torch . cos ( 3.0 * torch . pi * x )) / 2.0","title":"f_torch"},{"location":"module_hagen_poiseuille/","text":"Module hagen_poiseuille A problem type defined by training a quantum circuit to solve the Hagen-Poiseuille ODE. HagenPoiseuille Bases: Problem Solves the Hagen-Poiseuille equation, as defined here . Source code in src/hagen_poiseuille.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class HagenPoiseuille ( prb . Problem ): \"\"\" Solves the Hagen-Poiseuille equation, as defined [here](https://en.wikipedia.org/wiki/Hagen%E2%80%93Poiseuille_equation). \"\"\" def __init__ ( self , x0 : float , xf : float , G : float , R : float , mu : float ): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self . map = dm . LinearMap ( x0 , xf ) self . G = G self . R = R self . mu = mu def get_domain_map ( self ): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self . map def cost_int_pointwise ( self , node , weights , x ): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self . map . global2local ( x ) # Compute derivatives in local space l_dfdX = qd . df ( node , weights , x = X ) l_d2fdX2 = qd . d2f ( node , weights , x = X ) # Compute jacobians dldg = self . map . dlocal_dglobal ( x ) d2ldg2 = self . map . d2local_dglobal2 ( x ) # Compute derivatives in global space g_dfdx = dldg * l_dfdX g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return ( g_d2fdx2 + self . G / self . mu ) * x + g_dfdx def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = ( node ( weights , x = self . map . global2local ( self . map . global_start )) - self . G * self . R ** 2 / ( 4.0 * self . mu )) ** 2 bc_r = ( node ( weights , x = self . map . global2local ( self . map . global_end ))) ** 2 bc_d = ( qd . df ( node , weights , x = self . map . global2local ( self . map . global_start ))) ** 2 # Interior cost int_cost = sum ( self . cost_int_pointwise ( node , weights , x ) ** 2 for x in data ) return ( bc_l + bc_r + bc_d + int_cost ) / N __init__ ( x0 , xf , G , R , mu ) Initializes the problem object. Parameters: Name Type Description Default x0 float Left boundary of the domain. required xf float Righr boundary of the domain. required G float Hagen Poiseuille G parameter. required R float Hagen Poiseuille R parameter. required mu float Hagen Poiseuille mu parameter. required Source code in src/hagen_poiseuille.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , x0 : float , xf : float , G : float , R : float , mu : float ): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self . map = dm . LinearMap ( x0 , xf ) self . G = G self . R = R self . mu = mu cost ( node , weights , data , N ) Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/hagen_poiseuille.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = ( node ( weights , x = self . map . global2local ( self . map . global_start )) - self . G * self . R ** 2 / ( 4.0 * self . mu )) ** 2 bc_r = ( node ( weights , x = self . map . global2local ( self . map . global_end ))) ** 2 bc_d = ( qd . df ( node , weights , x = self . map . global2local ( self . map . global_start ))) ** 2 # Interior cost int_cost = sum ( self . cost_int_pointwise ( node , weights , x ) ** 2 for x in data ) return ( bc_l + bc_r + bc_d + int_cost ) / N cost_int_pointwise ( node , weights , x ) Returns the cost function of the problem at each point in the input domain. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required x float The point where to comput the cost function. required Source code in src/hagen_poiseuille.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def cost_int_pointwise ( self , node , weights , x ): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self . map . global2local ( x ) # Compute derivatives in local space l_dfdX = qd . df ( node , weights , x = X ) l_d2fdX2 = qd . d2f ( node , weights , x = X ) # Compute jacobians dldg = self . map . dlocal_dglobal ( x ) d2ldg2 = self . map . d2local_dglobal2 ( x ) # Compute derivatives in global space g_dfdx = dldg * l_dfdX g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return ( g_d2fdx2 + self . G / self . mu ) * x + g_dfdx get_domain_map () Returns: Type Description DomainMap The linear domain map used in the problem. Source code in src/hagen_poiseuille.py 32 33 34 35 36 37 def get_domain_map ( self ): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self . map PlaneHagenPoiseuille Bases: Problem Solves the Hagen-Poiseuille equation between to infinite plates as defined here . Source code in src/hagen_poiseuille.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 class PlaneHagenPoiseuille ( prb . Problem ): \"\"\" Solves the Hagen-Poiseuille equation between to infinite plates as defined [here](https://en.wikipedia.org/wiki/Hagen%E2%80%93Poiseuille_equation). \"\"\" def __init__ ( self , x0 : float , xf : float , x , G : float , R : float , mu : float ): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self . map = dm . LinearMap ( x0 , xf ) self . G = G self . R = R self . mu = mu self . target = self . G / ( 2 * self . mu ) * x * ( xf - x ) def get_domain_map ( self ): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self . map def cost_int_pointwise ( self , node , weights , x ): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self . map . global2local ( x ) # Compute derivatives in local space l_dfdX = qd . df ( node , weights , x = X ) l_d2fdX2 = qd . d2f ( node , weights , x = X ) # Compute jacobians dldg = self . map . dlocal_dglobal ( x ) d2ldg2 = self . map . d2local_dglobal2 ( x ) # Compute derivatives in global space g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return g_d2fdx2 + self . G / self . mu def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = ( node ( weights , x = self . map . global2local ( self . map . global_start ))) ** 2 bc_r = ( node ( weights , x = self . map . global2local ( self . map . global_end ))) ** 2 # Interior cost int_cost = sum ( self . cost_int_pointwise ( node , weights , x ) ** 2 for x in data ) return ( bc_l + bc_r + int_cost ) / N __init__ ( x0 , xf , x , G , R , mu ) Initializes the problem object. Parameters: Name Type Description Default x0 float Left boundary of the domain. required xf float Righr boundary of the domain. required G float Hagen Poiseuille G parameter. required R float Hagen Poiseuille R parameter. required mu float Hagen Poiseuille mu parameter. required Source code in src/hagen_poiseuille.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __init__ ( self , x0 : float , xf : float , x , G : float , R : float , mu : float ): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self . map = dm . LinearMap ( x0 , xf ) self . G = G self . R = R self . mu = mu self . target = self . G / ( 2 * self . mu ) * x * ( xf - x ) cost ( node , weights , data , N ) Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/hagen_poiseuille.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = ( node ( weights , x = self . map . global2local ( self . map . global_start ))) ** 2 bc_r = ( node ( weights , x = self . map . global2local ( self . map . global_end ))) ** 2 # Interior cost int_cost = sum ( self . cost_int_pointwise ( node , weights , x ) ** 2 for x in data ) return ( bc_l + bc_r + int_cost ) / N cost_int_pointwise ( node , weights , x ) Returns the cost function of the problem at each point in the input domain. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required x float The point where to comput the cost function. required Source code in src/hagen_poiseuille.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def cost_int_pointwise ( self , node , weights , x ): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self . map . global2local ( x ) # Compute derivatives in local space l_dfdX = qd . df ( node , weights , x = X ) l_d2fdX2 = qd . d2f ( node , weights , x = X ) # Compute jacobians dldg = self . map . dlocal_dglobal ( x ) d2ldg2 = self . map . d2local_dglobal2 ( x ) # Compute derivatives in global space g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return g_d2fdx2 + self . G / self . mu get_domain_map () Returns: Type Description DomainMap The linear domain map used in the problem. Source code in src/hagen_poiseuille.py 113 114 115 116 117 118 def get_domain_map ( self ): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self . map","title":"hagen_poiseuille"},{"location":"module_hagen_poiseuille/#module-hagen_poiseuille","text":"A problem type defined by training a quantum circuit to solve the Hagen-Poiseuille ODE.","title":"Module hagen_poiseuille"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.HagenPoiseuille","text":"Bases: Problem Solves the Hagen-Poiseuille equation, as defined here . Source code in src/hagen_poiseuille.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class HagenPoiseuille ( prb . Problem ): \"\"\" Solves the Hagen-Poiseuille equation, as defined [here](https://en.wikipedia.org/wiki/Hagen%E2%80%93Poiseuille_equation). \"\"\" def __init__ ( self , x0 : float , xf : float , G : float , R : float , mu : float ): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self . map = dm . LinearMap ( x0 , xf ) self . G = G self . R = R self . mu = mu def get_domain_map ( self ): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self . map def cost_int_pointwise ( self , node , weights , x ): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self . map . global2local ( x ) # Compute derivatives in local space l_dfdX = qd . df ( node , weights , x = X ) l_d2fdX2 = qd . d2f ( node , weights , x = X ) # Compute jacobians dldg = self . map . dlocal_dglobal ( x ) d2ldg2 = self . map . d2local_dglobal2 ( x ) # Compute derivatives in global space g_dfdx = dldg * l_dfdX g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return ( g_d2fdx2 + self . G / self . mu ) * x + g_dfdx def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = ( node ( weights , x = self . map . global2local ( self . map . global_start )) - self . G * self . R ** 2 / ( 4.0 * self . mu )) ** 2 bc_r = ( node ( weights , x = self . map . global2local ( self . map . global_end ))) ** 2 bc_d = ( qd . df ( node , weights , x = self . map . global2local ( self . map . global_start ))) ** 2 # Interior cost int_cost = sum ( self . cost_int_pointwise ( node , weights , x ) ** 2 for x in data ) return ( bc_l + bc_r + bc_d + int_cost ) / N","title":"HagenPoiseuille"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.HagenPoiseuille.__init__","text":"Initializes the problem object. Parameters: Name Type Description Default x0 float Left boundary of the domain. required xf float Righr boundary of the domain. required G float Hagen Poiseuille G parameter. required R float Hagen Poiseuille R parameter. required mu float Hagen Poiseuille mu parameter. required Source code in src/hagen_poiseuille.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , x0 : float , xf : float , G : float , R : float , mu : float ): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self . map = dm . LinearMap ( x0 , xf ) self . G = G self . R = R self . mu = mu","title":"__init__"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.HagenPoiseuille.cost","text":"Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/hagen_poiseuille.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = ( node ( weights , x = self . map . global2local ( self . map . global_start )) - self . G * self . R ** 2 / ( 4.0 * self . mu )) ** 2 bc_r = ( node ( weights , x = self . map . global2local ( self . map . global_end ))) ** 2 bc_d = ( qd . df ( node , weights , x = self . map . global2local ( self . map . global_start ))) ** 2 # Interior cost int_cost = sum ( self . cost_int_pointwise ( node , weights , x ) ** 2 for x in data ) return ( bc_l + bc_r + bc_d + int_cost ) / N","title":"cost"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.HagenPoiseuille.cost_int_pointwise","text":"Returns the cost function of the problem at each point in the input domain. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required x float The point where to comput the cost function. required Source code in src/hagen_poiseuille.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def cost_int_pointwise ( self , node , weights , x ): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self . map . global2local ( x ) # Compute derivatives in local space l_dfdX = qd . df ( node , weights , x = X ) l_d2fdX2 = qd . d2f ( node , weights , x = X ) # Compute jacobians dldg = self . map . dlocal_dglobal ( x ) d2ldg2 = self . map . d2local_dglobal2 ( x ) # Compute derivatives in global space g_dfdx = dldg * l_dfdX g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return ( g_d2fdx2 + self . G / self . mu ) * x + g_dfdx","title":"cost_int_pointwise"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.HagenPoiseuille.get_domain_map","text":"Returns: Type Description DomainMap The linear domain map used in the problem. Source code in src/hagen_poiseuille.py 32 33 34 35 36 37 def get_domain_map ( self ): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self . map","title":"get_domain_map"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.PlaneHagenPoiseuille","text":"Bases: Problem Solves the Hagen-Poiseuille equation between to infinite plates as defined here . Source code in src/hagen_poiseuille.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 class PlaneHagenPoiseuille ( prb . Problem ): \"\"\" Solves the Hagen-Poiseuille equation between to infinite plates as defined [here](https://en.wikipedia.org/wiki/Hagen%E2%80%93Poiseuille_equation). \"\"\" def __init__ ( self , x0 : float , xf : float , x , G : float , R : float , mu : float ): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self . map = dm . LinearMap ( x0 , xf ) self . G = G self . R = R self . mu = mu self . target = self . G / ( 2 * self . mu ) * x * ( xf - x ) def get_domain_map ( self ): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self . map def cost_int_pointwise ( self , node , weights , x ): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self . map . global2local ( x ) # Compute derivatives in local space l_dfdX = qd . df ( node , weights , x = X ) l_d2fdX2 = qd . d2f ( node , weights , x = X ) # Compute jacobians dldg = self . map . dlocal_dglobal ( x ) d2ldg2 = self . map . d2local_dglobal2 ( x ) # Compute derivatives in global space g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return g_d2fdx2 + self . G / self . mu def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = ( node ( weights , x = self . map . global2local ( self . map . global_start ))) ** 2 bc_r = ( node ( weights , x = self . map . global2local ( self . map . global_end ))) ** 2 # Interior cost int_cost = sum ( self . cost_int_pointwise ( node , weights , x ) ** 2 for x in data ) return ( bc_l + bc_r + int_cost ) / N","title":"PlaneHagenPoiseuille"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.PlaneHagenPoiseuille.__init__","text":"Initializes the problem object. Parameters: Name Type Description Default x0 float Left boundary of the domain. required xf float Righr boundary of the domain. required G float Hagen Poiseuille G parameter. required R float Hagen Poiseuille R parameter. required mu float Hagen Poiseuille mu parameter. required Source code in src/hagen_poiseuille.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __init__ ( self , x0 : float , xf : float , x , G : float , R : float , mu : float ): \"\"\" Initializes the problem object. Parameters: x0 (float): Left boundary of the domain. xf (float): Righr boundary of the domain. G (float): Hagen Poiseuille `G` parameter. R (float): Hagen Poiseuille `R` parameter. mu (float): Hagen Poiseuille `mu` parameter. \"\"\" self . map = dm . LinearMap ( x0 , xf ) self . G = G self . R = R self . mu = mu self . target = self . G / ( 2 * self . mu ) * x * ( xf - x )","title":"__init__"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.PlaneHagenPoiseuille.cost","text":"Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/hagen_poiseuille.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" # BCs bc_l = ( node ( weights , x = self . map . global2local ( self . map . global_start ))) ** 2 bc_r = ( node ( weights , x = self . map . global2local ( self . map . global_end ))) ** 2 # Interior cost int_cost = sum ( self . cost_int_pointwise ( node , weights , x ) ** 2 for x in data ) return ( bc_l + bc_r + int_cost ) / N","title":"cost"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.PlaneHagenPoiseuille.cost_int_pointwise","text":"Returns the cost function of the problem at each point in the input domain. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required x float The point where to comput the cost function. required Source code in src/hagen_poiseuille.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def cost_int_pointwise ( self , node , weights , x ): \"\"\" Returns the cost function of the problem at each point in the input domain. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. x (float): The point where to comput the cost function. \"\"\" # Get local X X = self . map . global2local ( x ) # Compute derivatives in local space l_dfdX = qd . df ( node , weights , x = X ) l_d2fdX2 = qd . d2f ( node , weights , x = X ) # Compute jacobians dldg = self . map . dlocal_dglobal ( x ) d2ldg2 = self . map . d2local_dglobal2 ( x ) # Compute derivatives in global space g_d2fdx2 = dldg * dldg * l_d2fdX2 + d2ldg2 * l_dfdX # ODE in global space return g_d2fdx2 + self . G / self . mu","title":"cost_int_pointwise"},{"location":"module_hagen_poiseuille/#hagen_poiseuille.PlaneHagenPoiseuille.get_domain_map","text":"Returns: Type Description DomainMap The linear domain map used in the problem. Source code in src/hagen_poiseuille.py 113 114 115 116 117 118 def get_domain_map ( self ): \"\"\" Returns: (DomainMap): The linear domain map used in the problem. \"\"\" return self . map","title":"get_domain_map"},{"location":"module_hp_params/","text":"Module hp_params Contains Hagen Poiseuille problem data handlers. HagenPoiseuilleParams A databag for storing the needed parameters of the Hagen-Poiseuille problem. Attributes: Name Type Description G float The Hagen-Poiseuille G value. R float The Hagen-Poiseuille R value. mu float The Hagen-Poiseuille mu value. Source code in src/hp_params.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class HagenPoiseuilleParams : \"\"\" A databag for storing the needed parameters of the Hagen-Poiseuille problem. Attributes: G (float): The Hagen-Poiseuille `G` value. R (float): The Hagen-Poiseuille `R` value. mu (float): The Hagen-Poiseuille `mu` value. \"\"\" def __init__ ( self , G , R , mu ): \"\"\" A databag for storing the needed parameters of the Hagen-Poiseuille problem. Parameters: G (float): The Hagen-Poiseuille `G` value. R (float): The Hagen-Poiseuille `R` value. mu (float): The Hagen-Poiseuille `mu` value. \"\"\" self . G = G self . R = R self . mu = mu __init__ ( G , R , mu ) A databag for storing the needed parameters of the Hagen-Poiseuille problem. Parameters: Name Type Description Default G float The Hagen-Poiseuille G value. required R float The Hagen-Poiseuille R value. required mu float The Hagen-Poiseuille mu value. required Source code in src/hp_params.py 16 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , G , R , mu ): \"\"\" A databag for storing the needed parameters of the Hagen-Poiseuille problem. Parameters: G (float): The Hagen-Poiseuille `G` value. R (float): The Hagen-Poiseuille `R` value. mu (float): The Hagen-Poiseuille `mu` value. \"\"\" self . G = G self . R = R self . mu = mu","title":"hp_params"},{"location":"module_hp_params/#module-hp_params","text":"Contains Hagen Poiseuille problem data handlers.","title":"Module hp_params"},{"location":"module_hp_params/#hp_params.HagenPoiseuilleParams","text":"A databag for storing the needed parameters of the Hagen-Poiseuille problem. Attributes: Name Type Description G float The Hagen-Poiseuille G value. R float The Hagen-Poiseuille R value. mu float The Hagen-Poiseuille mu value. Source code in src/hp_params.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class HagenPoiseuilleParams : \"\"\" A databag for storing the needed parameters of the Hagen-Poiseuille problem. Attributes: G (float): The Hagen-Poiseuille `G` value. R (float): The Hagen-Poiseuille `R` value. mu (float): The Hagen-Poiseuille `mu` value. \"\"\" def __init__ ( self , G , R , mu ): \"\"\" A databag for storing the needed parameters of the Hagen-Poiseuille problem. Parameters: G (float): The Hagen-Poiseuille `G` value. R (float): The Hagen-Poiseuille `R` value. mu (float): The Hagen-Poiseuille `mu` value. \"\"\" self . G = G self . R = R self . mu = mu","title":"HagenPoiseuilleParams"},{"location":"module_hp_params/#hp_params.HagenPoiseuilleParams.__init__","text":"A databag for storing the needed parameters of the Hagen-Poiseuille problem. Parameters: Name Type Description Default G float The Hagen-Poiseuille G value. required R float The Hagen-Poiseuille R value. required mu float The Hagen-Poiseuille mu value. required Source code in src/hp_params.py 16 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , G , R , mu ): \"\"\" A databag for storing the needed parameters of the Hagen-Poiseuille problem. Parameters: G (float): The Hagen-Poiseuille `G` value. R (float): The Hagen-Poiseuille `R` value. mu (float): The Hagen-Poiseuille `mu` value. \"\"\" self . G = G self . R = R self . mu = mu","title":"__init__"},{"location":"module_optimize/","text":"Module optimize Contains the main optimizer functionality for training circuits numpy_optimize ( out , ansatz , problem , params , config , data , random_generator ) Optimizes the quantum circuit to solve a problem using the Numpy library. Parameters: Name Type Description Default out Output The output object controlling where the training data will be saved to / recovered from. required ansatz Ansatz The trainable ansatz circuit for solving the problem. required problem Problem The problem object containing the problem type to be solved. required params OptimizerParams The configuration parameters of the optimizer. required config ConfigData The program configuration data. required data array The domain data points. required random_generator Generator A random number generator used for initializing the circuit weights. required Source code in src/optimize.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def numpy_optimize ( out : out . Output , ansatz : ans . Ansatz , problem : prb . Problem , params : op . OptimizerParams , config : cfg . ConfigData , data , random_generator ): \"\"\" Optimizes the quantum circuit to solve a problem using the Numpy library. Parameters: out (Output): The output object controlling where the training data will be saved to / recovered from. ansatz (Ansatz): The trainable ansatz circuit for solving the problem. problem (Problem): The problem object containing the problem type to be solved. params (OptimizerParams): The configuration parameters of the optimizer. config (ConfigData): The program configuration data. data (array): The domain data points. random_generator (numpy.random.Generator): A random number generator used for initializing the circuit weights. \"\"\" # Quantum device device = qml . device ( \"lightning.kokkos\" , wires = config . num_qubits , shots = None ) node = qml . QNode ( ansatz . ansatz , device , diff_method = \"adjoint\" ) # Recovery if out . recovered : first_iter = out . first_iter weights = np . array ( out . weights , requires_grad = True ) else : first_iter = 0 weights = ansatz . weights last_iter = first_iter + params . max_iters out . output_stream . write_attribute ( \"first_iter\" , first_iter ) out . output_stream . write_attribute ( \"last_iter\" , last_iter - 1 ) out . output_stream . write_attribute ( \"weights_shape\" , weights . shape ) opt = qml . AdamOptimizer ( params . step ) stopping_criteria = \"max iterations reached\" N_data = len ( data ) for i in range ( first_iter , last_iter ): if params . batch_size != 0 : batch_indices = random_generator . integers ( 1 , N_data - 2 , size = params . batch_size , endpoint = True ) batch_data = data [ batch_indices ] N_batch = params . batch_size else : batch_data = data N_batch = N_data # save, and print the current cost c = np . sqrt ( problem . cost ( node , weights , batch_data , N_batch )) out . output_stream . begin_step () out . output_stream . write ( \"iteration\" , i ) out . output_stream . write ( \"cost\" , c ) out . output_stream . write ( \"weights\" , weights . numpy (), weights . shape , [ 0 ] * len ( weights . shape ), weights . shape ) out . output_stream . end_step () if np . abs ( c ) < params . abstol : stopping_criteria = \"absolute tolerance reached\" break else : weights = opt . step ( lambda w : np . sqrt ( problem . cost ( node , w , data , N_data )), weights ) logger . info ( f \"Loss in teration { i } = { c } \" ) # Results logger . info ( \"Training done\" ) logger . info ( f \"Stopping criteria: { stopping_criteria } \" ) torch_optimize ( out , ansatz , problem , params , config , data_in , random_generator ) Optimizes the quantum circuit to solve a problem using the Torch library. Parameters: Name Type Description Default out Output The output object controlling where the training data will be saved to / recovered from. required ansatz Ansatz The trainable ansatz circuit for solving the problem. required problem Problem The problem object containing the problem type to be solved. required params OptimizerParams The configuration parameters of the optimizer. required config ConfigData The program configuration data. required data_in array The domain data points. required random_generator Generator A random number generator used for initializing the circuit weights. required Source code in src/optimize.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def torch_optimize ( out : out . Output , ansatz : ans . Ansatz , problem : prb . Problem , params : op . OptimizerParams , config : cfg . ConfigData , data_in , random_generator ): \"\"\" Optimizes the quantum circuit to solve a problem using the Torch library. Parameters: out (Output): The output object controlling where the training data will be saved to / recovered from. ansatz (Ansatz): The trainable ansatz circuit for solving the problem. problem (Problem): The problem object containing the problem type to be solved. params (OptimizerParams): The configuration parameters of the optimizer. config (ConfigData): The program configuration data. data_in (array): The domain data points. random_generator (numpy.random.Generator): A random number generator used for initializing the circuit weights. \"\"\" # Quantum device device = qml . device ( \"default.qubit\" , wires = config . num_qubits , shots = None ) node = qml . QNode ( ansatz . ansatz , device , interface = \"torch\" , diff_method = \"backprop\" ) # Recovery if out . recovered : first_iter = out . first_iter weights = torch . tensor ( out . weights , requires_grad = True , device = \"cuda\" ) else : first_iter = 0 weights = torch . tensor ( ansatz . weights , requires_grad = True , device = \"cuda\" ) last_iter = first_iter + params . max_iters out . output_stream . write_attribute ( \"first_iter\" , first_iter ) out . output_stream . write_attribute ( \"last_iter\" , last_iter - 1 ) out . output_stream . write_attribute ( \"weights_shape\" , weights . shape ) opt = torch . optim . LBFGS ([ weights ], lr = params . step ) # Adaptive LR. See # https://pytorch.org/docs/stable/generated/torch.optim.lr_scheduler.ReduceLROnPlateau.html#torch.optim.lr_scheduler.ReduceLROnPlateau sch = torch . optim . lr_scheduler . ReduceLROnPlateau ( opt , \"min\" , 0.1 , 5 , 1.0e-4 , \"rel\" , 0 , 0.0 , 1.0e-8 ) stopping_criteria = \"max iterations reached\" data = torch . tensor ( data_in , requires_grad = False , device = \"cuda\" ) N_data = len ( data ) # Optimization loop for i in range ( first_iter , last_iter ): if params . batch_size != 0 : batch_indices = random_generator . integers ( 1 , N_data - 2 , size = params . batch_size , endpoint = True ) batch_data = torch . tensor ( data [ batch_indices ], requires_grad = False , device = \"cuda\" ) N_batch = params . batch_size else : batch_data = data N_batch = N_data def torch_cost (): opt . zero_grad () c = torch . sqrt ( problem . cost ( node , weights , batch_data , N_batch )) c . backward () return c # save, and print the current cost c = torch_cost () . item () out . output_stream . begin_step () out . output_stream . write ( \"iteration\" , i ) out . output_stream . write ( \"cost\" , c ) out . output_stream . write ( \"weights\" , weights . cpu () . detach () . numpy (), weights . shape , [ 0 ] * len ( weights . shape ), weights . shape ) out . output_stream . end_step () if np . abs ( c ) < params . abstol : stopping_criteria = \"absolute tolerance reached\" break else : opt . step ( torch_cost ) sch . step ( c ) logger . info ( f \"(Loss, LR) in iteration { i } = ( { c } , { sch . get_last_lr () } )\" ) # Results logger . info ( \"Training done\" ) logger . info ( f \"Stopping criteria: { stopping_criteria } \" )","title":"optimize"},{"location":"module_optimize/#module-optimize","text":"Contains the main optimizer functionality for training circuits","title":"Module optimize"},{"location":"module_optimize/#optimize.numpy_optimize","text":"Optimizes the quantum circuit to solve a problem using the Numpy library. Parameters: Name Type Description Default out Output The output object controlling where the training data will be saved to / recovered from. required ansatz Ansatz The trainable ansatz circuit for solving the problem. required problem Problem The problem object containing the problem type to be solved. required params OptimizerParams The configuration parameters of the optimizer. required config ConfigData The program configuration data. required data array The domain data points. required random_generator Generator A random number generator used for initializing the circuit weights. required Source code in src/optimize.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def numpy_optimize ( out : out . Output , ansatz : ans . Ansatz , problem : prb . Problem , params : op . OptimizerParams , config : cfg . ConfigData , data , random_generator ): \"\"\" Optimizes the quantum circuit to solve a problem using the Numpy library. Parameters: out (Output): The output object controlling where the training data will be saved to / recovered from. ansatz (Ansatz): The trainable ansatz circuit for solving the problem. problem (Problem): The problem object containing the problem type to be solved. params (OptimizerParams): The configuration parameters of the optimizer. config (ConfigData): The program configuration data. data (array): The domain data points. random_generator (numpy.random.Generator): A random number generator used for initializing the circuit weights. \"\"\" # Quantum device device = qml . device ( \"lightning.kokkos\" , wires = config . num_qubits , shots = None ) node = qml . QNode ( ansatz . ansatz , device , diff_method = \"adjoint\" ) # Recovery if out . recovered : first_iter = out . first_iter weights = np . array ( out . weights , requires_grad = True ) else : first_iter = 0 weights = ansatz . weights last_iter = first_iter + params . max_iters out . output_stream . write_attribute ( \"first_iter\" , first_iter ) out . output_stream . write_attribute ( \"last_iter\" , last_iter - 1 ) out . output_stream . write_attribute ( \"weights_shape\" , weights . shape ) opt = qml . AdamOptimizer ( params . step ) stopping_criteria = \"max iterations reached\" N_data = len ( data ) for i in range ( first_iter , last_iter ): if params . batch_size != 0 : batch_indices = random_generator . integers ( 1 , N_data - 2 , size = params . batch_size , endpoint = True ) batch_data = data [ batch_indices ] N_batch = params . batch_size else : batch_data = data N_batch = N_data # save, and print the current cost c = np . sqrt ( problem . cost ( node , weights , batch_data , N_batch )) out . output_stream . begin_step () out . output_stream . write ( \"iteration\" , i ) out . output_stream . write ( \"cost\" , c ) out . output_stream . write ( \"weights\" , weights . numpy (), weights . shape , [ 0 ] * len ( weights . shape ), weights . shape ) out . output_stream . end_step () if np . abs ( c ) < params . abstol : stopping_criteria = \"absolute tolerance reached\" break else : weights = opt . step ( lambda w : np . sqrt ( problem . cost ( node , w , data , N_data )), weights ) logger . info ( f \"Loss in teration { i } = { c } \" ) # Results logger . info ( \"Training done\" ) logger . info ( f \"Stopping criteria: { stopping_criteria } \" )","title":"numpy_optimize"},{"location":"module_optimize/#optimize.torch_optimize","text":"Optimizes the quantum circuit to solve a problem using the Torch library. Parameters: Name Type Description Default out Output The output object controlling where the training data will be saved to / recovered from. required ansatz Ansatz The trainable ansatz circuit for solving the problem. required problem Problem The problem object containing the problem type to be solved. required params OptimizerParams The configuration parameters of the optimizer. required config ConfigData The program configuration data. required data_in array The domain data points. required random_generator Generator A random number generator used for initializing the circuit weights. required Source code in src/optimize.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def torch_optimize ( out : out . Output , ansatz : ans . Ansatz , problem : prb . Problem , params : op . OptimizerParams , config : cfg . ConfigData , data_in , random_generator ): \"\"\" Optimizes the quantum circuit to solve a problem using the Torch library. Parameters: out (Output): The output object controlling where the training data will be saved to / recovered from. ansatz (Ansatz): The trainable ansatz circuit for solving the problem. problem (Problem): The problem object containing the problem type to be solved. params (OptimizerParams): The configuration parameters of the optimizer. config (ConfigData): The program configuration data. data_in (array): The domain data points. random_generator (numpy.random.Generator): A random number generator used for initializing the circuit weights. \"\"\" # Quantum device device = qml . device ( \"default.qubit\" , wires = config . num_qubits , shots = None ) node = qml . QNode ( ansatz . ansatz , device , interface = \"torch\" , diff_method = \"backprop\" ) # Recovery if out . recovered : first_iter = out . first_iter weights = torch . tensor ( out . weights , requires_grad = True , device = \"cuda\" ) else : first_iter = 0 weights = torch . tensor ( ansatz . weights , requires_grad = True , device = \"cuda\" ) last_iter = first_iter + params . max_iters out . output_stream . write_attribute ( \"first_iter\" , first_iter ) out . output_stream . write_attribute ( \"last_iter\" , last_iter - 1 ) out . output_stream . write_attribute ( \"weights_shape\" , weights . shape ) opt = torch . optim . LBFGS ([ weights ], lr = params . step ) # Adaptive LR. See # https://pytorch.org/docs/stable/generated/torch.optim.lr_scheduler.ReduceLROnPlateau.html#torch.optim.lr_scheduler.ReduceLROnPlateau sch = torch . optim . lr_scheduler . ReduceLROnPlateau ( opt , \"min\" , 0.1 , 5 , 1.0e-4 , \"rel\" , 0 , 0.0 , 1.0e-8 ) stopping_criteria = \"max iterations reached\" data = torch . tensor ( data_in , requires_grad = False , device = \"cuda\" ) N_data = len ( data ) # Optimization loop for i in range ( first_iter , last_iter ): if params . batch_size != 0 : batch_indices = random_generator . integers ( 1 , N_data - 2 , size = params . batch_size , endpoint = True ) batch_data = torch . tensor ( data [ batch_indices ], requires_grad = False , device = \"cuda\" ) N_batch = params . batch_size else : batch_data = data N_batch = N_data def torch_cost (): opt . zero_grad () c = torch . sqrt ( problem . cost ( node , weights , batch_data , N_batch )) c . backward () return c # save, and print the current cost c = torch_cost () . item () out . output_stream . begin_step () out . output_stream . write ( \"iteration\" , i ) out . output_stream . write ( \"cost\" , c ) out . output_stream . write ( \"weights\" , weights . cpu () . detach () . numpy (), weights . shape , [ 0 ] * len ( weights . shape ), weights . shape ) out . output_stream . end_step () if np . abs ( c ) < params . abstol : stopping_criteria = \"absolute tolerance reached\" break else : opt . step ( torch_cost ) sch . step ( c ) logger . info ( f \"(Loss, LR) in iteration { i } = ( { c } , { sch . get_last_lr () } )\" ) # Results logger . info ( \"Training done\" ) logger . info ( f \"Stopping criteria: { stopping_criteria } \" )","title":"torch_optimize"},{"location":"module_optimizer_params/","text":"Module optimizer_params Contains optimizer related configurations OptimizerParams A databag for holding circuit optimizer related data. Attributes: Name Type Description max_iters float The maximun number of steps the optimizer may take. abstol float The absolute tolerence of the error function below which training stops. step float Initial step size for the optimizer algorithim. batch_size int Size of the subdata array to use for batching. If 0 , batching is disabled. Source code in src/optimizer_params.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class OptimizerParams : \"\"\" A databag for holding circuit optimizer related data. Attributes: max_iters (float): The maximun number of steps the optimizer may take. abstol (float): The absolute tolerence of the error function below which training stops. step (float): Initial step size for the optimizer algorithim. batch_size (int): Size of the subdata array to use for batching. If `0`, batching is disabled. \"\"\" def __init__ ( self , max_iters : int , abstol : float , step : float , batch_size : int ): \"\"\" Initialize the object. Parameters: max_iters (float): The maximun number of steps the optimizer may take. abstol (float): The absolute tolerence of the error function below which training stops. step (float): Initial step size for the optimizer algorithim. batch_size (int): Size of the subdata array to use for batching. If `0`, batching is disabled. \"\"\" self . max_iters = max_iters self . abstol = abstol self . step = step self . batch_size = batch_size __init__ ( max_iters , abstol , step , batch_size ) Initialize the object. Parameters: Name Type Description Default max_iters float The maximun number of steps the optimizer may take. required abstol float The absolute tolerence of the error function below which training stops. required step float Initial step size for the optimizer algorithim. required batch_size int Size of the subdata array to use for batching. If 0 , batching is disabled. required Source code in src/optimizer_params.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , max_iters : int , abstol : float , step : float , batch_size : int ): \"\"\" Initialize the object. Parameters: max_iters (float): The maximun number of steps the optimizer may take. abstol (float): The absolute tolerence of the error function below which training stops. step (float): Initial step size for the optimizer algorithim. batch_size (int): Size of the subdata array to use for batching. If `0`, batching is disabled. \"\"\" self . max_iters = max_iters self . abstol = abstol self . step = step self . batch_size = batch_size","title":"optimizer_params"},{"location":"module_optimizer_params/#module-optimizer_params","text":"Contains optimizer related configurations","title":"Module optimizer_params"},{"location":"module_optimizer_params/#optimizer_params.OptimizerParams","text":"A databag for holding circuit optimizer related data. Attributes: Name Type Description max_iters float The maximun number of steps the optimizer may take. abstol float The absolute tolerence of the error function below which training stops. step float Initial step size for the optimizer algorithim. batch_size int Size of the subdata array to use for batching. If 0 , batching is disabled. Source code in src/optimizer_params.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class OptimizerParams : \"\"\" A databag for holding circuit optimizer related data. Attributes: max_iters (float): The maximun number of steps the optimizer may take. abstol (float): The absolute tolerence of the error function below which training stops. step (float): Initial step size for the optimizer algorithim. batch_size (int): Size of the subdata array to use for batching. If `0`, batching is disabled. \"\"\" def __init__ ( self , max_iters : int , abstol : float , step : float , batch_size : int ): \"\"\" Initialize the object. Parameters: max_iters (float): The maximun number of steps the optimizer may take. abstol (float): The absolute tolerence of the error function below which training stops. step (float): Initial step size for the optimizer algorithim. batch_size (int): Size of the subdata array to use for batching. If `0`, batching is disabled. \"\"\" self . max_iters = max_iters self . abstol = abstol self . step = step self . batch_size = batch_size","title":"OptimizerParams"},{"location":"module_optimizer_params/#optimizer_params.OptimizerParams.__init__","text":"Initialize the object. Parameters: Name Type Description Default max_iters float The maximun number of steps the optimizer may take. required abstol float The absolute tolerence of the error function below which training stops. required step float Initial step size for the optimizer algorithim. required batch_size int Size of the subdata array to use for batching. If 0 , batching is disabled. required Source code in src/optimizer_params.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , max_iters : int , abstol : float , step : float , batch_size : int ): \"\"\" Initialize the object. Parameters: max_iters (float): The maximun number of steps the optimizer may take. abstol (float): The absolute tolerence of the error function below which training stops. step (float): Initial step size for the optimizer algorithim. batch_size (int): Size of the subdata array to use for batching. If `0`, batching is disabled. \"\"\" self . max_iters = max_iters self . abstol = abstol self . step = step self . batch_size = batch_size","title":"__init__"},{"location":"module_output/","text":"Module output Contains handlers for ouputting and recovering ADIOS2 training data. Output Holds a stream-writtable ADIOS2 file and creates new output files with the the correct naming convention for checkpointing. Source code in src/output.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class Output : \"\"\" Holds a stream-writtable ADIOS2 file and creates new output files with the the correct naming convention for checkpointing. \"\"\" def __init__ ( self , output_name : str , config_file : str ): \"\"\" Initializes the object Parameters: output_name (str): The output folder name where data will be stored. config_file (str): The path of the configuration file, which will be copyied to the output data folder. \"\"\" self . output_name = output_name self . config_file = os . path . join ( self . output_name , config_file ) # Create output dir if not os . path . exists ( self . output_name ): os . makedirs ( self . output_name ) # Copy config if not os . path . exists ( self . config_file ): shutil . copy2 ( config_file , self . config_file ) # Find all .bp files and extract last checkpoint from file name file_list = map ( os . path . splitext , os . listdir ( self . output_name )) file_list = filter ( lambda x : x [ 1 ] == \".bp\" , file_list ) file_list = list ( file_list ) # Recover data from previous checkpoint if len ( file_list ) != 0 : self . last_checkpoint = int ( file_list [ - 1 ][ 0 ]) logger . info ( f \"Recovering data from checkpoint { self . last_checkpoint } \" ) prev_output_file = os . path . join ( self . output_name , f \" { self . last_checkpoint } .bp\" ) with adios2 . FileReader ( prev_output_file ) as s : attrs = s . available_attributes () vars = s . available_variables () steps = int ( vars [ \"weights\" ][ \"AvailableStepsCount\" ]) self . first_iter = int ( attrs [ \"last_iter\" ][ \"Value\" ]) self . weights = s . read ( \"weights\" , step_selection = [ steps - 1 , 1 ]) self . recovered = True else : self . last_checkpoint = - 1 self . first_iter = None self . weights = None self . recovered = False self . output_file = os . path . join ( self . output_name , f \" { self . last_checkpoint + 1 } .bp\" ) # Create ADIOS2 stream self . output_stream = adios2 . Stream ( self . output_file , \"w\" ) def __del__ ( self ): \"\"\" Deinitializes the object and closes the ADIOS2 output stream. \"\"\" logger . info ( \"Closing output stream\" ) self . output_stream . close () __del__ () Deinitializes the object and closes the ADIOS2 output stream. Source code in src/output.py 80 81 82 83 84 85 def __del__ ( self ): \"\"\" Deinitializes the object and closes the ADIOS2 output stream. \"\"\" logger . info ( \"Closing output stream\" ) self . output_stream . close () __init__ ( output_name , config_file ) Initializes the object Parameters: Name Type Description Default output_name str The output folder name where data will be stored. required config_file str The path of the configuration file, which will be copyied to the output data folder. required Source code in src/output.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def __init__ ( self , output_name : str , config_file : str ): \"\"\" Initializes the object Parameters: output_name (str): The output folder name where data will be stored. config_file (str): The path of the configuration file, which will be copyied to the output data folder. \"\"\" self . output_name = output_name self . config_file = os . path . join ( self . output_name , config_file ) # Create output dir if not os . path . exists ( self . output_name ): os . makedirs ( self . output_name ) # Copy config if not os . path . exists ( self . config_file ): shutil . copy2 ( config_file , self . config_file ) # Find all .bp files and extract last checkpoint from file name file_list = map ( os . path . splitext , os . listdir ( self . output_name )) file_list = filter ( lambda x : x [ 1 ] == \".bp\" , file_list ) file_list = list ( file_list ) # Recover data from previous checkpoint if len ( file_list ) != 0 : self . last_checkpoint = int ( file_list [ - 1 ][ 0 ]) logger . info ( f \"Recovering data from checkpoint { self . last_checkpoint } \" ) prev_output_file = os . path . join ( self . output_name , f \" { self . last_checkpoint } .bp\" ) with adios2 . FileReader ( prev_output_file ) as s : attrs = s . available_attributes () vars = s . available_variables () steps = int ( vars [ \"weights\" ][ \"AvailableStepsCount\" ]) self . first_iter = int ( attrs [ \"last_iter\" ][ \"Value\" ]) self . weights = s . read ( \"weights\" , step_selection = [ steps - 1 , 1 ]) self . recovered = True else : self . last_checkpoint = - 1 self . first_iter = None self . weights = None self . recovered = False self . output_file = os . path . join ( self . output_name , f \" { self . last_checkpoint + 1 } .bp\" ) # Create ADIOS2 stream self . output_stream = adios2 . Stream ( self . output_file , \"w\" )","title":"output"},{"location":"module_output/#module-output","text":"Contains handlers for ouputting and recovering ADIOS2 training data.","title":"Module output"},{"location":"module_output/#output.Output","text":"Holds a stream-writtable ADIOS2 file and creates new output files with the the correct naming convention for checkpointing. Source code in src/output.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class Output : \"\"\" Holds a stream-writtable ADIOS2 file and creates new output files with the the correct naming convention for checkpointing. \"\"\" def __init__ ( self , output_name : str , config_file : str ): \"\"\" Initializes the object Parameters: output_name (str): The output folder name where data will be stored. config_file (str): The path of the configuration file, which will be copyied to the output data folder. \"\"\" self . output_name = output_name self . config_file = os . path . join ( self . output_name , config_file ) # Create output dir if not os . path . exists ( self . output_name ): os . makedirs ( self . output_name ) # Copy config if not os . path . exists ( self . config_file ): shutil . copy2 ( config_file , self . config_file ) # Find all .bp files and extract last checkpoint from file name file_list = map ( os . path . splitext , os . listdir ( self . output_name )) file_list = filter ( lambda x : x [ 1 ] == \".bp\" , file_list ) file_list = list ( file_list ) # Recover data from previous checkpoint if len ( file_list ) != 0 : self . last_checkpoint = int ( file_list [ - 1 ][ 0 ]) logger . info ( f \"Recovering data from checkpoint { self . last_checkpoint } \" ) prev_output_file = os . path . join ( self . output_name , f \" { self . last_checkpoint } .bp\" ) with adios2 . FileReader ( prev_output_file ) as s : attrs = s . available_attributes () vars = s . available_variables () steps = int ( vars [ \"weights\" ][ \"AvailableStepsCount\" ]) self . first_iter = int ( attrs [ \"last_iter\" ][ \"Value\" ]) self . weights = s . read ( \"weights\" , step_selection = [ steps - 1 , 1 ]) self . recovered = True else : self . last_checkpoint = - 1 self . first_iter = None self . weights = None self . recovered = False self . output_file = os . path . join ( self . output_name , f \" { self . last_checkpoint + 1 } .bp\" ) # Create ADIOS2 stream self . output_stream = adios2 . Stream ( self . output_file , \"w\" ) def __del__ ( self ): \"\"\" Deinitializes the object and closes the ADIOS2 output stream. \"\"\" logger . info ( \"Closing output stream\" ) self . output_stream . close ()","title":"Output"},{"location":"module_output/#output.Output.__del__","text":"Deinitializes the object and closes the ADIOS2 output stream. Source code in src/output.py 80 81 82 83 84 85 def __del__ ( self ): \"\"\" Deinitializes the object and closes the ADIOS2 output stream. \"\"\" logger . info ( \"Closing output stream\" ) self . output_stream . close ()","title":"__del__"},{"location":"module_output/#output.Output.__init__","text":"Initializes the object Parameters: Name Type Description Default output_name str The output folder name where data will be stored. required config_file str The path of the configuration file, which will be copyied to the output data folder. required Source code in src/output.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def __init__ ( self , output_name : str , config_file : str ): \"\"\" Initializes the object Parameters: output_name (str): The output folder name where data will be stored. config_file (str): The path of the configuration file, which will be copyied to the output data folder. \"\"\" self . output_name = output_name self . config_file = os . path . join ( self . output_name , config_file ) # Create output dir if not os . path . exists ( self . output_name ): os . makedirs ( self . output_name ) # Copy config if not os . path . exists ( self . config_file ): shutil . copy2 ( config_file , self . config_file ) # Find all .bp files and extract last checkpoint from file name file_list = map ( os . path . splitext , os . listdir ( self . output_name )) file_list = filter ( lambda x : x [ 1 ] == \".bp\" , file_list ) file_list = list ( file_list ) # Recover data from previous checkpoint if len ( file_list ) != 0 : self . last_checkpoint = int ( file_list [ - 1 ][ 0 ]) logger . info ( f \"Recovering data from checkpoint { self . last_checkpoint } \" ) prev_output_file = os . path . join ( self . output_name , f \" { self . last_checkpoint } .bp\" ) with adios2 . FileReader ( prev_output_file ) as s : attrs = s . available_attributes () vars = s . available_variables () steps = int ( vars [ \"weights\" ][ \"AvailableStepsCount\" ]) self . first_iter = int ( attrs [ \"last_iter\" ][ \"Value\" ]) self . weights = s . read ( \"weights\" , step_selection = [ steps - 1 , 1 ]) self . recovered = True else : self . last_checkpoint = - 1 self . first_iter = None self . weights = None self . recovered = False self . output_file = os . path . join ( self . output_name , f \" { self . last_checkpoint + 1 } .bp\" ) # Create ADIOS2 stream self . output_stream = adios2 . Stream ( self . output_file , \"w\" )","title":"__init__"},{"location":"module_problem/","text":"Module problem Generic problem solvable by training a quantum circuit. Problem Source code in src/problem.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Problem ( metaclass = abc . ABCMeta ): def __init__ ( self ): \"\"\" Initializes the problem object. Attributes: map (DomainMap): A domain map for the problem. target (array): List of taret values for the problem (the true solution of the problem). f (callable): A function that returns the true solution value when called for all points in `x`. \"\"\" self . map = None self . target = None self . f = None @abc . abstractmethod def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" pass @abc . abstractmethod def get_domain_map ( self ): \"\"\" Returns: (DomainMap): Returns the domain map of the problem. \"\"\" pass __init__ () Initializes the problem object. Attributes: Name Type Description map DomainMap A domain map for the problem. target array List of taret values for the problem (the true solution of the problem). f callable A function that returns the true solution value when called for all points in x . Source code in src/problem.py 9 10 11 12 13 14 15 16 17 18 19 20 def __init__ ( self ): \"\"\" Initializes the problem object. Attributes: map (DomainMap): A domain map for the problem. target (array): List of taret values for the problem (the true solution of the problem). f (callable): A function that returns the true solution value when called for all points in `x`. \"\"\" self . map = None self . target = None self . f = None cost ( node , weights , data , N ) abstractmethod Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/problem.py 22 23 24 25 26 27 28 29 30 31 32 33 @abc . abstractmethod def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" pass get_domain_map () abstractmethod Returns: (DomainMap): Returns the domain map of the problem. Source code in src/problem.py 35 36 37 38 39 40 41 @abc . abstractmethod def get_domain_map ( self ): \"\"\" Returns: (DomainMap): Returns the domain map of the problem. \"\"\" pass","title":"problem"},{"location":"module_problem/#module-problem","text":"Generic problem solvable by training a quantum circuit.","title":"Module problem"},{"location":"module_problem/#problem.Problem","text":"Source code in src/problem.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Problem ( metaclass = abc . ABCMeta ): def __init__ ( self ): \"\"\" Initializes the problem object. Attributes: map (DomainMap): A domain map for the problem. target (array): List of taret values for the problem (the true solution of the problem). f (callable): A function that returns the true solution value when called for all points in `x`. \"\"\" self . map = None self . target = None self . f = None @abc . abstractmethod def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" pass @abc . abstractmethod def get_domain_map ( self ): \"\"\" Returns: (DomainMap): Returns the domain map of the problem. \"\"\" pass","title":"Problem"},{"location":"module_problem/#problem.Problem.__init__","text":"Initializes the problem object. Attributes: Name Type Description map DomainMap A domain map for the problem. target array List of taret values for the problem (the true solution of the problem). f callable A function that returns the true solution value when called for all points in x . Source code in src/problem.py 9 10 11 12 13 14 15 16 17 18 19 20 def __init__ ( self ): \"\"\" Initializes the problem object. Attributes: map (DomainMap): A domain map for the problem. target (array): List of taret values for the problem (the true solution of the problem). f (callable): A function that returns the true solution value when called for all points in `x`. \"\"\" self . map = None self . target = None self . f = None","title":"__init__"},{"location":"module_problem/#problem.Problem.cost","text":"Returns the cost function of the problem. Parameters: Name Type Description Default node QuantumNode The quantum node used for evaluating the circuit. required weights array The array of weights representing the free parameters in the circuit. required data array The input domain data of the problem. required N int The size of the input domain data. required Source code in src/problem.py 22 23 24 25 26 27 28 29 30 31 32 33 @abc . abstractmethod def cost ( self , node , weights , data , N ): \"\"\" Returns the cost function of the problem. Parameters: node (QuantumNode): The quantum node used for evaluating the circuit. weights (array): The array of weights representing the free parameters in the circuit. data (array): The input domain data of the problem. N (int): The size of the input domain data. \"\"\" pass","title":"cost"},{"location":"module_problem/#problem.Problem.get_domain_map","text":"Returns: (DomainMap): Returns the domain map of the problem. Source code in src/problem.py 35 36 37 38 39 40 41 @abc . abstractmethod def get_domain_map ( self ): \"\"\" Returns: (DomainMap): Returns the domain map of the problem. \"\"\" pass","title":"get_domain_map"},{"location":"module_quantum_derivatives/","text":"Module quantum_derivatives Contains definitions for taking derivatives of quantum circuits that represent functions. d2f ( node , weights , x ) Takes the second derivative of a quantum circuit. Parameters: Name Type Description Default node QuantumNode The quantum node that will evaluate the circuit. required weights array A list of circuit weights. required x float The point where the derivative is to be computed. required Returns: Type Description flot The value of the second derivative of the function represented by the circuit in point x Source code in src/quantum_derivatives.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def d2f ( node , weights , x ): \"\"\" Takes the second derivative of a quantum circuit. Parameters: node (QuantumNode): The quantum node that will evaluate the circuit. weights (array): A list of circuit weights. x (float): The point where the derivative is to be computed. Returns: (flot): The value of the second derivative of the function represented by the circuit in point `x` \"\"\" f = node ( weights , x = x ) fp = node ( weights , x = ( x + np . pi )) fm = node ( weights , x = ( x - np . pi )) return ( fm + fp - 2.0 * f ) / 4.0 df ( node , weights , x ) Takes the first derivative of a quantum circuit. Parameters: Name Type Description Default node QuantumNode The quantum node that will evaluate the circuit. required weights array A list of circuit weights. required x float The point where the derivative is to be computed. required Returns: Type Description flot The value of the first derivative of the function represented by the circuit in point x Source code in src/quantum_derivatives.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def df ( node , weights , x ): \"\"\" Takes the first derivative of a quantum circuit. Parameters: node (QuantumNode): The quantum node that will evaluate the circuit. weights (array): A list of circuit weights. x (float): The point where the derivative is to be computed. Returns: (flot): The value of the first derivative of the function represented by the circuit in point `x` \"\"\" fp_2 = node ( weights , x = ( x + np . pi / 2.0 )) fm_2 = node ( weights , x = ( x - np . pi / 2.0 )) return ( fp_2 + fm_2 ) / 2.0","title":"quantum_derivatives"},{"location":"module_quantum_derivatives/#module-quantum_derivatives","text":"Contains definitions for taking derivatives of quantum circuits that represent functions.","title":"Module quantum_derivatives"},{"location":"module_quantum_derivatives/#quantum_derivatives.d2f","text":"Takes the second derivative of a quantum circuit. Parameters: Name Type Description Default node QuantumNode The quantum node that will evaluate the circuit. required weights array A list of circuit weights. required x float The point where the derivative is to be computed. required Returns: Type Description flot The value of the second derivative of the function represented by the circuit in point x Source code in src/quantum_derivatives.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def d2f ( node , weights , x ): \"\"\" Takes the second derivative of a quantum circuit. Parameters: node (QuantumNode): The quantum node that will evaluate the circuit. weights (array): A list of circuit weights. x (float): The point where the derivative is to be computed. Returns: (flot): The value of the second derivative of the function represented by the circuit in point `x` \"\"\" f = node ( weights , x = x ) fp = node ( weights , x = ( x + np . pi )) fm = node ( weights , x = ( x - np . pi )) return ( fm + fp - 2.0 * f ) / 4.0","title":"d2f"},{"location":"module_quantum_derivatives/#quantum_derivatives.df","text":"Takes the first derivative of a quantum circuit. Parameters: Name Type Description Default node QuantumNode The quantum node that will evaluate the circuit. required weights array A list of circuit weights. required x float The point where the derivative is to be computed. required Returns: Type Description flot The value of the first derivative of the function represented by the circuit in point x Source code in src/quantum_derivatives.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def df ( node , weights , x ): \"\"\" Takes the first derivative of a quantum circuit. Parameters: node (QuantumNode): The quantum node that will evaluate the circuit. weights (array): A list of circuit weights. x (float): The point where the derivative is to be computed. Returns: (flot): The value of the first derivative of the function represented by the circuit in point `x` \"\"\" fp_2 = node ( weights , x = ( x + np . pi / 2.0 )) fm_2 = node ( weights , x = ( x - np . pi / 2.0 )) return ( fp_2 + fm_2 ) / 2.0","title":"df"}]}